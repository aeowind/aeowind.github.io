<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="你的舞步划过空空的房间，时光就变成了烟">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础（二）">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="你的舞步划过空空的房间，时光就变成了烟">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.404Z">
<meta property="article:modified_time" content="2021-06-01T09:02:40.252Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础（二） | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-01 17:02:40" itemprop="dateModified" datetime="2021-06-01T17:02:40+08:00">2021-06-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">你的舞步划过空空的房间，时光就变成了烟</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="常用类">常用类</h1>
<h2 id="string类">string类</h2>
<p><code>java.lang.String</code> 类的使用 ### 概述
<code>String</code>:字符串，使用一对""引起来表示。</p>
<ol type="1">
<li><p>String声明为<code>final</code>的，不可被继承</p></li>
<li><p>String
实现了<code>Serializable 接口</code>：表示字符串是支持序列化的。实现了<code>Comparable接口</code>：表示String可以比较大小</p></li>
<li><p>String内部定义了<code>final char[] value</code>用于存储字符串数据</p></li>
<li><p>String:代表不可变的字符序列。简称：<strong>不可变性</strong>。</p></li>
</ol>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的 replace()
方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
<ol start="5" type="1">
<li><p>通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。</p></li>
<li><p>字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的)。</p></li>
</ol>
<h3 id="string特性">String特性</h3>
<p><code>String类</code>：代表字符串。<br />
Java程序中的所有字符串字面值（如"abc"）都作为此类的实例实现。<br />
String是一个<code>final类</code>，代表不可变的字符序列。
字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。<br />
String对象的字符内容是存储在一个字符数组<code>vaue[]</code>中的。</p>
<blockquote>
<p><strong>String源码构造器:</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure> ####
String的不可变性 <strong>说明：</strong> -
当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
-
当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
-
当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
</blockquote>
<h4 id="string实例化方法">String实例化方法</h4>
<blockquote>
<p><strong>实现方式：</strong> -
<strong>方式一</strong>：通过<code>字面量定义</code>的方式 -
<strong>方式二</strong>：通过<code>new + 构造器</code>的方式</p>
</blockquote>
<p><strong><em>面试题：</em></strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;abc&quot;); 方式创建对象，在内存中创建了几个对象？</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：&quot;abc&quot;</span><br></pre></td></tr></table></figure> &gt;
<strong>代码实例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="comment">//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure> &gt;
<code>String str1=“abc”;</code> 与
<code>String str2= new String(“abc”);</code>的区别? <a
target="_blank" rel="noopener" href="https://imgtu.com/i/2PMCk9"><img
src="https://z3.ax1x.com/2021/05/27/2PMCk9.png"
alt="2PMCk9.png" /></a></p>
<blockquote>
<p>新建String对象的内存解析 <a target="_blank" rel="noopener" href="https://imgtu.com/i/2PMMtA"><img
src="https://z3.ax1x.com/2021/05/27/2PMMtA.png"
alt="2PMMtA.png" /></a></p>
</blockquote>
<h4 id="字符串拼接方式赋值对比">字符串拼接方式赋值对比</h4>
<ol type="1">
<li><code>常量与常量</code>的拼接结果在<strong>常量池</strong>。且常量池中不会存在相同内容的常量。</li>
<li>只要其中一个是<code>变量</code>，结果就在<strong>堆</strong>中。</li>
<li>如果拼接的结果调用
<code>intern() 方法</code>，返回值就在<strong>常量池</strong>中</li>
</ol>
<blockquote>
<p><strong>代码示例:</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();<span class="comment">//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">****************************</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure> <strong>内存解析:</strong>
<a target="_blank" rel="noopener" href="https://imgtu.com/i/2PMx3t"><img
src="https://z3.ax1x.com/2021/05/27/2PMx3t.png"
alt="2PMx3t.png" /></a></p>
</blockquote>
<h4 id="string类常用方法">String类常用方法</h4>
<h5 id="字符串操作"><strong>字符串操作</strong></h5>
<ul>
<li><code>int length()</code>：返回字符串的长度： return
value.length<br />
</li>
<li><code>char charAt(int index)</code>： 返回某索引处的字符 return
value[index]<br />
</li>
<li><code>boolean isEmpty()</code>：判断是否是空字符串：return
value.length == 0<br />
</li>
<li><code>String toLowerCase()</code>：使用默认语言环境，将 String
中的所字符转换为小写<br />
</li>
<li><code>String toUpperCase()</code>：使用默认语言环境，将 String
中的所字符转换为大写<br />
</li>
<li><code>String trim()</code>：返回字符串的副本，忽略前导空白和尾部空白<br />
</li>
<li><code>boolean equals(Object obj)</code>：比较字符串的内容是否相同<br />
</li>
<li><code>boolean equalsIgnoreCase(String anotherString)</code>：与
equals() 方法类似，忽略大小写<br />
</li>
<li><code>String concat(String str)</code>：将指定字符串连接到此字符串的结尾。
等价于用 +<br />
</li>
<li><code>int compareTo(String anotherString)</code>：比较两个字符串的大小<br />
</li>
<li><code>String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的从beginIndex
开始截取到最后的一个子字符串。<br />
</li>
<li><code>String substring(int beginIndex, int endIndex)</code>
：返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex
(不包含)的一个子字符串。</li>
</ul>
<blockquote>
<p><strong>判断字符：</strong> -
<code>boolean endsWith(String suffix)</code>：测试此字符串是否以指定的后缀结束
-
<code>boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开始
-
<code>boolean startsWith(String prefix, int toffset)</code>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p>
</blockquote>
<h5 id="查找字符串中的字符">查找字符串中的字符</h5>
<ul>
<li><code>boolean contains(CharSequence s)</code>：当且仅当此字符串包含指定的
char 值序列时，返回 true</li>
<li><code>int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引</li>
<li><code>int indexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>
<li><code>int lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最右边出现处的索引</li>
<li><code>int lastIndexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</li>
</ul>
<h4 id="string与其他结构的转换">String与其他结构的转换</h4>
<h5
id="string与基本数据类型包装类之间的转换">String与基本数据类型、包装类之间的转换</h5>
<ul>
<li><p><strong>String</strong> --&gt;
基本数据类型、包装类：调用包装类的静态方法：<code>parseXxx(str)</code></p></li>
<li><p><strong>基本数据类型、包装类</strong> --&gt;
String:调用String重载的 <code>valueOf(xxx)</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToBasic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(i == <span class="number">123</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(j);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(s.equals(<span class="string">&quot;456&quot;</span>));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #####
与字符数组之间的转换 <strong>String</strong> --&gt;
<strong>char[]</strong>:调用String的 <code>toCharArray() char[]</code>
--&gt; <strong>String</strong>:调用String的构造器 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BasicToString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        System.out.println(chars[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    System.out.println(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #####
与字节数组之间的转换</p></li>
<li><p><strong>编码</strong>：String --&gt; byte[]:调用String的
getBytes()</p></li>
<li><p><strong>解码</strong>：byte[] --&gt;
String:调用String的构造器</p></li>
<li><p><strong>编码</strong>：字符串 --&gt;字节 (看得懂
---&gt;看不懂的二进制数据)</p></li>
<li><p><strong>解码</strong>：编码的逆过程，字节 --&gt; 字符串
（看不懂的二进制数据 ---&gt; 看得懂</p></li>
<li><p><strong>说明</strong>：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToByteTest</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span><span class="string">&quot;你好java世界&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytesArray = s1.getBytes();<span class="comment">//使用默认字符集编码</span></span><br><span class="line">    System.out.println(Arrays.toString(bytesArray));<span class="comment">//[-28, -67, -96, -27, -91, -67, 106, 97, 118, 97, -28, -72, -106, -25, -107, -116]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] gbks = s1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk编码集合</span></span><br><span class="line">    System.out.println(Arrays.toString(gbks));<span class="comment">//[-60, -29, -70, -61, 106, 97, 118, 97, -54, -64, -67, -25]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String str1=<span class="keyword">new</span> <span class="title class_">String</span>(bytesArray);<span class="comment">//使用默认字符进行解码</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//你好java世界</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);<span class="comment">//使用默认字符对gbk编码进行解码</span></span><br><span class="line">    System.out.println(str2);<span class="comment">//���java����解码错误，出现中文乱码,原因：编码和解码不一致</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk格式进行解码</span></span><br><span class="line">    System.out.println(str3);<span class="comment">//你好java世界，解码正确，原因：编码和解码一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="与stringbufferstringbuilder之间的转换">与StringBuffer、StringBuilder之间的转换</h5>
<ol type="1">
<li><p><strong>String</strong>
--&gt;<strong>StringBuffer、StringBuilder</strong>:
调用StringBuffer、StringBuilder构造器</p></li>
<li><p>StringBuffer、StringBuilder --&gt;String:</p></li>
</ol>
<ul>
<li><p>调用String构造器；</p></li>
<li><p>StringBuffer、StringBuilder的toString()</p></li>
</ul>
<h4 id="jvm中字符串常量池存放说明">JVM中字符串常量池存放说明：</h4>
<ul>
<li><p><code>jdk 1.6 (jdk 6.0 ,java 6.0)</code>:字符串常量池存储在<strong>方法区（永久区）</strong></p></li>
<li><p><code>jdk 1.7</code>:字符串常量池存储在<strong>堆空间</strong></p></li>
<li><p><code>jdk 1.8</code>:字符串常量池存储在<strong>方法区（元空间）</strong></p></li>
</ul>
<h2 id="stringbuffer和stringbuilder">StringBuffer和StringBuilder</h2>
<h3 id="stringbuffer类">StringBuffer类</h3>
<p><code>java.lang.String.Buffer</code>
代表<strong>可变的字符序列</strong>，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。很多方法与String相同。<br />
作为参数传递时，方法内部可以改变值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;<span class="comment">//value没有final声明，value可以不断扩容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//count记录有效字符个数</span></span><br></pre></td></tr></table></figure>
<p><code>StringBuffer类</code>不同于
String，其对象必须使用<strong>构造器</strong>生成。</p>
<p>有三个构造器:</p>
<ol type="1">
<li><code>StringBuffer()</code>：初始容量为16的字符串缓冲区</li>
<li><code>StringBuffer(int size)</code>：构造指定容量的字符串缓冲区</li>
<li><code>StringBuffer(String str)</code>：将内容初始化为指定字符串内容
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s= new String(&quot;我喜欢学习&quot;)；</span><br><span class="line">StringBuffer buffer= new StringBuffer(&quot;我喜欢学习&quot;)；</span><br><span class="line">buffer. append(&quot;数学&quot;);</span><br></pre></td></tr></table></figure> #### 常用方法</li>
<li><code>StringBuffer append(xxx)</code>：提供了很多的 append()
方法，用于进行字符串拼接</li>
<li><code>StringBuffer delete(int start,int end)</code>：删除指定位置的内容</li>
<li><code>StringBuffer replace(int start, int end, String str)</code>：把[start,end)位置替换为str</li>
<li><code>StringBuffer insert(int offset, xxx)</code>：在指定位置插入xxx</li>
<li><code>StringBuffer reverse()</code> ：把当前字符序列逆转</li>
</ol>
<p>当<code>append</code>和<code>insert</code>时，如果原来vaue数组长度不够，<strong>可扩容</strong>。
如上这些方法支持<strong>方法链操作</strong>。<br />
<strong>方法链的原理</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
<code>public int indexOf(String str)</code>：返回子串的下标 -
<code>public String substring(int start,int end)</code>:返回一个从start开始到end索引结束的左闭右开区间的子字符串
- <code>public int length()</code>：获取字符串的长度 -
<code>public char charAt(int n)</code>：返回指定位置的字符 -
<code>public void setCharAt(int n ,char ch)</code>：设置指定位置的字符</p>
<blockquote>
<p><strong>总结：</strong> - <strong>增</strong>：append(xxx) ； -
<strong>删</strong>：delete(int start,int end) ； -
<strong>改</strong>：setCharAt(int n ,char ch) / replace(int start, int
end, String str) ； - <strong>查</strong>：charAt(int n ) ； -
<strong>插</strong>：insert(int offset, xxx) ； -
<strong>长度</strong>：length(); - <strong>遍历</strong>：for() +
charAt() / toString()；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringBufferMethodTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1.append(<span class="string">&quot;1&quot;</span>));<span class="comment">//abc1</span></span><br><span class="line">    System.out.println(s1.delete(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//bc1</span></span><br><span class="line">    System.out.println(s1.replace(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>));<span class="comment">//helloc1</span></span><br><span class="line">    System.out.println(s1.insert(<span class="number">3</span>, <span class="string">&quot;v&quot;</span>));<span class="comment">//helvloc1</span></span><br><span class="line">    System.out.println(s1.reverse());<span class="comment">//1colvleh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stringbuilder类">StringBuilder类</h3>
<p>StringBuilder和
StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样，只是<code>StringBuilder类</code><strong>没有加线程锁</strong>，执行效率更高。
#### String、StringBuffer、StringBuilder三者的对比 -
<strong>String</strong>:不可变的字符序列；底层使用 char[]
存储；占用内存（会不断的创建和回收对象） -
<strong>StringBuffer</strong>:可变的字符序列；线程安全的，效率低；线程安全；底层使用char[]存储；
-
<strong>StringBuilder</strong>:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；线程不安全；底层使用
char[] 存储</p>
<p><strong><em>注意：</em></strong>
作为参数传递的话，方法内部String不会改变其值，
<code>StringBuffer</code>和<code>StringBuilder</code>会<strong>改变其值</strong>。</p>
<h4
id="stringbuffer与stringbuilder的内存解析">StringBuffer与StringBuilder的内存解析</h4>
<blockquote>
<p><strong><em>以StringBuffer为例:</em></strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure>
<strong><em>StringBuffer构造器源码：</em></strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
<strong>问题1.</strong> System.out.println(sb2.length());//3 -
<strong>问题2.</strong>
扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
默认情况下，扩容为原来容量的2倍 +
2，同时将原有数组中的元素复制到新的数组中。 -
<strong>指导意义：</strong> 开发中建议大家使用：StringBuffer(int
capacity) 或 StringBuilder(int capacity)</p>
</blockquote>
<h4
id="对比stringstringbufferstringbuilder三者的执行效率">对比String、StringBuffer、StringBuilder三者的执行效率</h4>
<p>从高到低排列：<code>StringBuilder &gt; StringBuffer &gt; String</code>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        builder.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        text = text + i;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="jdk-8.0以前的日期时间api">JDK 8.0以前的日期时间API</h2>
<h3 id="java.lang.system类">java.lang.System类</h3>
<p><code>System类</code>提供的
<code>public static long currentTimeMillis()</code>
用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。(<strong>时间戳</strong>)
此方法适于计算时间差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取系统当前时间：System类中的currentTimeMillis()</span><br><span class="line">long time = System.currentTimeMillis();</span><br><span class="line">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span><br><span class="line">//称为时间戳</span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure>
<h3 id="java.util.date类">java.util.Date类</h3>
<p>表示特定的瞬间，精确到毫秒 #### 构造器 -
<code>Date()</code>:使用无参的构造器创建对象可以获取本地当前时间</p>
<ul>
<li><code>Date(long date)</code></li>
</ul>
<h4 id="常用方法">常用方法</h4>
<ul>
<li><p><code>getTime()</code>：返回自1970年1月1日00：00：00GMT以来此Date对象表示的毫秒数</p></li>
<li><p><code>tostring()</code>：把此Date对象转换为以下形式的
String：<br />
</p></li>
</ul>
<ol type="1">
<li>dow mon dd</li>
<li>hh: mm:ss zzz yyyy</li>
</ol>
<h4
id="java.util.date类与java.sql.date类">java.util.Date类与java.sql.Date类</h4>
<ul>
<li><code>java.util.Date</code> 类</li>
<li><code>java.sql.Date</code> 类</li>
</ul>
<ol type="1">
<li>两个构造器的使用</li>
</ol>
<ul>
<li>构造器一：<code>Date()</code>：创建一个对应当前时间的Date对象</li>
<li>构造器二：创建指定毫秒数的Date对象</li>
</ul>
<ol start="2" type="1">
<li>两个方法的使用</li>
</ol>
<ul>
<li><code>toString()</code>:显示当前的年、月、日、时、分、秒</li>
<li><code>getTime()</code>:获取当前Date对象对应的毫秒数。（时间戳）</li>
</ul>
<ol start="3" type="1">
<li><code>java.sql.Date</code> 对应着数据库中的日期类型的变量<br />
如何将 <code>java.util.Date</code> 对象转换为 <code>java.sql.Date</code>
对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dateTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date1.toString());<span class="comment">//Sun Apr 19 13:35:12 CST 2020</span></span><br><span class="line">    System.out.println(date1.getTime());<span class="comment">//1587274512876</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">15872745176L</span>);</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">1587274512876L</span>);</span><br><span class="line">    System.out.println(date3.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//第一种方式，存在问题：java.util.Date cannot be cast to java.sql.Date</span></span><br><span class="line">    <span class="comment">//        java.sql.Date date6 = (java.sql.Date) date4;</span></span><br><span class="line">    <span class="comment">//        System.out.println(date6);</span></span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date4.getTime());</span><br><span class="line">    System.out.println(date5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### java.text.SimpleDateFormat类
Date类的AP不易于国际化，大部分被废弃了，<code>java.text.SimpleDateFormat</code>类是一个不与语言环境有关的方式来格式化和解析日期的具体类。<br />
它允许进行格式化：日期→文本、解析：文本→日期</li>
</ol>
<blockquote>
<p><strong>格式化：</strong> -
<code>SimpleDateFormat()</code>：默认的模式和语言环境创建对象 -
<code>public SimpleDateFormat(String pattern)</code>：该构造方法可以用参数
pattern指定的格式创建一个对象，该对象调用：
<code>public String format(Datedate)</code>：方法格式化时间对象date</p>
</blockquote>
<blockquote>
<p><strong>解析： </strong></p>
</blockquote>
<p><code>public Date parse(String source)</code>：从给定字符串的开始解析文本，以生成个日期</p>
<blockquote>
<p><code>SimpleDateFormat</code>对日期<code>Date类</code>的格式化和解析</p>
</blockquote>
<p>两个操作：</p>
<ol type="1">
<li><p>格式化：<strong>日期 ---&gt;字符串</strong></p></li>
<li><p>解析：<strong>格式化的逆过程，字符串 ---&gt;
日期</strong></p></li>
</ol>
<blockquote>
<p><code>SimpleDateFormat</code> 的实例化:<strong>new +
构造器</strong></p>
</blockquote>
<p>照指定的方式格式化和解析：<strong>调用带参的构造器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码示例：</em></strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">//实例化Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//实例化SimpleDateFormate对象，并设置显示格式</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:aaa&quot;</span>);</span><br><span class="line">    <span class="comment">//格式化date对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">    System.out.println(format.toString());<span class="comment">//2020-09-19 02:09:下午</span></span><br><span class="line">    <span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),</span></span><br><span class="line">    <span class="comment">//否则，抛异常</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2020-04-20 14:20:下午&quot;</span>);</span><br><span class="line">    System.out.println(date2.toString());<span class="comment">//Tue Jan 21 02:20:00 CST 2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
将字符串"2020-09-08"转换为 java.sql.Date 格式的时间 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brith</span> <span class="operator">=</span> <span class="string">&quot;1997-10-15&quot;</span>;</span><br><span class="line">    <span class="comment">//新建SimpleDateFormat对象并设置时间格式</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpBrith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line">    <span class="comment">//将字符串格式的时间格式化为Date类</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">brithday</span> <span class="operator">=</span> simpBrith.parse(brith);</span><br><span class="line">    <span class="comment">//通过Date的getTime方法将Date对象转化为时间戳放到java.sql.date类的构造方法中</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">brithDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(brithday.getTime());</span><br><span class="line">    System.out.println(brithDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ####
Calender类：日历类，抽象类
<code>Calendar</code>是一个<strong>抽象基类</strong>，主用用于完成日期字段之间相互操作的功能。</p>
<ul>
<li>获取<code>Calenda实例</code>的方法
使用<code>Calendar.getInstance()方法</code>调用它的子类
<code>GregorianCalendarl的构造器</code>。</li>
<li>一个<code>Calendar</code>的实例是系统时间的抽象表示，通过<code>get(int field)</code>方法来取得想要的时间信息。
比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND</li>
</ul>
<blockquote>
<p><strong>实例化</strong><br />
方式一：创建其子类(<code>GregorianCalendar</code>)的对象</p>
</blockquote>
<p>方式二：调用其静态方法 <code>getInstance()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>常用方法</strong> - <code>get()</code>: 获取日期</p>
</blockquote>
<ul>
<li><p><code>set()</code>: 设置日期</p></li>
<li><p><code>add()</code>: 添加、修改日期</p></li>
<li><p><code>getTime</code>: 日历类--&gt;Date</p></li>
<li><p><code>setTime:Date</code>: --&gt;日历类</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//        System.out.println(calendar.getClass());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.常用方法</span></span><br><span class="line"><span class="comment">//get()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);<span class="comment">//获取本月第几天</span></span><br><span class="line">System.out.println(days);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//获取本年第几天</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set()</span></span><br><span class="line"><span class="comment">//calendar可变性</span></span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);<span class="comment">//设置本月第几天</span></span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getTime():日历类---&gt; Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTime():Date ---&gt; 日历类</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">calendar.setTime(date1);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<h2 id="jdk-8.0中新的日期时间类">JDK 8.0中新的日期时间类</h2>
<h3 id="日期时间api的迭代">日期时间API的迭代</h3>
<ul>
<li><p>第一代：jdk 1.0 Date类</p></li>
<li><p>第二代：jdk 1.1 Calendar类，一定程度上替换Date类</p></li>
<li><p>第三代：jdk 1.8 提出了新的一套API</p></li>
</ul>
<h3 id="前两代的问题">前两代的问题</h3>
<ul>
<li><strong>可变性</strong>：像日期和时间这样的类应该是不可变的。</li>
<li><strong>偏移性</strong>：Date中的年份是从1900开始的，而月份都从0开始。</li>
<li><strong>格式化</strong>：格式化只对Date用，Calendar则不行。
此外，它们也不是线程安全的；不能处理闰秒等。</li>
<li>Java 8.0中新引入的<code>java.time API</code>:</li>
<li>Java
8.0吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的APl。新的java.time中包含了所有关于本地日期(LocalDate)、本地时间(Localtime)、本地日期时间(LocalDate
time)、时区(ZonedDate
time)和持续时间(Duration)的类。历史悠久的Date类新增了tolnstant()方法用于把Date转换成新的表示形式。这些新增的本地化时间日期API大大简化了日期时间和本地化的管理。
<a target="_blank" rel="noopener" href="https://imgtu.com/i/2PqSzT"><img
src="https://z3.ax1x.com/2021/05/27/2PqSzT.png"
alt="2PqSzT.png" /></a></li>
</ul>
<h3
id="本地日期本地时间本地日期时间的使用">本地日期、本地时间、本地日期时间的使用</h3>
<h4 id="说明">说明</h4>
<ol type="1">
<li>分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</li>
<li><code>LocalDateTime</code>相较于LocalDate、LocalTime，使用频率要高</li>
<li>类似于<code>Calendar</code> #### 常用方法 <a
target="_blank" rel="noopener" href="https://imgtu.com/i/2Pqbp6"><img
src="https://z3.ax1x.com/2021/05/27/2Pqbp6.png" alt="2Pqbp6.png" /></a>
<strong><em>代码示例：</em></strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取当前的日期、时间、日期时间</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localTime);<span class="comment">//18:52:54.929</span></span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:52:54.929</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">12</span>);</span><br><span class="line">    System.out.println(localDateTime1);<span class="comment">//2020-10-06T12:13:12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());<span class="comment">//21</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line">    System.out.println(localDateTime.getMonth());<span class="comment">//APRIL</span></span><br><span class="line">    System.out.println(localDateTime.getMonthValue());<span class="comment">//4</span></span><br><span class="line">    System.out.println(localDateTime.getMinute());<span class="comment">//52</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//体现不可变性</span></span><br><span class="line">    <span class="comment">//withXxx():设置相关的属性</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDate.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localDate1);<span class="comment">//2020-04-22</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.withHour(<span class="number">4</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime2);<span class="comment">//2020-04-21T04:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不可变性</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime3</span> <span class="operator">=</span> localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime3);<span class="comment">//2020-07-21T18:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime4);<span class="comment">//2020-04-15T18:59:17.484</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 时间点：Instance
#### 说明</li>
</ol>
<ul>
<li>时间线上的一个瞬时点。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。）</li>
<li>类似于 <code>java.util.Date 类</code></li>
</ul>
<h4 id="常用方法-1">常用方法</h4>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2PvMa4"><img
src="https://z3.ax1x.com/2021/05/27/2PvMa4.png" alt="2PvMa4.png" /></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    System.out.println(instant);<span class="comment">//2020-04-21T11:03:21.469Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加时间的偏移量</span></span><br><span class="line">    <span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime);<span class="comment">//2020-04-21T19:03:21.469+08:00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">    System.out.println(milli);<span class="comment">//1587467105795</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1587467105795L</span>);</span><br><span class="line">    System.out.println(instant1);<span class="comment">//2020-04-21T11:05:05.795Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 日期时间格式化类：DateTimeFormatter #### 说明 -
格式化或解析日期、时间</p>
<ul>
<li>类似于 <code>SimpleDateFormat</code> #### 常用方法</li>
</ul>
<ol type="1">
<li>实例化方式：
预定义的标准格式。如：<code>ISO\_LOCAL\_DATE\_TIME;</code></li>
</ol>
<ul>
<li>ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式：</li>
<li>如：ofLocalizedDateTime(FormatStyle.LONG)</li>
<li>自定义的格式：如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li>
</ul>
<ol start="2" type="1">
<li>常用方法： <a target="_blank" rel="noopener" href="https://imgtu.com/i/2Px10S"><img
src="https://z3.ax1x.com/2021/05/27/2Px10S.png"
alt="2Px10S.png" /></a></li>
</ol>
<p>特别的：自定义的格式。如：<code>ofPattern(“yyyy-MM-dd hh:mm:ss”)</code>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//        方式一：预定义的标准格式。</span></span><br><span class="line">    <span class="comment">//        如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">//格式化:日期--&gt;字符串</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T19:13:13.530</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//2020-04-21T19:13:13.53</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析：字符串 --&gt;日期</span></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2000-04-21T19:13:13.53&quot;</span>);</span><br><span class="line">    System.out.println(parse);<span class="comment">//&#123;&#125;,ISO resolved to 2000-04-21T19:13:13.530</span></span><br><span class="line">    <span class="comment">//        方式二：</span></span><br><span class="line">    <span class="comment">//        本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line">    <span class="comment">//        FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">    System.out.println(str2);<span class="comment">//2020年4月21日 下午07时16分57秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line">    <span class="comment">//      FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> formatter2.format(LocalDate.now());</span><br><span class="line">    System.out.println(str3);<span class="comment">//2020-4-21</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//       重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">Str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(Str4);<span class="comment">//2020-04-21 07:24:04</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2020-02-03 05:23:06&quot;</span>);</span><br><span class="line">    System.out.println(accessor);<span class="comment">//&#123;SecondOfMinute=6, HourOfAmPm=5, NanoOfSecond=0, MicroOfSecond=0, MinuteOfHour=23, MilliOfSecond=0&#125;,ISO resolved to 2020-02-03</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="java比较器">Java比较器</h2>
<ul>
<li>Java中的对象，正常情况下，只能进行比较：<code>==</code> 或
<code>!=</code>。不能使用 <code>&gt;</code> 或 <code>&lt;</code> 的</li>
<li>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</li>
<li>如何实现？使用两个接口中的任何一个：<code>Comparable</code>（<strong>自然排序</strong>）
或 <code>Comparator</code>（<strong>定制排序</strong>）</li>
</ul>
<h3 id="自然排序使用compareble接口">自然排序：使用Compareble接口</h3>
<h4 id="说明-1">说明</h4>
<ol type="1">
<li><p>像<code>String</code>或<code>包装类</code>等实现了<code>Comparable接口</code>，重写了<code>compareTo(obj)</code>方法，给出了比较两个对象大小的方式。</p></li>
<li><p>像<code>String</code>或<code>包装类</code>重写<code>compareTo()</code>方法以后，进行了从小到大的排列</p></li>
<li><p>重写compareTo(obj)的规则：<br />
如果当前对象<code>this</code><strong>大于</strong>形参对象<code>obj</code>，则<strong>返回正整数</strong>，<br />
如果当前对象<code>this</code><strong>小于</strong>形参对象<code>obj</code>，则<strong>返回负整数</strong>，<br />
如果当前对象<code>this</code><strong>等于</strong>形参对象<code>obj</code>，则<strong>返回零</strong>。</p></li>
<li><p>对于自定义类来说，如果需要排序，我们可以让自定义类实现<code>Comparable接口</code>，重写<code>compareTo(obj)方法</code>。在<code>compareTo(obj)方法</code>中指明如何排序</p></li>
<li><p><code>Comparable</code>的典型实现：<br />
(默认都是从小到大排列的)<br />
<code>String</code>：按照字符串中字符的Uincode值进行比较<br />
<code>Character</code>：按照字符的 Unicode值来进行比较<br />
<code>数值类型对应的包装类以及 BigInteger、BigDecimal</code>：按照它们对应的数值大小进行比较<br />
<code>Boolean</code>：true对应的包装类实例大于false对应的包装类实例<br />
<code>Date、Time等</code>：后面的日期时间比前面的日期时间大</p></li>
</ol>
<h4 id="自定义类代码举例">自定义类代码举例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span>  <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照价格从低到高排序,再照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter、setter、toString()、构造器：省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定制排序使用comparator接口">定制排序：使用Comparator接口</h3>
<h4 id="说明-2">说明</h4>
<ol type="1">
<li>当元素的类型没实现 <code>java.lang.Comparable</code>
接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用
<code>Comparator</code> 的对象来排序<br />
</li>
<li>重写 <code>compare(Object o1,Object o2)</code>
方法，比较o1和o2的大小：</li>
</ol>
<ul>
<li>如果方法返回正整数，则表示o1大于o2；</li>
<li>如果返回0，表示相等；</li>
<li>返回负整数，表示o1小于o2。</li>
</ul>
<blockquote>
<p><strong>代码举例:</strong></p>
</blockquote>
<h3 id="两种排序方式对比">两种排序方式对比</h3>
<ul>
<li>Comparable接口的方式是一定的，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li>
<li>Comparator接口属于临时性的比较。</li>
</ul>
<h2 id="其他常用类">其他常用类</h2>
<h3 id="system类">System类</h3>
<ul>
<li><code>System类</code>代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</li>
<li>由于该类的构造器是<code>private</code>的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</li>
</ul>
<h4 id="成员方法">成员方法</h4>
<ul>
<li><p><code>native long currentTimeMillis()</code>：<br />
该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间（格林威治时间）1970年1月1号0时0分0秒所差的毫秒数。</p></li>
<li><p><code>void exit(int status)</code>:<br />
该方法的作用是退出程序。其中
status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等</p></li>
<li><p><code>void gc()</code>:<br />
该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p></li>
<li><p><code>String getProperty(String key)</code>:<br />
该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2iZl28"><img
src="https://z3.ax1x.com/2021/05/27/2iZl28.png"
alt="2iZl28.png" /></a></p>
<h3 id="math类">Math类</h3>
<p><code>java.lang.Math</code>
提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为<strong>double型</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2iZtVs"><img
src="https://z3.ax1x.com/2021/05/27/2iZtVs.png"
alt="2iZtVs.png" /></a></p>
<h1 id="枚举类和注解">枚举类和注解</h1>
<h2 id="枚举类的使用">枚举类的使用</h2>
<h3 id="枚举类的说明">枚举类的说明</h3>
<ol type="1">
<li><p><code>枚举类的理解</code>：类的对象只有<strong>有限个</strong>，确定的。我们称此类为枚举类</p></li>
<li><p>当需要<strong>定义一组常量</strong>时，强烈建议使用枚举类</p></li>
<li><p>枚举类的<strong>实现</strong>：<br />
</p></li>
</ol>
<ul>
<li>JDK 5.0以前需要自定义</li>
<li>JDK 5.0后新增<code>enum关键字</code>用于定义枚举类</li>
</ul>
<ol start="4" type="1">
<li><p>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</p></li>
<li><p>枚举类的<code>属性</code>：</p></li>
</ol>
<ul>
<li>枚举类对象的属性不应允许被改动，所以应该使用
<code>private final</code> 修饰<br />
</li>
<li>枚举类的使用 <code>private final</code>
修饰的属性应该在构造器中为其赋值<br />
</li>
<li>若枚举类显式的定义了<strong>带参数的构造器</strong>，则在列出枚举值时也必须对应的传入参数</li>
</ul>
<h3 id="如何自定义枚举类">如何自定义枚举类</h3>
<p><strong>步骤:</strong></p>
<ol type="1">
<li><p><strong>私有化构造器</strong>，保证不能在类的外部创建其对象；</p></li>
<li><p>在类的内部创建枚举类的示例。声明为：<code>public static final</code>；</p></li>
<li><p>对象如果有实例变量，应该声明为<code>private final</code>，并在构造器中初始化；</p></li>
</ol>
<p><strong>代码示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###
JDK5.0新增使用enum定义枚举类 &gt; <strong>使用说明：</strong> -
使用enum定义的枚举类默认继承了 <code>java.lang.Enum</code>
类，因此不能再继承其他类</p>
<ul>
<li><p>枚举类的构造器只能使用<strong>private权限修饰符</strong></p></li>
<li><p>枚举类的所有实例必须在枚举类中显式列出<strong>(, 分隔 ;
结尾)</strong>。列出的实例系统会自动添加
<code>public static final</code> 修饰</p></li>
<li><p>必须在枚举类的第一行声明枚举类对象</p></li>
</ul>
<blockquote>
<p><strong>代码示例:</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Enum类的常用方法：</strong> -
<code>values()方法</code>：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p>
</blockquote>
<ul>
<li><p><code>valueOf(String str)</code>：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”.如不是，会有运行时异常
IllegalArgumentException</p></li>
<li><p><code>toString()</code>：返回当前枚举类对象常量的名称</p></li>
</ul>
<p><strong>代码示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line"><span class="comment">//toString():返回枚举类对象的名称</span></span><br><span class="line">System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(Season1.class.getSuperclass());</span></span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"><span class="comment">//values():返回所的枚举类对象构成的数组</span></span><br><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">Thread.State[] values1 = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">    System.out.println(values1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line"><span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">System.out.println(winter);</span><br></pre></td></tr></table></figure> &gt;
<strong>用Enum类定义的枚举类对象分别实现接口：</strong></p>
<ul>
<li>使用说明：<br />
</li>
</ul>
<ol type="1">
<li><p>和普通Java类一样，枚举类可以实现一个或多个接口<br />
</p></li>
<li><p>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</p></li>
<li><p>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 注解的使用 ### 注解的理解</p></li>
<li><p>jdk 5.0 新增的功能</p></li>
<li><p><code>Annotation</code> 其实就是代码里的特殊标记,
这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用
Annotation,程序员可以在不改变原逻辑的情况下,
在源文件中嵌入一些补充信息。</p></li>
<li><p><code>Annotation</code>
可以像修饰符一样使用，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的
<code>name = value 对</code>中。</p></li>
<li><p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android
中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p></li>
<li><p><strong>框架</strong> =
<code>注解 + 反射机制 + 设计模式</code></p></li>
</ol>
<h3 id="注解的使用示例">注解的使用示例</h3>
<p>使用 <code>Annotation</code> 时要在其前面增加 <code>@</code>
符号，并把该 Annotation 当成个修饰符使用。用于修饰它支持的程序元素</p>
<h4
id="示例在编译时进行格式检查jdk内置的个基本注解">示例：在编译时进行格式检查(JDK内置的个基本注解)</h4>
<ul>
<li><code>@Override</code>: 限定重写父类方法, 该注解只能用于方法；</li>
<li><code>@Deprecated</code>: 用于表示所修饰的元素(类,
方法等)已过时。通常是因为所修饰的结构危险或存在更好的择；</li>
<li><code>@SuppressWarnings</code>: 抑制编译器警告；</li>
</ul>
<p><strong>代码示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarning(&quot;unused&quot;)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;重写的toString方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ####
示例：跟踪代码依赖性，实现替代配置文件功能
在使用<code>Spring框架</code>时会大量用到注解驱动开发。</p>
<h3 id="如何自定义注解">如何自定义注解</h3>
<p>参照 <code>@SuppressWarnings</code> 定义</p>
<ol type="1">
<li>注解声明为：<code>@interface</code></li>
<li>内部定义成员，通常使用<code>value</code>表示</li>
<li>可以指定成员的默认值，使用<code>default</code>定义</li>
<li>如果自定义注解没成员，表明是一个<strong>标识作用</strong>。</li>
</ol>
<p><strong>说明：</strong> 1.
如果注解有成员，在使用注解时，需要指明成员的值。</p>
<ol start="2" type="1">
<li><p>自定义注解必须配上注解的信息处理流程(使用反射)才意义。</p></li>
<li><p>自定义注解通过都会指明两个元注解：<code>@Retention</code>、<code>@Target</code></p></li>
</ol>
<p><strong>代码举例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="元注解">元注解</h3>
<p>对现有的注解进行解释说明的注解。</p>
<blockquote>
<p>JDK 5.0 提供的4种元注解： 1. <code>@Retention</code>：指定所修饰的
Annotation 的生命周期：SOURCE（默认行为），才能通过反射获取。</p>
</blockquote>
<ol start="2" type="1">
<li><p><code>@Target</code>:用于指定被修饰的 Annotation
能用于修饰哪些程序元素</p></li>
<li><p><code>@Documented</code>:表示所修饰的注解在被javadoc解析时，保留下来。</p></li>
<li><p><code>@Inherited</code>:被它修饰的 Annotation 将具继承性。
<strong>类比</strong>：元数据的概念：<code>String name = "Tom";</code>对现有数据的修饰</p></li>
</ol>
<h3 id="如何获取注解信息">如何获取注解信息</h3>
<p>通过发射来进行获取、调用。</p>
<p><strong>前提</strong>：要求此注解的元注解<code>Retention</code>中声明的生命周期状态为：<code>RUNTIME</code>.</p>
<h3 id="jdk8.0中的新特性">JDK8.0中的新特性</h3>
<p>可重复注解、类型注解 #### 可重复注解： 1. 在MyAnnotation上声明
<code>@Repeatable</code>，成员值为 <code>MyAnnotations.class</code> 2.
MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 ####
类型注解： ElementType.TYPE_PARAMETER
表示该注解能写在类型变量的声明语句中（如：泛型声明。）
ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
<h1 id="集合">集合</h1>
<h2 id="集合与数组">集合与数组</h2>
<h3 id="存储数据概念">存储数据概念</h3>
<p>集合、数组都是对多个数据进行存储操作的结构，简称<strong>Java容器</strong>。<code>说明</code>：此时的存储，主要指的是<strong>内存层面的存储</strong>，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中)
### 数组存储的概念 一旦初始化以后，其长度就确定了。
数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。
### 数组存储的弊端 1. 一旦初始化以后，其长度就不可修改。 2.
数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。
3. 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用 4.
数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</p>
<h3 id="集合的分类">集合的分类</h3>
<p><strong>Java集合</strong>可分为<code>Collection</code>和<code>Map</code>两种体系</p>
<ol type="1">
<li><strong>Collection接口</strong>：单列数据，定义了存取一组对象的方法的集合</li>
</ol>
<ul>
<li><code>List</code>：元素有序、可重复的集合</li>
<li><code>Set</code>：元素无序、不可重复的集合</li>
</ul>
<ol start="2" type="1">
<li><strong>Map接口</strong>：双列数据，保存具有映射关系“<code>key-value对</code>”的集合</li>
</ol>
<h3 id="集合的框架结构">集合的框架结构</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存null值</span><br><span class="line">           		|----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">                      底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br></pre></td></tr></table></figure>
<h2 id="collection接口">Collection接口</h2>
<ul>
<li><code>Collection接口</code>是<strong>List、Set和Queue接口的父接口</strong>，该接口里定义的方法既可用于操作Set集合，也可用于操作List和
Queue集合。</li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）实现。</li>
<li>在JDK
5.0之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成
<strong>Object类型</strong> 处理；从JDK
5.0增加了泛型以后，Java集合可以记住容器中对象的数据类型</li>
</ul>
<h3 id="单列集合框架结构">单列集合框架结构</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存null值</span><br><span class="line">           		|----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2mU0iQ"><img
src="https://z3.ax1x.com/2021/05/31/2mU0iQ.png" alt="2mU0iQ.png" /></a>
### Collection接口常用方法 1. 添加 - add(Object obj) - addAll(Collection
coll)</p>
<ol start="2" type="1">
<li>获取有效元素个数</li>
</ol>
<ul>
<li>int size()</li>
</ul>
<ol start="3" type="1">
<li>清空集合</li>
</ol>
<ul>
<li>void clear()</li>
</ul>
<ol start="4" type="1">
<li>是否为空集合</li>
</ol>
<ul>
<li>boolean isEmpty()</li>
</ul>
<ol start="5" type="1">
<li>是否包含某个元素</li>
</ol>
<ul>
<li>boolean contains(Object
obj):是通过元素的equals方法来判断是否是同一个对象</li>
<li>boolean containsAll(Collection
c):也是调用元素的equals方法来比较的。用两个两个集合的元素逐一比较</li>
</ul>
<ol start="6" type="1">
<li>删除</li>
</ol>
<ul>
<li>boolean remove(Object
obj):通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll):取当前集合的差集</li>
</ul>
<ol start="7" type="1">
<li>取两个集合的交集</li>
</ol>
<ul>
<li>boolean retainAll(Collection
c):把交集的结果存在当前的集合中，不影响c</li>
</ul>
<ol start="8" type="1">
<li>集合是否相等</li>
</ol>
<ul>
<li>boolean equals(Object obj)</li>
</ul>
<ol start="9" type="1">
<li>转换成对象数组</li>
</ol>
<ul>
<li>Object [] toArray()</li>
</ul>
<ol start="10" type="1">
<li>获取集合对象的哈希值</li>
</ol>
<ul>
<li>hashCode()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//1.add(Object e):将元素添加到集合中</span></span><br><span class="line">    collection.add(<span class="string">&quot;ZZ&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    collection.add(<span class="number">123</span>);</span><br><span class="line">    collection.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="comment">//2.size():获取添加元素的个数</span></span><br><span class="line">    System.out.println(collection.size());<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//3.addAll(Collection coll1):将coll1集合中的元素添加到当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    collection1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    collection1.add(<span class="number">213</span>);</span><br><span class="line">    collection.addAll(collection1);</span><br><span class="line">    System.out.println(collection.size());<span class="comment">//9</span></span><br><span class="line">    <span class="comment">//调用collection1中的toString()方法输出</span></span><br><span class="line">    System.out.println(collection);<span class="comment">//[ZZ, AA, BB, 123, Tue Apr 28 09:22:34 CST 2020, 213, 213]</span></span><br><span class="line">    <span class="comment">//4.clear():清空集合元素</span></span><br><span class="line">    collection1.clear();</span><br><span class="line">    System.out.println(collection1.size());<span class="comment">//0</span></span><br><span class="line">    System.out.println(collection1);<span class="comment">//[]</span></span><br><span class="line">    <span class="comment">//5.isEmpty():判断当前集合是否为空</span></span><br><span class="line">    System.out.println(collection1.isEmpty());<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//6.contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">    <span class="comment">//判断时需要调用obj对象所在类的equals()方法</span></span><br><span class="line">    System.out.println(coll.contains(<span class="number">123</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>)));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">23</span>)));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//7.containsAll(Collection coll1):判断形参coll1中的元素是否都存在当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">4566</span>);</span><br><span class="line">    System.out.println(coll.containsAll(coll1));<span class="comment">//flase</span></span><br><span class="line">    <span class="comment">//8.remove(Object obj):从当前集合中移除obj元素</span></span><br><span class="line">    coll.remove(<span class="number">123</span>);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[456, Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;, false]</span></span><br><span class="line">    <span class="comment">//9.removeAll(Collection coll1):差集：从当前集合中和coll1中所有的元素</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">456</span>, <span class="literal">false</span>);</span><br><span class="line">    coll.removeAll(coll2);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//10.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">345</span>, <span class="number">456</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> coll.retainAll(coll1);</span><br><span class="line">    System.out.println(b);<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll);<span class="comment">//[123, 456]</span></span><br><span class="line">    <span class="comment">//11.equals(Object obj):返回true需要当前集合和形参集合的元素相同</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll2.add(<span class="number">123</span>);</span><br><span class="line">    coll2.add(<span class="number">456</span>);</span><br><span class="line">    System.out.println(coll.equals(coll2));<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//12.hashCode():返回当前对象的哈希值</span></span><br><span class="line">    System.out.println(coll.hashCode());<span class="comment">//5230</span></span><br><span class="line">    <span class="comment">//13.集合---&gt;数组:toArray()</span></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span> (Object obj : array) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//14.数组---&gt;集合:调用Arrays类的静态方法asList()</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">345</span>&#125;);</span><br><span class="line">    System.out.println(ints.size());<span class="comment">//1</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(strings);<span class="comment">//[AA, BB, CC]</span></span><br><span class="line">    <span class="comment">//15.iteratoriterator():返回Iterator接口的实例，用于遍历集合元素。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="collection集合与数组的转换">Collection集合与数组的转换</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合 ---&gt;数组：toArray()</span></span><br><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>使用 Collection 集合存储对象，要求对象所属的类满足： 向 Collection
接口的实现类的对象中添加数据 <code>obj</code> 时，要求 obj
所在类要<strong>重写 equals()</strong>。</p>
<h2 id="iterator接口与foreach循环">Iterator接口与foreach循环</h2>
<h3 id="遍历collection接口的两种方式">遍历Collection接口的两种方式</h3>
<ol type="1">
<li>使用迭代器Iterator</li>
<li>foreach循环（或增强for循环） ###
java.utils包下定义的迭代器接口：Iterator #### 说明
<code>Iterator</code>对象称为迭代器(设计模式的一种)，主要用于遍历
<code>Collection</code> 集合中的元素。
GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。<strong>迭代器模式</strong>，就是为容器而生。
#### 如何获取实例 <code>coll.iterator()</code> 返回一个迭代器实例 ####
遍历的代码实现 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">//hasNext():判断是否还下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <a target="_blank" rel="noopener" href="https://imgtu.com/i/2m0KOI"><img
src="https://z3.ax1x.com/2021/05/31/2m0KOI.png" alt="2m0KOI.png" /></a>
#### Iterator中remove()方法的使用</li>
</ol>
<ul>
<li>测试Iterator中的 remove()</li>
<li>如果还未调用 next() 或在上一次调用 next() 方法之后已经调用了
remove() 方法，再调用 remove 都会报
<code>IllegalStateException</code>。</li>
<li>内部定义了
remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="string">&quot;Tom&quot;</span></span><br><span class="line">            );</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//            iterator.remove();</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">//                iterator.remove();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将指针重新放到头部，遍历集合</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### JDK5.0新特性-增强for循环（foreach循环） ####
遍历集合举例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内部仍然调用了<strong>迭代器</strong>。</li>
</ul>
<h2 id="collection子接口list接口">Collection子接口：List接口</h2>
<h3 id="存储的数据特点">存储的数据特点</h3>
<p>存储<strong>有序的、可重复</strong>的数据。</p>
<ul>
<li><p>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</p></li>
<li><p>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引</p></li>
<li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p></li>
<li><p>JDK
AP中List接口的实现类常用的有：<code>ArrayList、LinkedList和 Vector</code>
### 常用方法 List除了从
Collection集合继承的方法外，List集合里添加了一些<strong>根据索引来操作集合元素</strong>的方法。</p></li>
<li><p><code>void add(int index, Object ele)</code>:在index位置插入ele元素</p></li>
<li><p><code>boolean addAll(int index, Collection eles)</code>:从index位置开始将eles中的所有元素添加进来</p></li>
<li><p><code>Object get(int index)</code>:获取指定index位置的元素</p></li>
<li><p><code>int indexOf(Object obj)</code>:返回obj在集合中首次出现的位置</p></li>
<li><p><code>int lastIndexOf(Object obj)</code>:返回obj在当前集合中末次出现的位置</p></li>
<li><p><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</p></li>
<li><p><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</p></li>
<li><p><code>List subList(int fromIndex, int toIndex)</code>:返回从fromIndex到toIndex位置的子集合</p></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong>增</strong>：add(Object obj)<br />
</li>
<li><strong>删</strong>：remove(int index) / remove(Object obj)</li>
<li><strong>改</strong>：set(int index, Object ele)</li>
<li><strong>查</strong>：get(int index)</li>
<li><strong>插</strong>：add(int index, Object ele)</li>
<li><strong>长度</strong>：size()</li>
<li><strong>遍历</strong>： ① Iterator迭代器方式 ②
foreach（增强for循环） ③ 普通的循环</li>
</ul>
<p><strong>代码示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    <span class="comment">//int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">4567</span>);</span><br><span class="line">    System.out.println(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">    System.out.println(list.lastIndexOf(<span class="number">456</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object set(int index, Object ele):设置指定index位置的元素为ele</span></span><br><span class="line">    list.set(<span class="number">1</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">subList</span> <span class="operator">=</span> list.subList(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(subList);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">    list.add(<span class="number">1</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    list.addAll(list1);</span><br><span class="line">    <span class="comment">//        list.add(list1);</span></span><br><span class="line">    System.out.println(list.size());<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object get(int index):获取指定index位置的元素</span></span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 常用实现类
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3. 常用实现类：</span><br><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">  |----List接口：存储序的、可重复的数据。  --&gt;“动态”数组,替换原的数组</span><br><span class="line">      |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span><br><span class="line">      |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">      |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br></pre></td></tr></table></figure> #### ArratList -
<code>ArrayList</code>是<strong>List接口</strong>的典型实现类、主要实现类</p>
<ul>
<li><p>本质上，ArrayList是对象引用的一个<strong>变长数组</strong></p></li>
<li><p><em>ArrayList的JDK 1.8之前与之后的实现区别？</em></p>
<ol type="1">
<li>JDK
1.7：ArrayList像<strong>饿汉式</strong>，直接创建一个初始容量为10的数组</li>
<li>JDK
1.8：ArrayList像<strong>懒汉式</strong>，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</li>
</ol></li>
<li><p>Arrays.asList(...)方法返回的List集合，既不是
ArrayList实例，也不是Vector实例。Arrays.asList(...)返回值是一个固定长度的List集合
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">345</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//iterator()遍历ArrayList集合</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### linkedList</p></li>
<li><p>对于频繁的插入和删除元素操作，建议使用LinkedList类，效率更高</p></li>
<li><p>新增方法：</p>
<ul>
<li><p><code>void addFirst(Object obj)</code></p></li>
<li><p><code>void addLast(Object obj)</code></p></li>
<li><p><code>Object getFirst()</code></p></li>
<li><p><code>Object getlast)()</code></p></li>
<li><p><code>Object removeFirst()</code></p></li>
<li><p><code>Object removeLast()</code></p></li>
</ul></li>
<li><p><code>Linkedlist</code>：双向链表，内部没有声明数组，而是定义了Node类型的frst和last，用于记录首末元素。同时，定义内部类Node，作为
Linkedlist中保存数据的基本结构。Node除了保存数据，还定义了两个变量：</p>
<ul>
<li><code>prev</code>：变量记录前一个元素的位置</li>
<li><code>next</code>：变量记录下一个元素的位置 <a
target="_blank" rel="noopener" href="https://imgtu.com/i/2nFRxI"><img
src="https://z3.ax1x.com/2021/06/01/2nFRxI.png" alt="2nFRxI.png" /></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    linkedList.add(<span class="number">123</span>);</span><br><span class="line">    linkedList.add(<span class="number">345</span>);</span><br><span class="line">    linkedList.add(<span class="number">2342</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;DDD&quot;</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 源码分析 #### ArrayList的源码分析 &gt; JDK 7.0情况下
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p></li>
<li><p><strong>结论</strong>：建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code></p></li>
</ul>
<blockquote>
<p>JDK 8.0中ArrayList的变化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure> <strong><em>JDK
7.0中的ArrayList的对象的创建类似于单例的饿汉式，而JDK
8.0中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</em></strong></p>
</blockquote>
<h4 id="linkedlist的源码分析">LinkedList的源码分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中，Node定义为：体现了LinkedList的双向链表的说法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vector的源码分析">Vector的源码分析</h4>
<ol type="1">
<li>Vector是一个古老的集合，JDK
1.0就有了。大多数操作与ArrayList相同，区别在于Vector是<strong>线程安全的</strong></li>
<li>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免选择使用。</li>
<li>JDK 7.0和JDK
8.0中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</li>
<li>在扩容方面，默认扩容为原来的数组长度的2倍。</li>
</ol>
<h3 id="存储元素的要求">存储元素的要求</h3>
<p>添加的对象，所在的类要<strong>重写</strong><code>equals()方法</code></p>
<h3 id="面试题">面试题</h3>
<blockquote>
<p>请问 <code>ArrayList/LinkedList/Vector</code>
的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？ Vector和
ArrayList的最大区别？</p>
</blockquote>
<ul>
<li><p><code>ArrayList</code> 和 <code>Linkedlist</code> 的异同：<br />
二者都线程不安全，相比线程安全的 Vector，ArrayList执行效率高。
此外，ArrayList是实现了基于动态数组的数据结构，Linkedlist基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于Linkedlist，因为Linkedlist要移动指针。对于新增和删除操作add（特指插入）和
remove，Linkedlist比较占优势，因为 ArrayList要移动数据。</p></li>
<li><p><code>ArrayList</code> 和 <code>Vector</code> 的区别：<br />
Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比
ArrayList要大，访问要慢。正常情况下，大多数的Java程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack.</p></li>
</ul>
<h2 id="collection子接口set接口概述">Collection子接口：Set接口概述</h2>
<ol type="1">
<li><code>Set接口</code>是<strong>Collection的子接口</strong>，set接口没有提供额外的方法</li>
<li><code>Set集合</code><strong>不允许包含相同的元素</strong>，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。（多用于过滤操作，去掉重复数据）</li>
<li><code>Set</code>判断两个对象是否相同不是使用==运算符，而是根据<strong>equals()方法</strong></li>
</ol>
<h3 id="存储数据特点">存储数据特点</h3>
<p>用于存放<strong>无序的、不可重复的</strong>元素</p>
<p>以<code>HashSet</code>为例说明： -
<strong>无序性</strong>：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。
-
<strong>不可重复性</strong>：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</p>
<h3 id="元素添加过程">元素添加过程</h3>
<p>我们向<code>HashSet</code>中添加元素a,首先调用元素a所在类的<code>hashCode()方法</code>，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），<em>判断数组此位置上是否已经有元素</em>：</p>
<ul>
<li>如果此位置上<strong>没有其他元素</strong>，则元素a添加成功。
---&gt;<code>情况1</code></li>
<li>如果此位置上<strong>有其他元素</strong>b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：
<ul>
<li>如果hash值<strong>不相同</strong>，则元素a添加成功。---&gt;<code>情况2</code></li>
<li>如果hash值<strong>相同</strong>，进而需要调用元素a所在类的equals()方法：
<ul>
<li>equals()返回<strong>true</strong>,元素a添加失败</li>
<li>equals()返回<strong>false</strong>,则元素a添加成功。---&gt;<code>情况3</code></li>
</ul></li>
</ul></li>
</ul>
<p>对于添加成功的情况2和情况3而言：元素a
与已经存在指定索引位置上数据以链表的方式存储。<br />
<code>JDK 7.0</code> :元素a放到数组中，指向原来的元素。<br />
<code>JDK 8.0</code> :原来的元素在数组中，指向元素a<br />
<strong>总结</strong>：七上八下<br />
<strong>HashSet底层</strong>：<code>数组+链表</code>的结构。（JDK
7.0以前） <a target="_blank" rel="noopener" href="https://imgtu.com/i/2neVaV"><img
src="https://z3.ax1x.com/2021/06/01/2neVaV.png"
alt="2neVaV.png" /></a></p>
<h3 id="常用方法-2">常用方法</h3>
<p><code>Set接口</code>中没额外定义新的方法，使用的都是Collection中声明过的方法。
#### 重写hashCode()的基本方法 - 在程序运行时，同一个对象多次调用
<code>hashCode()</code> 方法应该<strong>返回相同的值</strong>。</p>
<ul>
<li><p>当两个对象的 <code>equals()</code>
方法比较返回true时，这两个对象的 <code>hashCode()</code>
方法的返回值也应相等。</p></li>
<li><p>对象中用作 <code>equals()</code>
方法比较的Field，都应该用来计算hashCode值。</p></li>
</ul>
<h4 id="重写-equals-方法基本原则">重写 equals() 方法基本原则</h4>
<blockquote>
<p>以自定义的 Customer类为例，何时需要<strong>重写
equals()</strong>？</p>
</blockquote>
<p>当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候，总是要改写
hashCode()，根据一个类的
equals方法(改写后)，两个截然不同的实例有可能在逻辑上是相等的，但是，根据
Object.hashCode() 方法，它们仅仅是两个对象。</p>
<p>因此，违反了<strong>相等的对象必须具有相等的散列码</strong>。</p>
<p><strong>结论</strong>：复写equals方法的时候一般都需要<strong>同时复写
hashCode 方法</strong>。通常参与计算 hashCode的对象的属性也应该参与到
equals() 中进行计算。</p>
<h4
id="eclipseidea工具里hashcode重写">Eclipse/IDEA工具里hashCode()重写</h4>
<p><strong><em>以Eclipse/DEA为例，在自定义类中可以调用工具自动重写
equals() 和 hashCode()</em></strong><br />
&gt; 问题：为什么用 Eclipse/IDEA复写 hash Code方法，有31这个数字？</p>
<ul>
<li><p>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</p></li>
<li><p>并且31只占用5bits，相乘造成数据溢出的概率较小。</p></li>
<li><p>31可以由i*31==(&lt;&lt;5)-1来表示，现在很多虚拟机里面都有做相关优化。（提高算法效率）</p></li>
<li><p>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！（减少冲突）
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User equals()....&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(user.name) : user.name == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">//return name.hashCode() + age;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + age;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 常用实现类 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">          |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</span><br><span class="line">               |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">          |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure> #### HashSet</p></li>
<li><p><code>Hashset</code>是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。</p></li>
<li><p><code>HashSet</code>按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p></li>
<li><p><code>HashSet</code>具有以下特点：</p>
<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet不是线程安全的</li>
<li>集合元素可以是nul</li>
</ul></li>
<li><p><code>HashSet集合</code>判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等。</p></li>
<li><p>对于<code>存放在Set容器中的对象</code>，对应的类一定要<strong>重写equals()和hashCode(Object
obj)方法</strong>，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”</p></li>
</ul>
<p>代码示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//HashSet使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    set.add(<span class="number">454</span>);</span><br><span class="line">    set.add(<span class="number">213</span>);</span><br><span class="line">    set.add(<span class="number">111</span>);</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">23</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">34</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>,<span class="number">74</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### LinkedHashSet -
<code>LinkedhashSet</code>是HashSet的子类</p>
<ul>
<li><p><code>LinkedhashSet</code>根据元素的hashCode值来决定元素的存储位置但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p></li>
<li><p><code>LinkedhashSet</code>插入性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能。</p></li>
<li><p><code>LinkedhashSet</code>不允许集合元素重复。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//LinkedHashSet使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">    set.add(<span class="number">454</span>);</span><br><span class="line">    set.add(<span class="number">213</span>);</span><br><span class="line">    set.add(<span class="number">111</span>);</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">23</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">34</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>,<span class="number">74</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#### TreeSet</p></li>
<li><p><code>Treeset</code>是<strong>SortedSet接口的实现类</strong>，TreeSet可以确保集合元素处于排序状态。</p></li>
<li><p><code>TreeSet</code>底层使用<strong>红黑树结构</strong>存储数据</p></li>
<li><p><code>TreeSet</code>两种排序方法：<strong>自然排序</strong>和<strong>定制排序</strong>。默认情况下，<code>TreeSet采用自然排序</code>。</p></li>
</ul>
<p><strong>红黑树的特点</strong>：有序，查询效率比List快</p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/LiaHon/p/11203229.html">红黑树详细介绍</a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">34</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;mars&quot;</span>,<span class="number">38</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane&quot;</span>,<span class="number">56</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane&quot;</span>,<span class="number">60</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bruce&quot;</span>,<span class="number">58</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> treeSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 存储对象所在类的要求 #### HashSet/LinkedHashSet -
<code>要求</code>：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要<strong>重写hashCode()和equals()</strong>
-
<code>要求</code>：重写的hashCode()和equals()尽可能保持一致性：<strong>相等的对象必须具有相等的散列码</strong></p>
<blockquote>
<p><strong>重写两个方法的小技巧</strong>：对象中用作 equals() 方法比较的
Field，都应该用来计算 hashCode 值。</p>
</blockquote>
<h4 id="treeset">TreeSet</h4>
<ol type="1">
<li><p>自然排序中，比较两个对象是否相同的标准为：<code>compareTo()</code>
返回0.不再是 equals()</p></li>
<li><p>定制排序中，比较两个对象是否相同的标准为：<code>compare()</code>
返回0.不再是 equals()</p></li>
</ol>
<h3 id="treeset的使用">TreeSet的使用</h3>
<h4 id="使用说明">使用说明:</h4>
<ol type="1">
<li><p>向TreeSet中添加的数据，要求是相同类的对象。</p></li>
<li><p>两种排序方式：自然排序（实现Comparable接口）和定制排序（Comparator）</p></li>
</ol>
<h4 id="常用的排序方式">常用的排序方式:</h4>
<blockquote>
<p><strong>方式一：自然排序</strong></p>
</blockquote>
<ul>
<li><p><strong>自然排序</strong>：TreeSet会调用集合元素的
<code>compareTo(object obj)</code>
方法来比较元素之间的大小关系，然后将集合元素按<strong>升序（默认情况）</strong>排列</p></li>
<li><p>如果试图把一个对象添加到<code>Treeset</code>时，则该对象的类必须实现<strong>Comparable接口</strong>。</p>
<ul>
<li>实现Comparable的类必须实现 <code>compareTo(Object obj)</code>
方法，两个对象即通过 <code>compareTo(Object obj)</code>
方法的返回值来比较大小</li>
</ul></li>
<li><p><code>Comparable</code>的典型实现:</p>
<ul>
<li><p><strong>BigDecimal、BigInteger以及所有的数值型对应的包装类</strong>：按它们对应的数值大小进行比较</p></li>
<li><p><strong>Character</strong>：按字符的unicode值来进行比较</p></li>
<li><p><strong>Boolean</strong>：true对应的包装类实例大于fase对应的包装类实例</p></li>
<li><p><strong>String</strong>：按字符串中字符的unicode值进行比较</p></li>
<li><p><strong>Date、Time</strong>：后边的时间、日期比前面的时间、日期大</p></li>
</ul></li>
<li><p>向<code>TreeSet</code>中添加元素时，只有第一个元素无须比较
compareTo() 方法，后面添加的所有元素都会<strong>调用 compareTo()
方法</strong>进行比较。</p></li>
<li><p>因为只有相同类的两个实例才会比较大小，所以向
TreeSet中添加的应该是同一个类的对象。
对于TreeSet集合而言，它判断两个对象是否相等的<code>唯一标准</code>是：<strong>两个对象通过
compareTo(Object obj) 方法比较返回值。</strong></p></li>
<li><p>当需要把一个对象放入TreeSet中，重写该对象对应的equals()方法时，应保证该方法与
<code>compareTo(Object obj)</code>
方法有一致的结果：如果两个对象通过equals()方法比较返回true，则通过
<code>compareTo(object ob)</code>方法比较应返回0。否则，让人难以理解。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败：不能添加不同类的对象</span></span><br><span class="line">    <span class="comment">//        set.add(123);</span></span><br><span class="line">    <span class="comment">//        set.add(456);</span></span><br><span class="line">    <span class="comment">//        set.add(&quot;AA&quot;);</span></span><br><span class="line">    <span class="comment">//        set.add(new User(&quot;Tom&quot;,12));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//举例一：</span></span><br><span class="line">    <span class="comment">//        set.add(34);</span></span><br><span class="line">    <span class="comment">//        set.add(-34);</span></span><br><span class="line">    <span class="comment">//        set.add(43);</span></span><br><span class="line">    <span class="comment">//        set.add(11);</span></span><br><span class="line">    <span class="comment">//        set.add(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//举例二：</span></span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>方式二：定制排序</strong></p>
</blockquote>
<ul>
<li><p>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现
Comparable接口，或不希望按照升序（默认情况）的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过
<code>Comparator 接口</code>来实现。需要<strong>重写 compare(T o1，T
o2)方法</strong>。</p></li>
<li><p>利用 <code>int compare(T o1，T o2)</code>
方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</p></li>
<li><p>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</p></li>
<li><p>此时，仍然只能向Treeset中添加类型相同的对象。否则发生
<code>ClassCastException 异常</code></p></li>
<li><p>使用定制排序判断两个元素相等的标准是：<code>通过 Comparator比较两个元素返回了0</code>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">        <span class="comment">//照年龄从小到大排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mary&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Map接口</p></li>
<li><p><code>Map</code>与Collection并列存在。用于保存具有映射关系的数据:key-value</p></li>
<li><p><code>Map</code>中的key和value都可以是任何引用类型的数据</p></li>
<li><p><code>Map</code>中的key用set来存放，不允许重复，即同一个Map对象所对应的类，须重写
hashCode() 和 equals() 方法</p></li>
<li><p>常用 <code>String类</code> 作为Map的“键”</p></li>
<li><p>key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value</p></li>
<li><p><code>Map接口</code>的常用实现类:HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类</p></li>
</ul>
<h3 id="常见实现类结构">常见实现类结构</h3>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2nNOp9"><img
src="https://z3.ax1x.com/2021/06/01/2nNOp9.png" alt="2nNOp9.png" /></a>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">                      底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap的底层： 数组+链表  （JDK 7.0及之前)</span><br><span class="line">               数组+链表+红黑树 （JDK 8.0以后)</span><br></pre></td></tr></table></figure> #### HashMap -
<code>HashMap</code>是Map接口使用频率最高的实现类。</p>
<ul>
<li><p>允许使用<code>null键</code>和n<code>ull值</code>，与 HashSet
一样，不保证映射的顺序。</p></li>
<li><p>所有的key构成的集合是set：无序的、不可重复的。所以，key所在的类要<code>重写equals()和 hashCode()</code></p></li>
<li><p>所有的value构成的集合是<code>Collection</code>：无序的、可以重复的。所以，value所在的类要重写:<code>equals()</code></p></li>
<li><p>一个<code>key-value</code>构成一个<code>entry</code></p></li>
<li><p>所有的<code>entry</code>构成的集合是<code>Set</code>：无序的、不可重复的</p></li>
<li><p>HashMap判断两个key<code>相等</code>的标准是：<strong>两个key通过
equals() 方法返回true，hashCode值也相等。</strong></p></li>
<li><p>HashMap判断两个value<code>相等</code>的标准是：<strong>两个value通过
equals() 方法返回true。</strong></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="literal">null</span>,<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="linkedhashmap">LinkedHashMap</h4>
<ul>
<li><p><code>LinkedHashMap</code>底层使用的结构<strong>与HashMap相同</strong>，因为LinkedHashMap继承于HashMap.</p></li>
<li><p><strong>区别就在于</strong>：LinkedHashMap内部提供了<code>Entry</code>，替换HashMap中的Node.</p></li>
<li><p>与<code>Linkedhash Set</code>类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与Key-value对的插入顺序一致
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">    map.put(<span class="number">123</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="number">345</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="number">12</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure> #### TreeMap</p></li>
<li><p><code>TreeMap</code>存储Key-Value对时，需要根据key-value对进行排序。TreeMap可以保证所有的
Key-Value 对处于有序状态。</p></li>
<li><p><code>TreeSet底层</code>使用<strong>红黑树结构</strong>存储数据</p></li>
<li><p><code>TreeMap</code>的Key的排序:</p>
<ul>
<li><strong>自然排序</strong>：
TreeMap的所有的Key必须实现<code>Comparable接口</code>，而且所有的Key应该是同一个类的对象，否则将会抛出ClasssCastEXception()</li>
<li><strong>定制排序</strong>：创建 TreeMap 时，传入一个
<code>Comparator对象</code>，该对象负责对TreeMap中的所有key进行排序。此时不需要Map的Key实现Comparable接口</li>
</ul></li>
<li><p><strong>TreeMap判断两个key相等的标准</strong>：两个key通过<code>compareTo()</code>方法或者<code>compare()</code>方法返回0.</p></li>
</ul>
<h4 id="hashtable">Hashtable</h4>
<ul>
<li><p><code>Hashtable</code>是个古老的Map实现类，JDK1.0就提供了。不同于
HashMap，<strong>Hashtable是线程安全的</strong></p></li>
<li><p><code>Hashtable</code>实现原理和HashMap相同，功能相同。底层都使用<strong>哈希表</strong>结构，查询速度快，很多情况下可以互用</p></li>
<li><p>与<code>HashMap</code>不同，Hashtable不允许使用null作为<strong>key和value</strong></p></li>
<li><p>与<code>HashMap</code>一样，Hashtable也不能保证其中Key-value对的顺序</p></li>
<li><p><code>Hashtable</code>判断两个key相等、两个value相等的标准，与HashMap一致</p></li>
</ul>
<h4 id="properties">Properties</h4>
<ul>
<li><p><code>Properties类</code>是Hashtable的子类，该对象用于<strong>处理属性文件</strong></p></li>
<li><p>由于属性文件里的key、value都是字符串类型，所以Properties里的key和value都是<strong>字符串类型</strong></p></li>
<li><p>存取数据时，建议使用
<code>setProperty(String key,String value)</code>方法和
<code>getProperty(String key)</code>方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Properties:常用来处理配置文件。key和value都是String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###
存储结构的理解</p></li>
<li><p><code>Map中的key</code>: 无序的、不可重复的，使用Set存储所的key
---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)</p></li>
<li><p><code>Map中的value</code>:无序的、可重复的，使用Collection存储所的value
---&gt;value所在的类要重写equals()</p></li>
<li><p><code>一个键值对</code>：key-value构成了一个Entry对象</p></li>
<li><p><code>Map中的entry</code>:无序的、不可重复的，使用Set存储所的entry</p></li>
</ul>
<h3 id="常用方法-3">常用方法</h3>
<h4 id="添加删除修改操作">添加、删除、修改操作</h4>
<ul>
<li><p><code>Object put(Object key,Object value)</code>：将指定key-value添加到(或修改)当前map对象中</p></li>
<li><p><code>void putAll(Map m)</code>:将m中的所有key-value对存放到当前map中</p></li>
<li><p><code>Object remove(Object key)</code>：移除指定key的key-value对，并返回value</p></li>
<li><p><code>void clear()</code>：清空当前map中的所有数据 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="comment">//Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</span></span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ZZ&quot;</span>,<span class="number">251</span>);</span><br><span class="line">    map.put(<span class="string">&quot;CC&quot;</span>,<span class="number">110</span>);</span><br><span class="line">    map.put(<span class="string">&quot;RR&quot;</span>,<span class="number">124</span>);</span><br><span class="line">    map.put(<span class="string">&quot;FF&quot;</span>,<span class="number">662</span>);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=251, CC=110, RR=124, FF=662&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</span></span><br><span class="line">    map.put(<span class="string">&quot;ZZ&quot;</span>,<span class="number">261</span>);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=261, CC=110, RR=124, FF=662&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void putAll(Map m):将m中的所有key-value对存放到当前map中</span></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map1.put(<span class="string">&quot;GG&quot;</span>,<span class="number">435</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;DD&quot;</span>,<span class="number">156</span>);</span><br><span class="line">    map.putAll(map1);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=261, CC=110, RR=124, FF=662, GG=435, DD=156&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object remove(Object key)：移除指定key的key-value对，并返回value</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.remove(<span class="string">&quot;GG&quot;</span>);</span><br><span class="line">    System.out.println(value);<span class="comment">//435</span></span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=261, CC=110, RR=124, FF=662, DD=156&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void clear()：清空当前map中的所有数据</span></span><br><span class="line">    map.clear();</span><br><span class="line">    System.out.println(map.size());<span class="comment">//0  与map = null操作不同</span></span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#### 元素查询的操作</p></li>
<li><p><code>Object get(Object key)</code>：获取指定key对应的value</p></li>
<li><p><code>boolean containsKey(Object key)</code>：是否包含指定的key</p></li>
<li><p><code>boolean containsValue(Object value)</code>：是否包含指定的value</p></li>
<li><p><code>int size()</code>：返回map中key-value对的个数</p></li>
<li><p><code>boolean isEmpty()</code>：判断当前map是否为空</p></li>
<li><p><code>boolean equals(Object obj)</code>：判断当前map和参数对象obj是否相等
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ZZ&quot;</span>, <span class="number">251</span>);</span><br><span class="line">    map.put(<span class="string">&quot;CC&quot;</span>, <span class="number">110</span>);</span><br><span class="line">    map.put(<span class="string">&quot;RR&quot;</span>, <span class="number">124</span>);</span><br><span class="line">    map.put(<span class="string">&quot;FF&quot;</span>, <span class="number">662</span>);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=251, CC=110, RR=124, FF=662&#125;</span></span><br><span class="line">    <span class="comment">//Object get(Object key)：获取指定key对应的value</span></span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;AA&quot;</span>));<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean containsKey(Object key)：是否包含指定的key</span></span><br><span class="line">    System.out.println(map.containsKey(<span class="string">&quot;ZZ&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean containsValue(Object value)：是否包含指定的value</span></span><br><span class="line">    System.out.println(map.containsValue(<span class="number">123</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int size()：返回map中key-value对的个数</span></span><br><span class="line">    System.out.println(map.size());<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isEmpty()：判断当前map是否为空</span></span><br><span class="line">    System.out.println(map.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean equals(Object obj)：判断当前map和参数对象obj是否相等</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map1.put(<span class="string">&quot;AA&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;ZZ&quot;</span>, <span class="number">251</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;CC&quot;</span>, <span class="number">110</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;RR&quot;</span>, <span class="number">124</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;FF&quot;</span>, <span class="number">662</span>);</span><br><span class="line">    System.out.println(map.equals(map1));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 元视图操作的方法</p></li>
<li><p><code>Set keySet()</code>：返回所有key构成的Set集合</p></li>
<li><p><code>Collection values()</code>：返回所有value构成的Collection集合</p></li>
<li><p><code>Set entrySet()</code>：返回所有key-value对构成的Set集合
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ZZ&quot;</span>, <span class="number">251</span>);</span><br><span class="line">    map.put(<span class="string">&quot;CC&quot;</span>, <span class="number">110</span>);</span><br><span class="line">    map.put(<span class="string">&quot;RR&quot;</span>, <span class="number">124</span>);</span><br><span class="line">    map.put(<span class="string">&quot;FF&quot;</span>, <span class="number">662</span>);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=251, CC=110, RR=124, FF=662&#125;</span></span><br><span class="line">    <span class="comment">//遍历所有的key集:Set keySet()：返回所有key构成的Set集合</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历所有的value集：Collection values()：返回所有value构成的Collection集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">    <span class="keyword">for</span> (Object obj :</span><br><span class="line">         values) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">    <span class="comment">//Set entrySet()：返回所有key-value对构成的Set集合</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">        <span class="comment">//entrySet集合中的元素都是entry</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;--&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        System.out.println(key + <span class="string">&quot;==&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; <strong>总结：常用方法</strong></p></li>
<li><p><code>添加</code>：put(Object key,Object value)</p></li>
<li><p><code>删除</code>：remove(Object key)</p></li>
<li><p><code>修改</code>：put(Object key,Object value)</p></li>
<li><p><code>查询</code>：get(Object key)</p></li>
<li><p><code>长度</code>：size()</p></li>
<li><p><code>遍历</code>：keySet() / values() / entrySet()</p></li>
</ul>
<h3 id="内存结构说明">内存结构说明</h3>
<h4 id="hashmap在jdk-7.0中实现原理">HashMap在JDK 7.0中实现原理</h4>
<h5 id="hashmap的存储结构">HashMap的存储结构</h5>
<p>JDK
7.0及以前的版本：HashMap是<strong>数组+链表</strong>结构（地址链表法）</p>
<p>JDK 8.0版本以后：HashMap是<strong>数组+链表+红黑树</strong>实现</p>
<h5 id="对象创建和添加过程">对象创建和添加过程</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = new HashMap():</span><br></pre></td></tr></table></figure>
<p>在实例化以后，底层创建了长度是16的一维数组
<code>Entry[] table</code>。</p>
<blockquote>
<p><strong>map.put(key1,value1)</strong>:</p>
</blockquote>
<ul>
<li>首先，调用key1所在类的 <code>hashCode()</code>
计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</li>
<li>如果此位置上的数据为空，此时的<code>key1-value1</code>添加成功。
----<strong><em>情况1</em></strong></li>
<li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：
<ul>
<li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----<strong><em>情况2</em></strong></li>
<li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
<ul>
<li>如果 equals()
返回<code>false</code>:此时key1-value1添加成功。----<strong><em>情况3</em></strong></li>
<li>如果 equals() 返回<code>true</code>:使用value1替换value2。</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>补充</strong>：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</p>
</blockquote>
<p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<h5 id="hashmap的扩容">HashMap的扩容</h5>
<p>当<code>HashMap</code>中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对
HashMap的数组进行扩容，而在HashMap数组扩容之后，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是
<code>resize</code>。</p>
<h5 id="hashmap扩容时机">HashMap扩容时机</h5>
<p>当<code>HashMap</code>中的元素个数超过数组大小（数组总大小
length，不是数组中个数）*
loadFactor时，就会进行数组扩容，<code>loadFactor</code>的默认值(DEFAULT_LOAD_
FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT
INITIAL CAPACITY)为16，那么当 HashMap中元素个数超过16 *
0.75=12（这个值就是代码中的
threshold值，也叫做临界值）的时候，就把数组的大小扩展为2 *
16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知
HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
<h4 id="hashmap在jdk-8.0底层实现原理">HashMap在JDK 8.0底层实现原理</h4>
<h5 id="hashmap的存储结构-1">HashMap的存储结构</h5>
<p><code>HashMap</code>的内部存储结构其实是<strong>数组+链表+红黑树</strong>的组合。</p>
<h5 id="hashmap添加元素的过程">HashMap添加元素的过程</h5>
<ul>
<li>当实例化一个<code>HashMap</code>时，会初始化
<code>initialCapacity</code>和<code>loadFactor</code>，在put第一对映射关系时，系统会创建一个长度为
<code>initialCapacity</code>的<code>Node</code>数组，这个长度在哈希表中被称为<strong>容量（Capacity）</strong>，在这个数组中可以存放元素的位置我们称之为“桶”（
bucket），每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</li>
<li>每个
<code>bucket</code>中存储一个元素，即一个<code>Node</code>对象，但每一个Node对象可以带个引用变量<code>next</code>，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个
<code>TreeNode</code>对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</li>
</ul>
<h5 id="hashmap的扩容机制">HashMap的扩容机制</h5>
<ul>
<li>当<code>HashMap</code>中的其中一个链的对象个数<strong>没有达到8个</strong>和JDK
7.0以前的扩容方式一样。</li>
<li>当<code>HashMap</code>中的其中一个链的对象个数如果<strong>达到了8个</strong>，此时如果
<code>capacity</code>
没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，<strong>结点类型由Node变成
TreeNode
类型</strong>。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</li>
</ul>
<h5 id="jdk-8.0与jdk-7.0中hashmap底层的变化">JDK 8.0与JDK
7.0中HashMap底层的变化</h5>
<ol type="1">
<li><p><code>new HashMap()</code>:底层没有创建一个长度为16的数组</p></li>
<li><p><code>JDK 8.0底层的数组</code>是：<strong>Node[]</strong>,而非
Entry[]</p></li>
<li><p><strong>首次</strong>调用<code>put()</code>方法时，底层创建长度为16的数组</p></li>
<li><p><code>JDK 7.0底层结构</code>：<strong>数组+链表</strong>。<br />
<code>JDK 8.0底层结构</code>：<strong>数组+链表+红黑树</strong>。</p>
<ul>
<li>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8
且当前数组的长度 &gt;
64时，此时此索引位置上的所数据改为使用红黑树存储。</li>
</ul></li>
</ol>
<h4
id="hashmap底层典型属性的属性的说明">HashMap底层典型属性的属性的说明</h4>
<ul>
<li><code>DEFAULT_INITIAL_CAPACITY</code> :
HashMap的<strong>默认容量</strong>，16</li>
<li><code>DEFAULT_LOAD_FACTOR</code>：HashMap的<strong>默认加载因子</strong>：0.75</li>
<li><code>threshold</code>：<strong>扩容的临界值</strong>，=
容量<em>填充因子：16 </em> 0.75 =&gt; 12</li>
<li><code>TREEIFY_THRESHOLD</code>：Bucket中链表长度大于该默认值，转化为<strong>红黑树</strong>:JDK
8.0引入</li>
<li><code>MIN_TREEIFY_CAPACITY</code>：桶中的Node被树化时最小的hash表容量:64</li>
</ul>
<h4 id="linkedhashmap的底层实现原理">LinkedHashMap的底层实现原理</h4>
<ul>
<li><code>LinkedHashMap</code>底层使用的结构与HashMap相同，因为<strong>LinkedHashMap继承于HashMap</strong>.</li>
<li>区别就在于：<code>LinkedHashMap</code>内部提供了<code>Entry</code>，替换HashMap中的Node.</li>
<li>与Linkedhash
Set类似，<code>LinkedHashMap</code>可以<strong>维护Map的迭代顺序</strong>：迭代顺序与Key-value对的插入顺序一致</li>
</ul>
<p><strong><em>HashMap中内部类Node源码：</em></strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong><em>LinkedHashM中内部类Entry源码:</em></strong>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;<span class="comment">//能够记录添加的元素的先后顺序</span></span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="treemap的使用">TreeMap的使用</h3>
<p>向<code>TreeMap</code>中添加<code>key-value</code>，要求key必须是由同一个类创建的对象
要照key进行排序：自然排序、定制排序 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bruce&quot;</span>, <span class="number">56</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Davie&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1, <span class="number">98</span>);</span><br><span class="line">    map.put(u2, <span class="number">16</span>);</span><br><span class="line">    map.put(u3, <span class="number">92</span>);</span><br><span class="line">    map.put(u4, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制排序：按照年龄大小排</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User) o1;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User) o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(), u2.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入数据类型错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bruce&quot;</span>, <span class="number">56</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Davie&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1, <span class="number">98</span>);</span><br><span class="line">    map.put(u2, <span class="number">16</span>);</span><br><span class="line">    map.put(u3, <span class="number">92</span>);</span><br><span class="line">    map.put(u4, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###
使用Properties读取配置文件 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Properties:常用来处理配置文件。key和value都是String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 面试题 1.
HashMap的底层实现原理？</p>
<ol start="2" type="1">
<li><p>HashMap 和 Hashtable的异同？</p></li>
<li><p>CurrentHashMap 与 Hashtable的异同？</p></li>
<li><p>负载因子值的大小，对HashMap的影响？</p>
<ul>
<li><p>负载因子的大小决定了HashMap的数据密度。</p></li>
<li><p>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成査询或插入时的比较次数增多，性能会下降。</p></li>
<li><p>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</p></li>
<li><p>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。
## Collection工具类的使用 ### 作用</p></li>
</ul></li>
</ol>
<ul>
<li><p><code>Collections</code>是一个操作<code>Set、Lit和Map</code>等集合的工具类</p></li>
<li><p><code>Collections</code>中提供了一系列静态的方法对集合元素进行排序、査询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p></li>
</ul>
<h3 id="常用方法-4">常用方法</h3>
<h4 id="排序操作">排序操作</h4>
<ul>
<li><code>reverse(List)</code>：反转 List 中元素的顺序</li>
<li><code>shuffle(List)</code>：对 List 集合元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List
集合元素升序排序</li>
<li><code>sort(List，Comparator)</code>：根据指定的 Comparator
产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List，int， int)</code>：将指定 list 集合中的 i 处元素和
j 处元素进行交换 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, 43, 765, -97, 0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//reverse(List)：反转 List 中元素的顺序</span></span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[0, -97, 765, 43, 123]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//shuffle(List)：对 List 集合元素进行随机排序</span></span><br><span class="line">    Collections.shuffle(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[765, -97, 123, 0, 43]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[-97, 0, 43, 123, 765]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line">    Collections.swap(list,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[-97, 765, 43, 123, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 查找、替换</li>
<li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li><code>Object max(Collection，Comparator)</code>：根据 Comparator
指定的顺序，返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code></li>
<li><code>Object min(Collection，Comparator)</code></li>
<li><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换
List 对象的所旧值 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, 43, 765, -97, 0]</span></span><br><span class="line">    <span class="comment">//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(list);</span><br><span class="line">    System.out.println(max);<span class="comment">//765</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object min(Collection)</span></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">min</span> <span class="operator">=</span> Collections.min(list);</span><br><span class="line">    System.out.println(min);<span class="comment">//-97</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> Collections.frequency(list,<span class="number">123</span>);</span><br><span class="line">    System.out.println(frequency);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void copy(List dest,List src)：将src中的内容复制到dest中</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);</span><br><span class="line">    System.out.println(dest.size());<span class="comment">//7</span></span><br><span class="line">    Collections.copy(dest,list);</span><br><span class="line">    System.out.println(dest);<span class="comment">//[123, 123, 123, 43, 765, -97, 0]</span></span><br><span class="line">    <span class="comment">//boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="同步控制">同步控制</h4>
<p><code>Collections 类</code>中提供了多个
<code>synchronizedXxx() 方法</code>，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, 43, 765, -97, 0]</span></span><br><span class="line">    <span class="comment">//返回的list1即为线程安全的List</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br><span class="line">    System.out.println(list1);<span class="comment">//[123, 123, 123, 43, 765, -97, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> Java基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/Java%20%E5%B9%B6%E5%8F%91/" rel="prev" title="Java并发笔记">
      <i class="fa fa-chevron-left"></i> Java并发笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/" rel="next" title="Java基础（三）">
      Java基础（三） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">string类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.1.</span> <span class="nav-text">String特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">String实例化方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E5%BC%8F%E8%B5%8B%E5%80%BC%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">字符串拼接方式赋值对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">String类常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">字符串操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">查找字符串中的字符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E4%B8%8E%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">String与其他结构的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#string%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.1.4.1.</span> <span class="nav-text">String与基本数据类型、包装类之间的转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8Estringbufferstringbuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.1.4.2.</span> <span class="nav-text">与StringBuffer、StringBuilder之间的转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jvm%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%AD%98%E6%94%BE%E8%AF%B4%E6%98%8E"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">JVM中字符串常量池存放说明：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stringbuffer%E5%92%8Cstringbuilder"><span class="nav-number">1.2.</span> <span class="nav-text">StringBuffer和StringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stringbuffer%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">StringBuffer类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stringbuilder%E7%B1%BB"><span class="nav-number">1.2.2.</span> <span class="nav-text">StringBuilder类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stringbuffer%E4%B8%8Estringbuilder%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">StringBuffer与StringBuilder的内存解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94stringstringbufferstringbuilder%E4%B8%89%E8%80%85%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">对比String、StringBuffer、StringBuilder三者的执行效率</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jdk-8.0%E4%BB%A5%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api"><span class="nav-number">1.3.</span> <span class="nav-text">JDK 8.0以前的日期时间API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java.lang.system%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">java.lang.System类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java.util.date%E7%B1%BB"><span class="nav-number">1.3.2.</span> <span class="nav-text">java.util.Date类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java.util.date%E7%B1%BB%E4%B8%8Ejava.sql.date%E7%B1%BB"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">java.util.Date类与java.sql.Date类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jdk-8.0%E4%B8%AD%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">JDK 8.0中新的日期时间类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api%E7%9A%84%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.4.1.</span> <span class="nav-text">日期时间API的迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E4%B8%A4%E4%BB%A3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.</span> <span class="nav-text">前两代的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">本地日期、本地时间、本地日期时间的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text">Java比较器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%E4%BD%BF%E7%94%A8compareble%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.1.</span> <span class="nav-text">自然排序：使用Compareble接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-1"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">自定义类代码举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%E4%BD%BF%E7%94%A8comparator%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.2.</span> <span class="nav-text">定制排序：使用Comparator接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-2"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="nav-number">1.5.3.</span> <span class="nav-text">两种排序方式对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">1.6.</span> <span class="nav-text">其他常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#system%E7%B1%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">System类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">成员方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#math%E7%B1%BB"><span class="nav-number">1.6.2.</span> <span class="nav-text">Math类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">枚举类和注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">枚举类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">2.1.1.</span> <span class="nav-text">枚举类的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">2.1.2.</span> <span class="nav-text">如何自定义枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.3.</span> <span class="nav-text">注解的使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5jdk%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">示例：在编译时进行格式检查(JDK内置的个基本注解)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.1.4.</span> <span class="nav-text">如何自定义注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.1.5.</span> <span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="nav-number">2.1.6.</span> <span class="nav-text">如何获取注解信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk8.0%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.7.</span> <span class="nav-text">JDK8.0中的新特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.</span> <span class="nav-text">集合与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.1.</span> <span class="nav-text">存储数据概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.2.</span> <span class="nav-text">集合的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.3.</span> <span class="nav-text">集合的框架结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.2.</span> <span class="nav-text">Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">单列集合框架结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#collection%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.2.2.</span> <span class="nav-text">Collection集合与数组的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterator%E6%8E%A5%E5%8F%A3%E4%B8%8Eforeach%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.3.</span> <span class="nav-text">Iterator接口与foreach循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">遍历Collection接口的两种方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collection%E5%AD%90%E6%8E%A5%E5%8F%A3list%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.4.</span> <span class="nav-text">Collection子接口：List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%89%B9%E7%82%B9"><span class="nav-number">3.4.1.</span> <span class="nav-text">存储的数据特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linkedlist%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">LinkedList的源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">Vector的源码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">3.4.2.</span> <span class="nav-text">存储元素的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">3.4.3.</span> <span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collection%E5%AD%90%E6%8E%A5%E5%8F%A3set%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-number">3.5.</span> <span class="nav-text">Collection子接口：Set接口概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%89%B9%E7%82%B9"><span class="nav-number">3.5.1.</span> <span class="nav-text">存储数据特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text">元素添加过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="nav-number">3.5.3.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99-equals-%E6%96%B9%E6%B3%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">重写 equals() 方法基本原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eclipseidea%E5%B7%A5%E5%85%B7%E9%87%8Chashcode%E9%87%8D%E5%86%99"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">Eclipse&#x2F;IDEA工具里hashCode()重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#treeset"><span class="nav-number">3.5.3.3.</span> <span class="nav-text">TreeSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#treeset%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.5.4.</span> <span class="nav-text">TreeSet的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">使用说明:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">常用的排序方式:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.5.</span> <span class="nav-text">常见实现类结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linkedhashmap"><span class="nav-number">3.5.5.1.</span> <span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashtable"><span class="nav-number">3.5.5.2.</span> <span class="nav-text">Hashtable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#properties"><span class="nav-number">3.5.5.3.</span> <span class="nav-text">Properties</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="nav-number">3.5.6.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">添加、删除、修改操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="nav-number">3.5.7.</span> <span class="nav-text">内存结构说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hashmap%E5%9C%A8jdk-7.0%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.7.1.</span> <span class="nav-text">HashMap在JDK 7.0中实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#hashmap%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.7.1.1.</span> <span class="nav-text">HashMap的存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">3.5.7.1.2.</span> <span class="nav-text">对象创建和添加过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashmap%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="nav-number">3.5.7.1.3.</span> <span class="nav-text">HashMap的扩容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashmap%E6%89%A9%E5%AE%B9%E6%97%B6%E6%9C%BA"><span class="nav-number">3.5.7.1.4.</span> <span class="nav-text">HashMap扩容时机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashmap%E5%9C%A8jdk-8.0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.7.2.</span> <span class="nav-text">HashMap在JDK 8.0底层实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#hashmap%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="nav-number">3.5.7.2.1.</span> <span class="nav-text">HashMap的存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashmap%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.5.7.2.2.</span> <span class="nav-text">HashMap添加元素的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.7.2.3.</span> <span class="nav-text">HashMap的扩容机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk-8.0%E4%B8%8Ejdk-7.0%E4%B8%ADhashmap%E5%BA%95%E5%B1%82%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">3.5.7.2.4.</span> <span class="nav-text">JDK 8.0与JDK
7.0中HashMap底层的变化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashmap%E5%BA%95%E5%B1%82%E5%85%B8%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">3.5.7.3.</span> <span class="nav-text">HashMap底层典型属性的属性的说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linkedhashmap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.7.4.</span> <span class="nav-text">LinkedHashMap的底层实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#treemap%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.5.8.</span> <span class="nav-text">TreeMap的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-4"><span class="nav-number">3.5.9.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">3.5.9.1.</span> <span class="nav-text">排序操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="nav-number">3.5.9.2.</span> <span class="nav-text">同步控制</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

