<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="试试 冰冷昂贵入云涉水的轻身术。看看 演员王公游民盗贼的心电图">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记（一）">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="试试 冰冷昂贵入云涉水的轻身术。看看 演员王公游民盗贼的心电图">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.449Z">
<meta property="article:modified_time" content="2021-10-12T06:43:17.711Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统笔记（一） | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统笔记（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-12 14:43:17" itemprop="dateModified" datetime="2021-10-12T14:43:17+08:00">2021-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <div class="post-description"><blockquote class="blockquote-center">试试 冰冷昂贵入云涉水的轻身术。看看 演员王公游民盗贼的心电图</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="操作系统概述">操作系统概述</h1>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hbxaE6"><img
src="https://z3.ax1x.com/2021/09/09/hbxaE6.png"
alt="hbxaE6.png" /></a></p>
<h2 id="操作系统">操作系统</h2>
<p><strong>现代计算机系统</strong>
由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hbx6KA"><img
src="https://z3.ax1x.com/2021/09/09/hbx6KA.png"
alt="hbx6KA.png" /></a></p>
<p>然而，程序员不会直接和这些硬件打交道，而且每位程序员不可能会掌握所有计算机系统的细节，这样我们就不用再编写代码了，所以在硬件的基础之上，计算机安装了一层软件，这层软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户需求，这种软件称之为
<strong>操作系统</strong>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。</p>
<p>我们一般常见的操作系统主要有 Windows、Linux、FreeBSD 或 OS X
，这种带有图形界面的操作系统被称为
<code>图形用户界面(Graphical User Interface, GUI)</code>，而基于文本、命令行的通常称为
<code>Shell</code>。下面是我们所要探讨的操作系统的部件。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hjTCD0"><img
src="https://z3.ax1x.com/2021/09/10/hjTCD0.png"
alt="hjTCD0.png" /></a></p>
<p>这是一个操作系统的简化图，最下面的是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，在硬件之上是软件。<strong>大部分计算机有两种运行模式</strong>：<code>内核态</code>
和 <code>用户态</code>，软件中最基础的部分是操作系统，它运行在
<code>内核态</code> 中，<strong>内核态</strong>也称为 <code>管态</code>
和
<code>核心态</code>，它们都是操作系统的运行状态，只不过是不同的叫法而已。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在
<code>用户态</code> 下。</p>
<p><strong>用户接口程序(shell 或者 GUI)</strong>
处于<code>用户态</code>中，并且它们位于用户态的最低层，允许用户运行其他程序，例如
Web
浏览器、电子邮件阅读器、音乐播放器等。而且，越靠近用户态的应用程序越容易编写，如果你不喜欢某个电子邮件阅读器你可以重新写一个或者换一个，但你不能自行写一个操作系统或者是中断处理程序。这个程序由硬件保护，防止外部对其进行修改。</p>
<h2 id="计算机硬件简介">计算机硬件简介</h2>
<p>操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源。因此，操作系统因此必须足够了解硬件的运行，这里我们先简要介绍一下现代计算机中的计算机硬件。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4po1Ld"><img
src="https://z3.ax1x.com/2021/09/12/4po1Ld.png"
alt="4po1Ld.png" /></a></p>
<p>从概念上来看，一台简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O
设备都和总线串联起来并通过总线与其他设备进行通信。现代操作系统有着更为复杂的结构，会设计很多条总线，我们稍后会看到。暂时来讲，这个模型能够满足我们的讨论。</p>
<h3 id="cpu">CPU</h3>
<p><strong>CPU</strong>
是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个 CPU
的执行周期是从内存中提取第一条指令、解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。</p>
<p>每个 CPU 都有一组可以执行的特定指令集。因此，x86 的 CPU 不能执行 ARM
的程序并且 ARM 的 CPU 也不能执行 x86
的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的
CPU
内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如
add 操作就会把两个操作数相加并把结果保存到内存中。</p>
<p>除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。其中之一就是
<strong>程序计数器(program counter)</strong>
，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。</p>
<p>另一个寄存器是 <strong>堆栈指针(stack pointer)</strong>
，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。</p>
<p>还有一个寄存器是 <strong>PSW(Program Status Word)
程序状态字寄存器</strong>，这个寄存器是由操作系统维护的8个字节(64位)
long
类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略
PSW 。用户程序通常可以读取整个PSW，但通常只能写入其某些字段。PSW
在系统调用和 I / O 中起着重要作用。</p>
<p>操作系统必须了解所有的寄存器。在<strong>时间多路复用(time
multiplexing)</strong> 的 CPU
中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时，操作系统会保存所有寄存器的值，以便于后续重新运行该程序。</p>
<p>为了提升性能， CPU
设计人员早就放弃了同时去读取、解码和执行一条简单的指令。许多现代的 CPU
都具有同时读取多条指令的机制。例如，一个 CPU
可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N
条指令时，还可以对 N + 1 条指令解码，还可以读取 N + 2
条指令。像这样的组织形式被称为 <strong>流水线(pipeline)</strong> 。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/490IKO"><img
src="https://z3.ax1x.com/2021/09/12/490IKO.png"
alt="490IKO.png" /></a></p>
<p>比流水线更先进的设计是
<strong>超标量(superscalar)CPU</strong>，下面是超标量 CPU 的设计</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/490XGt"><img
src="https://z3.ax1x.com/2021/09/12/490XGt.png"
alt="490XGt.png" /></a></p>
<p>在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。</p>
<p>除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU
都有两种模式，即前面已经提到的内核态和用户态。通常情况下，PSW
寄存器中的一个二进制位会控制当前状态是内核态还是用户态。当运行在内核态时，CPU
能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下，剩下的一部分运行在用户态下。</p>
<p>用户应用程序通常运行在用户态下，在用户态下，CPU
只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关
I/O 和内存保护的所有指令是禁止执行的。当然，设置 PSW
模式的二进制位为内核态也是禁止的。</p>
<p>为了获取操作系统的服务，用户程序必须使用 <strong>系统调用(system
call)</strong> ，系统调用会转换为内核态并且调用操作系统。TRAP
指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。</p>
<p>需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。</p>
<h3 id="多线程和多核芯片">多线程和多核芯片</h3>
<p>Intel Pentinum
4也就是奔腾处理器引入了被称为<code>多线程</code>(multithreading) 或
<code>超线程</code>(hyperthreading, Intel 公司的命名) 的特性，x86
处理器和其他一些 CPU 芯片就是这样做的。包括 SSPARC、Power5、Intel Xeon
和 Intel Core 系列 。近似地说，多线程允许 CPU
保持两个不同的线程状态并且在纳秒级(nanosecond)
的时间完成切换。线程是一种轻量级的进程，我们会在后面说到。例如，如果一个进程想要从内存中读取指令(这通常会经历几个时钟周期)，多线程
CPU
则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。</p>
<p>对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的
CPU。比如一个有两个 CPU 的操作系统，并且每个 CPU
运行两个线程，那么这对于操作系统来说就可能是 4 个 CPU。</p>
<p>除了多线程之外，现在许多 CPU
芯片上都具有四个、八个或更多完整的处理器或内核。多核芯片在其上有效地承载了四个微型芯片，每个微型芯片都有自己的独立CPU。</p>
<p>如果要说在绝对核心数量方面，没有什么能赢过现代 GPU(Graphics
Processing Unit)，GPU
是指由成千上万个微核组成的处理器。它们擅长处理大量并行的简单计算。</p>
<h3 id="内存">内存</h3>
<p>计算机中第二个主要的组件就是内存。理想情况下，内存应该非常快速(比执行一条指令要快，从而不会拖慢
CPU
执行效率)，而且足够大且便宜，但是目前的技术手段无法满足三者的需求。于是采用了不同的处理方式，存储器系统采用一种分层次的结构</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4Peqde"><img
src="https://z3.ax1x.com/2021/09/13/4Peqde.png"
alt="4Peqde.png" /></a></p>
<p>顶层的存储器速度最高，但是容量最小，成本非常高，层级结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜。</p>
<h4 id="寄存器">寄存器</h4>
<p>存储器的顶层是 CPU 中的<strong>寄存器</strong>，它们用和 CPU
一样的材料制成，所以和 CPU
一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）</p>
<h4 id="高速缓存">高速缓存</h4>
<p>位于寄存器下面的是<strong>高速缓存</strong>，它多数由硬件控制。主存被分割成<strong>高速缓存行(cache
lines)</strong> 为 64 字节，内存地址的 0 - 63 对应高速缓存行 0 ，地址 64
- 127 对应高速缓存行的 1，等等。使用最频繁的高速缓存行保存在位于 CPU
内部或非常靠近 CPU
的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是<code>高速缓存命中(cache hit)</code>
。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</p>
<p>缓存在计算机很多领域都扮演了非常重要的角色，不仅仅是 RAM 缓存行。</p>
<blockquote>
<p>“<strong>随机存储器（RAM）</strong>：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</p>
</blockquote>
<p>大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权，缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于
<code>/home/ast/projects/minix3/src/kernel/clock.c</code>
这样的长路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个
Web 页面(URL)
的地址转换为网络地址(IP地址)后，这个转换结果也可以缓存起来供将来使用。</p>
<p>在任何缓存系统中，都会有下面这几个噬需解决的问题 -
何时把新的内容放进缓存 - 把新的内容应该放在缓存的哪一行 -
在需要空闲空间时，应该把哪块内容从缓存中移除 -
应该把移除的内容放在某个较大存储器的何处</p>
<p>并不是每个问题都与每种缓存情况有关。对于 CPU
缓存中的主存缓存行，当有缓存未命中时，就会调入新的内容。通常通过所引用内存地址的高位计算应该使用的缓存行。</p>
<p>缓存是解决问题的一种好的方式，所以<strong>现代 CPU
设计了两种缓存</strong> 。第一级缓存或者说是 <code>L1 cache</code>
总是位于 CPU 内部，用来将已解码的指令调入 CPU
的执行引擎。对于那些频繁使用的关键字，多数芯片有第二个 L1 cache 。典型的
L1 cache 的大小为 16 KB。另外，往往还设有二级缓存，也就是
<code>L2 cache</code>，用来存放最近使用过的关键字，一般是兆字节为单位。<strong>L1
cache 和 L2 cache 最大的不同在于是否存在延迟</strong> 。访问 L1 cache
没有任何的延迟，然而访问 L2 cache 会有 1 - 2 个时钟周期的延后。</p>
<blockquote>
<p>“什么是<strong>时钟周期</strong>？计算机处理器或 CPU
的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以
Hz 为单位测量，通常为兆赫（MHz）或千兆赫（GHz）。例如，一个4
GHz处理器每秒执行4,000,000,000个时钟周期。计算机处理器可以在每个时钟周期执行一条或多条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的
CPU
在每个时钟周期只能执行一条指令，而现代处理器在每个时钟周期可以执行多条指令。</p>
</blockquote>
<h4 id="主存">主存</h4>
<p>在上面的层次结构中再下一层是<strong>主存</strong>
，这是内存系统的主力军，主存通常叫做 <strong>RAM(Random Access
Memory)</strong> ，由于 1950 年代和 1960
年代的计算机使用微小的可磁化铁氧体磁芯作为主存储器，因此旧时有时将其称为核心存储器。所有不能再高速缓存中得到满足的内存访问请求都会转往主存中。</p>
<p>除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与
RAM
不同，在电源断电后，非易失性随机访问存储器并不会丢失内容。<strong>ROM(Read
Only Memory)</strong>
中的内容一旦存储后就不会再被修改。它非常快而且便宜。（如果有人问你，有没有什么又快又便宜的内存设备，那就是
ROM 了）在计算机中，用于启动计算机的引导加载模块（也就是 bootstrap
）就存放在 ROM 中。另外，一些 I/O 卡也采用 ROM 处理底层设备控制。</p>
<p><strong>EEPROM(Electrically Erasable PROM)</strong> 和
<strong>闪存(flash memory)</strong> 也是非易失性的，但是与 ROM
相反，它们可以擦除和重写。不过重写它们需要比写入 RAM
更多的时间，所以它们的使用方式与 ROM 相同，但是与 ROM
不同的是他们可以通过重写字段来纠正程序中出现的错误。</p>
<p><strong>闪存</strong>也通常用来作为便携性的存储媒介。闪存是数码相机中的胶卷，是便携式音乐播放器的磁盘。闪存的速度介于
RAM
和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除的次数太多，会出现磨损。</p>
<p>还有一类是 <strong>CMOS</strong> ，它是易失性的。许多计算机都会使用
CMOS 存储器保持当前时间和日期。</p>
<h3 id="磁盘">磁盘</h3>
<p>下一个层次是磁盘(硬盘)，磁盘同 RAM
相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了三个数量级。磁盘访问慢的原因是因为磁盘的构造不同</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4PGyEq"><img
src="https://z3.ax1x.com/2021/09/13/4PGyEq.png"
alt="4PGyEq.png" /></a></p>
<p>磁盘是一种机械装置，在一个磁盘中有一个或多个金属盘片，它们以
5400rpm、7200rpm、10800rpm
或更高的速度旋转。从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片
33
转唱机上的拾音臂。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为
<strong>磁道(track)</strong>
。把一个给定臂的位置上的所有磁道合并起来，组成了一个
<strong>柱面(cylinder)</strong> 。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4PJQiV"><img
src="https://z3.ax1x.com/2021/09/13/4PJQiV.png"
alt="4PJQiV.png" /></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4PJNZR"><img
src="https://z3.ax1x.com/2021/09/13/4PJNZR.png"
alt="4PJNZR.png" /></a></p>
<p>每个磁道划分若干扇区，扇区的值是 512
字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要
1ms。而随机移到一个柱面的典型时间为 5ms 至
10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是50MB/s，而高速磁盘的速率是
160MB/s。</p>
<blockquote>
<p>“需要注意，固态硬盘(Solid State Disk,
SSD)不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中，与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。</p>
</blockquote>
<p>许多计算机支持一种著名的 <strong>虚拟内存机制</strong>
，这种机制使得期望运行的存储空间大于实际的物理存储空间。其方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在
RAM 中的物理地址。这种映像由 CPU 中的一个称为 存储器管理单元(Memory
Management Unit, MMU) 的部件来完成。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4P6P29"><img
src="https://z3.ax1x.com/2021/09/13/4P6P29.png"
alt="4P6P29.png" /></a></p>
<p>缓存和 MMU
的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为
<strong>上下文切换(context switch)</strong>
，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。</p>
<h3 id="io-设备">I/O 设备</h3>
<p>CPU 和存储器不是操作系统需要管理的全部，I/O
设备也与操作系统关系密切。可以参考上面这个图片，I/O
设备一般包括两个部分：<strong>设备控制器和设备本身</strong>
。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。</p>
<p>在许多情况下，实际控制设备的过程是非常复杂而且存在诸多细节。因此控制器的工作就是为操作系统提供一个更简单（但仍然非常复杂）的接口。也就是屏蔽物理细节。任何复杂的东西都可以加一层代理来解决，这是计算机或者人类社会很普世的一个解决方案。</p>
<p>I/O
设备另一部分是设备本身，设备本身有一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。例如，标准化后任何一个
SATA 磁盘控制器就可以适配任意一种 SATA 磁盘，所以标准化是必要的。ATA
代表 高级技术附件(AT Attachment)，而 SATA 表示串行高级技术附件(Serial
ATA)。</p>
<blockquote>
<p>“AT 是啥？它是 IBM 公司的第二代个人计算机的高级技术成果，使用 1984
年推出的 6MHz 80286 处理器，这个处理器是当时最强大的。</p>
</blockquote>
<p>像是高级这种词汇应该慎用，否则 20 年后再回首很可能会被无情打脸。</p>
<p>现在 SATA
是很多计算机的标准硬盘接口。由于实际的设备接口隐藏在控制器中，所以操作系统看到的是对控制器的接口，这个接口和设备接口有很大区别。</p>
<p>每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为
<strong>设备驱动程序(device driver)</strong>
。每个控制器厂家都应该针对不同的操作系统提供不同的设备驱动程序。</p>
<p>为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。要将设备驱动程序装入操作系统，一般有三个途径:</p>
<ul>
<li><strong>第一个途径</strong>是将内核与设备启动程序重新连接，然后重启系统。这是
<code>UNIX</code> 系统采用的工作方式</li>
<li><strong>第二个途径</strong>是在一个操作系统文件中设置一个入口，通知该文件需要一个设备驱动程序，然后重新启动系统。在重新系统时，操作系统回寻找有关的设备启动程序并把它装载，这是
<code>Windows</code> 采用的工作方式</li>
<li><strong>第三个途径</strong>是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统，这种方式采用的少，但是正变得普及起来。热插拔设备，比如
USB 和 IEEE 1394 都需要动态可装载的设备驱动程序。</li>
</ul>
<p>每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序回从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了
<code>I/O 端口空间</code> 。</p>
<p>在一些计算机中，设备寄存器会被映射到操作系统的可用地址空间，使他们能够向内存一样完成读写操作。在这种计算机中，不需要专门的
I/O
指令，用户程序可以被硬件阻挡在外，防止其接触这些存储器地址（例如，采用基址寄存器和变址寄存器）。在另一些计算机中，设备寄存器被放入一个专门的
I/O 端口空间，每个寄存器都有一个端口地址。在这些计算机中，特殊的 IN 和
OUT
指令会在内核态下启用，它能够允许设备驱动程序和寄存器进行读写。前面第一种方式会限制特殊的
I/O
指令但是允许一些地址空间；后者不需要地址空间但是需要特殊的指令，这两种应用都很广泛。</p>
<blockquote>
<p>实现输入和输出的方式有三种</p>
</blockquote>
<ul>
<li><p>在最简单的方式中，用户程序会发起系统调用，内核会将其转换为相应驱动程序的程序调用，然后设备驱动程序启动
I/O
并循环检查该设备，看该设备是否完成了工作（一般会有一些二进制位用来指示设备仍在忙碌中）。当
I/O
调用完成后，设备驱动程序把数据送到指定的地方并返回。然后操作系统会将控制权交给调用者。这种方式称为
<code>忙等待(busy waiting)</code>，这种方式的缺点是要一直占据 CPU，CPU
会一直轮询 I/O 设备直到 I/O 操作完成。</p></li>
<li><p>第二种方式是设备驱动程序启动设备并且让该设备在操作完成时发生中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备操作完成时，它发出一个中断通知操作完成。</p></li>
</ul>
<p><code>在操作系统中，中断是非常重要的，所以这需要更加细致的讨论一下。</code></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4PWujJ"><img
src="https://z3.ax1x.com/2021/09/13/4PWujJ.png"
alt="4PWujJ.png" /></a></p>
<p>如上图所示，这是一个三步的 I/O
过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤
2
中使用某些总线向中断控制器发送信号。如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在
CPU
的一个引脚上面声明。这就是步骤3。在第4步中，中断控制器把该设备的编号放在总线上，这样
CPU
可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。</p>
<p>一旦 CPU 决定去实施中断后，程序计数器和 PSW
就会被压入到当前堆栈中并且 CPU
会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作<code>中断向量</code>(interrupt
vector)。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和
PSW
寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令，这个过程如下</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4PW7CT"><img
src="https://z3.ax1x.com/2021/09/13/4PW7CT.png"
alt="4PW7CT.png" /></a></p>
<ul>
<li>实现 I/O 的第三种方式是使用特殊的硬件：<strong>直接存储器访问(Direct
Memory Access, DMA)芯片</strong>
。它可以控制内存和某些控制器之间的位流，而无需 CPU 的干预。CPU 会对 DMA
芯片进行设置，说明需要传送的字节数，有关的设备和内存地址以及操作方向。当
DMA
芯片完成后，会造成中断，中断过程就像上面描述的那样。我们会在后面具体讨论中断过程</li>
</ul>
<p>当另一个中断处理程序正在运行时，中断可能（并且经常）发生在不合宜的时间。因此，CPU
可以禁用中断，并且可以在之后重启中断。在 CPU
关闭中断后，任何已经发出中断的设备，可以继续保持其中断信号处理，但是 CPU
不会中断，直至中断再次启用为止。如果在关闭中断时，已经有多个设备发出了中断信号，中断控制器将决定优先处理哪个中断，通常这取决于事先赋予每个设备的优先级，最高优先级的设备优先赢得中断权，其他设备则必须等待。</p>
<h3 id="总线">总线</h3>
<p>上面的结构（简单个人计算机的组件图）在小型计算机已经使用了多年，并用在早期的
IBM PC
中。然而，随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括
IBM PC 总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理
I/O 设备以及 CPU
到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4P4o5t"><img
src="https://z3.ax1x.com/2021/09/13/4P4o5t.png"
alt="4P4o5t.png" /></a></p>
<p>上图中的 x86 系统包含很多总线，高速缓存、内存、PCIe、PCI、USB、SATA
和
DMI，每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是
<code>PCIe(Peripheral Component Interconnect Express) 总线</code>。</p>
<p>Intel 发明的 PCIe 总线也是作为之前古老的 PCI 总线的继承者，而古老的
PCI 总线也是为了取代古董级别的
<code>ISA(Industry Standard Architecture)</code> 总线而设立的。数十 Gb/s
的传输能力使得 PCIe 比它的前身快很多，而且它们本质上也十分不同。直到发明
PCIe 的 2004
年，大多数总线都是并行且共享的。<code>共享总线架构(shared bus architeture)</code>
表示多个设备使用一些相同的电线传输数据。因此，当多个设备同时发送数据时，此时你需要一个决策者来决定谁能够使用总线。而
PCIe 则不一样，它使用专门的端到端链路。传统 PCI
中使用的<code>并行总线架构(parallel bus architecture)</code>
表示通过多条电线发送相同的数据字。例如，在传统的 PCI 总线上，一个 32
位数据通过 32 条并行的电线发送。而 PCIe
则不同，它选用了<code>串行总线架构(serial bus architecture)</code>
，并通过单个连接（称为通道）发送消息中的所有比特数据，就像网络数据包一样。这样做会简化很多，因为不再确保所有
32
位数据在同一时刻准确到达相同的目的地。通过将多个数据通路并行起来，并行性仍可以有效利用。例如，可以使用
32 条数据通道并行传输 32 条消息。</p>
<p>在上图结构中，CPU 通过 DDR3 总线与内存对话，通过 PCIe
总线与外围图形设备
（GPU）对话，通过<code>DMI(Direct Media Interface)</code>总线经集成中心与所有其他设备对话。而集成控制中心通过串行总线与
USB 设备对话，通过 SATA 总线与硬盘和 DVD 驱动器对话，通过 PCIe
传输以太网络帧。</p>
<p>不仅如此，每一个核 <code>USB(Univversal Serial Bus)</code>
是用来将所有慢速 I/O 设备（比如键盘和鼠标）与计算机相连的设备。USB 1.0
可以处理总计 12 Mb/s 的负载，而 USB 2.0 将总线速度提高到 480Mb/s ，而
USB 3.0 能达到不小于 5Gb/s 的速率。所有的 USB
设备都可以直接连接到计算机并能够立刻开始工作，而不像之前那样要求重启计算机。</p>
<p><code>SCSI(Small Computer System Interface) 总线</code>是一种高速总线，用在高速硬盘，扫描仪和其他需要较大带宽的设备上。现在，它们主要用在服务器和工作站中，速度可以达到
640MB/s 。</p>
<h3 id="计算机启动过程">计算机启动过程</h3>
<p>那么有了上面一些硬件再加上操作系统的支持，我们的计算机就可以开始工作了，那么计算机的启动过程是怎样的呢？下面只是一个简要版的启动过程</p>
<p>在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一般有
BIOS 芯片、I/O
控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。</p>
<p>在母板上有一个称为 <strong>基本输入输出系统(Basic Input Output
System, BIOS)</strong> 的程序。在 BIOS 内有底层 I/O
软件，包括读键盘、写屏幕、磁盘I/O
以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS
中发现错误时，可以由操作系统进行更新。</p>
<p>在计算机<code>启动(booted)</code>时，BIOS 开启，它会首先检查所安装的
RAM 的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描
PCIe 和 PCI
总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一次启动时的设备不同，则新的设备将被重新配置。</p>
<p>然后，BIOS 通过尝试存储在 <strong>CMOS</strong>
存储器中的设备清单尝试启动设备</p>
<blockquote>
<p>“CMOS是 Complementary Metal Oxide
Semiconductor（互补金属氧化物半导体）的缩写。它是指制造大规模集成电路芯片用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的
RAM 芯片。因为可读写的特性，所以在电脑主板上用来保存 BIOS
设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。而对 BIOS
中各项参数的设定要通过专门的程序。BIOS
设置程序一般都被厂商整合在芯片中，在开机时通过特定的按键就可进入 BIOS
设置程序，方便地对系统进行设置。因此 BIOS 设置有时也被叫做 CMOS
设置。</p>
</blockquote>
<p>用户可以在系统启动后进入一个 BIOS
配置程序，对设备清单进行修改。然后，判断是否能够从外部 CD-ROM 和 USB
驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots
设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。</p>
<p>然后操作系统会询问 BIOS
获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入
CD-ROM 驱动（由设备制造商提供）或者从 Internet
上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。</p>
<h2 id="操作系统概念">操作系统概念</h2>
<p>大部分操作系统提供了特定的基础概念和抽象，例如进程、地址空间、文件等，它们是需要理解的核心内容。下面我们会简要介绍一些基本概念，为了说明这些概念，我们会不时的从
<code>UNIX</code>
中提出示例，相同的示例也会存在于其他系统中，我们后面会进行介绍。</p>
<h3 id="进程">进程</h3>
<p>操作系统一个很关键的概念就是 <strong>进程(Process)</strong>
。进程的本质就是操作系统执行的一个程序。与每个进程相关的是<strong>地址空间(address
space)</strong>
，这是从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写操作。地址空间中存放有可执行程序，程序所需要的数据和它的栈。与每个进程相关的还有资源集，通常包括
<strong>寄存器(registers)</strong>
（寄存器一般包括<code>程序计数器(program counter)</code>和<code>堆栈指针(stack pointer)</code>）、打开文件的清单、突发的报警、有关的进程清单和其他需要执行程序的信息。你可以把进程看作是容纳运行一个程序所有信息的一个容器。</p>
<p>对进程建立一种直观感觉的方式是考虑建立一种多程序的系统。考虑下面这种情况：用户启动一个视频编辑程序，指示它按照某种格式转换视频，然后再去浏览网页。同时，一个检查电子邮件的后台进程被唤醒并开始运行，这样，我们目前就会有三个活动进程：视频编辑器、Web
浏览器和电子邮件接收程序。操作系统周期性的挂起一个进程然后启动运行另一个进程，这可能是由于过去一两秒钟程序用完了
CPU 分配的时间片，而 CPU 转而运行另外的程序。</p>
<p>像这样暂时中断进程后，下次应用程序在此启动时，必须要恢复到与中断时刻相同的状态，这在我们用户看起来是习以为常的事情，但是操作系统内部却做了巨大的事情。这就像和足球比赛一样，一场完美精彩的比赛是可以忽略裁判的存在的。这也意味着在挂起时该进程的所有信息都要被保存下来。例如，进程可能打开了多个文件进行读取。与每个文件相关联的是提供当前位置的指针（即下一个需要读取的字节或记录的编号）。当进程被挂起时，必须要保存这些指针，以便在重新启动进程后执行的
<code>read</code>
调用将能够正确的读取数据。在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为
<code>进程表(process table)</code>，进程表是数组或者链表结构，当前存在每个进程都要占据其中的一项。</p>
<p>所以，一个挂起的进程包括：进程的地址空间（往往称作<code>磁芯映像</code>，
core
image，纪念过去的磁芯存储器），以及对应的进程表项（其中包括寄存器以及稍后启动该进程所需要的许多其他信息）。</p>
<p>与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用。考虑一个典型的例子，有一个称为
<code>命令解释器(command interpreter)</code> 或 <code>shell</code>
的进程从终端上读取命令。此时，用户刚键入一条命令要求编译一个程序。shell
必须先创建一个新进程来执行编译程序，当编译程序结束时，它执行一个系统调用来终止自己的进程。</p>
<p>如果一个进程能够创建一个或多个进程（称为<code>子进程</code>），而且这些进程又可以创建子进程，则很容易找到进程数，如下所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4ihUVs"><img
src="https://z3.ax1x.com/2021/09/13/4ihUVs.png"
alt="4ihUVs.png" /></a></p>
<p>上图表示一个进程树的示意图，进程 A 创建了两个子进程 B 和进程
C，子进程 B 又创建了三个子进程 D、E、F。</p>
<p>合作完成某些作业的相关进程经常需要彼此通信来完成作业，这种通信称为<strong>进程间通信(interprocess
communication)</strong> 。我们在后面会探讨进程间通信。</p>
<p>其他可用的进程系统调用包括：申请更多的内存（或释放不再需要的内存），等待一个子进程结束，用另一个程序覆盖该程序。</p>
<p>有时，需要向一个正在运行的进程传递信息，而该进程并没有等待接收信息。例如，一个进程通过网络向另一台机器上的进程发送消息进行通信。为了保证一条消息或消息的应答不丢失。发送者要求它所在的操作系统在指定的若干秒后发送一个通知，这样如果对方尚未收到确认消息就可以进行重新发送。在设定该定时器后，程序可以继续做其他工作。</p>
<p>在限定的时间到达后，操作系统会向进程发送一个
<code>警告信号(alarm signal)</code>。这个信号引起该进程暂时挂起，无论该进程正在做什么，系统将其寄存器的值保存到堆栈中，并开始重新启动一个特殊的信号处理程序，比如重新发送可能丢失的消息。这些信号是软件模拟的硬件中断，除了定时器到期之外，该信号可以通过各种原因产生。许多由硬件检测出来的陷阱，如执行了非法指令或使用了无效地址等，也被转换成该信号并交给这个进程。</p>
<p>系统管理器授权每个进程使用一个给定的
<code>UID(User IDentification)</code>。每个启动的进程都会有一个操作系统赋予的
UID，子进程拥有与父进程一样的
UID。用户可以是某个组的成员，每个组也有一个
<code>GID(Group IDentification)</code>。</p>
<p>在 UNIX 操作系统中，有一个 UID 是
<code>超级用户(superuser)</code>，或者 Windows
中的<code>管理员(administrator)</code>，它具有特殊的权利，可以违背一些保护规则。在大型系统中，只有系统管理员掌握着那些用户可以称为超级用户。</p>
<h3 id="地址空间">地址空间</h3>
<p>每台计算机都有一些主存用来保存正在执行的程序。在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中。为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存。</p>
<p>复杂一些的操作系统会允许多个应用程序同时装入内存中运行。为了防止应用程序之间相互干扰（包括操作系统），需要有某种保护机制。虽然此机制是在硬件中实现，但却是由操作系统控制的。</p>
<p>上述观点涉及对计算机主存的管理和保护。另一种同等重要并与存储器有关的内容是管理进程的地址空间。通常，每个进程有一些可以使用的地址集合，典型值从
0
开始直到某个最大值。一个进程可拥有的最大地址空间小于主存。在这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。</p>
<p>但是，在许多 32 位或 64 位地址的计算机中，分别有 2^32 或 2^64
字节的地址空间。如果一个进程有比计算机拥有的主存还大的地址空间，而且该进程希望使用全部的内存，那该怎么处理？在早期的计算机中是无法处理的。但是现在有了一种<strong>虚拟内存</strong>的技术，正如前面讲到过的，操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们。</p>
<h3 id="文件">文件</h3>
<p>几乎所有操作系统都支持的另一个关键概念就是文件系统。如前所述，操作系统的一项主要功能是屏蔽磁盘和其他
I/O
设备的细节特性，给程序员提供一个良好、清晰的独立于设备的抽象文件模型。<code>创建文件、删除文件、读文件和写文件</code>
都需要系统调用。在文件可以读取之前，必须先在磁盘上定位和打开文件，在文件读过之后应该关闭该文件，有关的系统调用则用于完成这类操作。</p>
<p>为了提供保存文件的地方，大多数个人计算机操作系统都有<code>目录(directory)</code>
的概念，从而可以把文件分组。比如，学生可以给每个课程都创建一个目录，用于保存该学科的资源，另一个目录可以存放电子邮件，再有一个目录可以存放万维网主页。这就需要系统调用创建和删除目录、将已有文件放入目录中，从目录中删除文件等。目录项可以是文件或者目录，目录和目录之间也可以嵌套，这样就产生了文件系统。</p>
<p>进程和文件层次都是以树状的结构组织，但这两种树状结构有不少不同之处。一般进程的树状结构层次不深（很少超过三层），而文件系统的树状结构要深一些，通常会到四层甚至五层。进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在很长时间。进程和文件在权限保护方面也是有区别的。一般来说，父进程能控制和访问子进程，而在文件和目录中通常存在一种机制，使文件所有者之外的其他用户也能访问该文件。</p>
<p>目录层结构中的每一个文件都可以通过从目录的顶部即
<code>根目录(Root directory) 开始的 路径名(path name)</code>
来确定。绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用斜杠分隔符分开，在上面的大学院系文件系统中，文件
CS101 的路径名是
<code>/Faculty/Prof.Brown/Courses/CS101</code>。最开始的斜杠分隔符代表的是<code>根目录 /</code>，也就是文件系统的绝对路径。</p>
<blockquote>
<p>“出于历史原因，Windows 下面的文件系统以  来作为分隔符，但是 Linux
会以 / 作为分隔符。</p>
</blockquote>
<p>在上面的系统中，每个进程会有一个 <strong>工作目录(working
directory)</strong>
，对于没有以斜线开头给出绝对地址的路径，将在这个工作目录下寻找。如果
<code>/Faculty/Prof.Brown</code> 是工作目录，那么
<code>/Courses/CS101</code>
与上面给定的绝对路径名表示的是同一个文件。进程可以通过使用系统调用指定新的工作目录，从而变更其工作目录。</p>
<p>在读写文件之前，首先需要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作<strong>文件描述符(file
descriptor)</strong>，供后续操作使用。若禁止访问，系统则返回一个错误码。</p>
<p>在 UNIX 中，另一个重要的概念是
<code>特殊文件(special file)</code>。提供特殊文件是为了使 I/O
设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O
设备也可以通过同样的系统调用进行读写。特殊文件有两种，一种是<code>块特殊文件(block special file)</code>
和
<code>字符特殊文件(character special file)</code>。块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读取第4块，程序可以直接访问设备的第4块而不必考虑存放在该文件的文件系统结构。类似的，字符特殊文件用于打印机、调制解调起和其他接受或输出字符流的设备。按照惯例，特殊文件保存在
<code>/dev</code> 目录中。例如，/devv/lp 是打印机。</p>
<p>还有一种与进程和文件相关的特性是管道，<strong>管道(pipe)</strong>
是一种虚文件，他可以连接两个进程。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4FD0AO"><img
src="https://z3.ax1x.com/2021/09/14/4FD0AO.png"
alt="4FD0AO.png" /></a></p>
<p>如果 A 和 B 希望通过管道对话，他们必须提前设置管道。当进程 A 相对进程
B 发送数据时，它把数据写到管道上，相当于管道就是输出文件。这样，在 UNIX
中两个进程之间的通信就非常类似于普通文件的读写了。</p>
<h3 id="保护">保护</h3>
<p>计算机中含有大量的信息，用户希望能够对这些信息中有用而且重要的信息加以保护，这些信息包括电子邮件、商业计划等，管理这些信息的安全性完全依靠操作系统来保证。例如，文件提供授权用户访问。</p>
<p>比如 UNIX 操作系统，UNIX 操作系统通过对每个文件赋予一个 9
位二进制保护代码，对 UNIX
中的文件实现保护。该保护代码有三个位子段，一个用于所有者，一个用于与所有者同组（用户被系统管理员划分成组）的其他成员，一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是著名的
<code>rwx位</code>。例如，保护代码 <code>rwxr-x--x</code>
的含义是所有者可以读、写或执行该文件，其他的组成员可以读或执行（但不能写）此文件、而其他人可以执行（但不能读和写）该文件。</p>
<h3 id="shell">shell</h3>
<p>操作系统是执行系统调用的代码。编辑器、编译器、汇编程序、链接程序、使用程序以及命令解释符等，尽管非常重要，非常有用，但是它们确实不是操作系统的组成部分。下面我们着重介绍一下
UNIX 下的命令提示符，也就是 <code>shell</code>，shell
虽然有用，但它也不是操作系统的一部分，然而它却能很好的说明操作系统很多特性，下面我们就来探讨一下。</p>
<p>shell 有许多种，例如<code>sh、csh、ksh 以及 bash</code>
等，它们都支持下面这些功能，最早起的 shell 可以追溯到 sh</p>
<p>用户登录时，会同时启动一个
shell，它以终端作为标准输入和标准输出。首先显示<code>提示符(prompt)</code>，它可能是一个美元符号($)，提示用户
shell 正在等待接收命令，假如用户输入 date，shell
会创建一个子进程，并运行 date 做为子进程。在该子进程运行期间，shell
将等待它结束。在子进程完成时，shell 会显示提示符并等待下一行输入。</p>
<p>用户可以将标准输出重定向到一个文件中，例如
<code>date &gt; file</code> 同样的，也可以将标准输入作为重定向
<code>sort &lt;file1&gt; file2</code></p>
<p>这会调用 sort 程序来接收 file1 的内容并把结果输出到 file2。</p>
<p>可以将一个应用程序的输出通过管道作为另一个程序的输入，因此有</p>
<p><code>cat file1 file2 file3 | sort &gt; /dev/lp</code></p>
<p>这会调用 cat 应用程序来合并三个文件，将其结果输送到 sort
程序中并按照字典进行排序。sort 应用程序又被重定向到 /dev/lp
，显然这是一个打印操作。</p>
<h2 id="系统调用">系统调用</h2>
<p>我们已经可以看到操作系统提供了两种功能：为用户提供应用程序抽象和管理计算机资源。对于大部分在应用程序和操作系统之间的交互主要是应用程序的抽象，例如创建、写入、读取和删除文件。计算机的资源管理对用户来说基本上是透明的。因此，用户程序和操作系统之间的接口主要是处理抽象。为了真正理解操作系统的行为，我们必须仔细的分析这个接口。</p>
<p>多数现代操作系统都有功能相同但是细节不同的系统调用，引发操作系统的调用依赖于计算机自身的机制，而且必须用汇编代码表达。任何单
CPU
计算机一次执行执行一条指令。如果一个进程在用户态下运行用户程序，例如从文件中读取数据。那么如果想要把控制权交给操作系统控制，那么必须执行一个异常指令或者系统调用指令。操作系统紧接着需要参数检查找出所需要的调用进程。操作系统紧接着进行参数检查找出所需要的调用进程。然后执行系统调用，把控制权移交给系统调用下面的指令。大致来说，系统调用就像是执行了一个特殊的过程调用，但是只有<strong>系统调用能够进入内核态而过程调用则不能进入内核态</strong>。</p>
<p>为了能够了解具体的调用过程，下面我们以 <strong>read</strong>
方法为例来看一下调用过程。像上面提到的那样，会有三个参数，第一个参数是指定文件、第二个是指向缓冲区、第三个参数是给定需要读取的字节数。就像几乎所有系统调用一样，它通过使用与系统调用相同的名称来调用一个函数库，从而从C程序中调用：read。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = read(fd,buffer,nbytes);</span><br></pre></td></tr></table></figure>
<p>系统调用在 count 中返回实际读出的字节数。这个值通常与 nbytes
相同，但也可能更小。比如在读过程中遇到了文件尾的情况。</p>
<p>如果系统调用不能执行，不管是因为无效的参数还是磁盘错误，count
的值都会被置成 -1，然后在全局变量 errno
中放入错误信号。程序应该进场检查系统调用的结果以了解是否出错。</p>
<p>系统调用是通过一系列的步骤实现的，为了更清楚的说明这个概念，我们还以
read 调用为例，在准备系统调用前，首先会把参数压入堆栈，如下所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4F6hss"><img
src="https://z3.ax1x.com/2021/09/14/4F6hss.png"
alt="4F6hss.png" /></a></p>
<p>C 和 C++ 编译器使用逆序（必须把第一个参数赋值给
printf(格式字符串)，放在堆栈的顶部）。第一个参数和第三个参数都是值调用，但是第二个参数通过引用传递，即传递的是缓冲区的地址（由
&amp; 指示），而不是缓冲的内容。然后是 C 调用系统库的 read
函数，这也是第四步。</p>
<p>在由汇编语言写成的库过程中，一般把系统调用的编号放在操作系统所期望的地方，如寄存器（第五步）。然后执行一个
<code>TRAP</code>
指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行第六步。TRAP
指令实际上与过程调用指令非常相似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中的返回地址。</p>
<p>TRAP 指令与过程调用指令存在两个方面的不同</p>
<ul>
<li>TRAP
指令会改变操作系统的状态，由用户态切换到内核态，而过程调用不改变模式</li>
<li>其次，TRAP
指令不能跳转到任意地址上。根据机器的体系结构，要么跳转到一个单固定地址上，或者指令中有一
8
位长的字段，它给定了内存中一张表格的索引，这张表格中含有跳转地址，然后跳转到指定地址上。</li>
</ul>
<p>跟随在 TRAP
指令后的内核代码开始检查系统调用编号，然后dispatch给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成第七步。此时，系统调用处理器运行第八步，一旦系统调用处理器完成工作，控制权会根据
TRAP
指令后面的指令中返回给函数调用库第九步。这个过程接着以通常的过程调用返回的方式，返回到客户应用程序，这是第十步。然后调用完成后，操作系统还必须清除用户堆栈，然后增加<strong>堆栈指针(increment
stackpointer)</strong> ，用来清除调用 read 之前压入的参数。从而完成整个
read 调用过程。</p>
<p>在上面的第九步中我们说到，控制可能返回 TRAP
指令后面的指令，把控制权再移交给调用者这个过程中，系统调用会发生阻塞，从而避免应用程序继续执行。这么做是有原因的。例如，如果试图读键盘，此时并没有任何输入，那么调用者就必须被阻塞。在这种情形下，操作系统会检查是否有其他可以运行的进程。这样，当有用户输入时候，进程会提醒操作系统，然后返回第
9 步继续运行。</p>
<h3 id="用于进程管理的系统调用">用于进程管理的系统调用</h3>
<p>在 UNIX 中，<strong>fork</strong> 是唯一可以在 POSIX
中创建进程的途径，它创建一个原有进程的副本，包括所有的文件描述符、寄存器等内容。在
fork 之后，原有进程以及副本（父与子）就分开了。在 fork
过程中，所有的变量都有相同的值，虽然父进程的数据通过复制给子进程，但是后续对其中任何一个进程的修改不会影响到另外一个。fork
调用会返回一个值，在子进程中该值为 0 ，并且在父进程中等于子进程的
<strong>进程标识符(Process IDentified,PID)</strong> 。使用返回的
PID，就可以看出来哪个是父进程和子进程。</p>
<p>在多数情况下， 在 <code>fork</code>
之后，子进程需要执行和父进程不一样的代码。从终端读取命令，创建一个子进程，等待子进程执行命令，当子进程结束后再读取下一个输入的指令。为了等待子进程完成，父进程需要执行
<code>waitpid</code>
系统调用，父进程会等待直至子进程终止（若有多个子进程的话，则直至任何一个子进程终止）。waitpid
可以等待一个特定的子进程，或者通过将第一个参数设为 -1
的方式，等待任何一个比较老的子进程。当 waitpid 完成后，会将第二个参数
<code>statloc</code>
所指向的地址设置为子进程的退出状态（正常或异常终止以及退出值）。有各种可使用的选项，它们由第三个参数确定。例如，如果没有已经退出的子进程则立刻返回。</p>
<p>那么 shell 该如何使用 fork 呢？ 在键入一条命令后， shell 会调用 fork
命令创建一个新的进程。这个子进程会执行用户的指令。通过使用
<code>execve</code>
系统调用可以实现系统执行，这个系统调用会引起整个核心映像被一个文件所替代，该文件由第一个参数给定。下面是一个简化版的例子说明
fork、waitpid 和 execve 的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define TRUE 1</span><br><span class="line"></span><br><span class="line">/* 一直循环下去 */</span><br><span class="line">while(TRUE)&#123;			</span><br><span class="line"></span><br><span class="line">/* 在屏幕上显示提示符 */</span><br><span class="line">	type_prompt();			</span><br><span class="line">  </span><br><span class="line">  /* 从终端读取输入 */</span><br><span class="line">	read_command(command,parameters)		</span><br><span class="line">  </span><br><span class="line">  /* fork 子进程 */</span><br><span class="line">	if(fork() != 0)&#123;								</span><br><span class="line">  </span><br><span class="line">		/* 父代码 */</span><br><span class="line">		/* 等待子进程执行完毕 */</span><br><span class="line">		waitpid(-1, &amp;status, 0);								</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">	</span><br><span class="line">		/* 执行命令 */</span><br><span class="line">		/* 子代码 */</span><br><span class="line">		execve(command,parameters,0)					</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，<strong><em>execve
有三个参数</em></strong>：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。这里对这些参数做一个简要的说明。</p>
<p>先看一个 shell 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure>
<p>此命令把 file1 复制到 file2 文件中，在 shell 执行 fork
之后，子进程定位并执行文件拷贝，并将源文件和目标文件的名称传递给它。</p>
<p>cp 的主程序（以及包含其他大多数 C 程序的主程序）包含声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(argc,argv,envp)</span><br></pre></td></tr></table></figure>
<p>其中 <code>argc</code>
是命令行中参数数目的计数，包括程序名称。对于上面的例子，argc
是3。第二个参数 <code>argv</code> 是数组的指针。该数组的元素 i
是指向该命令行第 i 个字符串的指针。在上面的例子中，argv[0] 指向字符串
cp，argv[1] 指向字符串 file1，argv[2] 指向字符串 file2。main
的第三个参数是指向环境的指针，该环境是一个数组，含有
<code>name = value</code>
的赋值形式，用以将诸如终端类型以及根目录等信息传送给程序。这些变量通常用来确定用户希望如何完成特定的任务（例如，使用默认打印机）。在上面的例子中，没有环境参数传递给
execve ，所以环境变量是 0 ，所以 execve 的第三个参数为 0 。</p>
<p>可能你觉得 execve 过于复杂，这时候我要鼓励一下你，execve 可能是 POSIX
的全部系统调用中最复杂的一个了，其他都比较简单。作为一个简单的例子，我们再来看一下
<strong>exit</strong>
，这是进程在执行完成后应执行的系统调用。这个系统调用有一个参数，它的退出状态是
0 - 255 之间，它通过 waitpid 系统调用中的 statloc 返回给父级。</p>
<p><code>UNIX 中的进程将内存划分成三个部分</code>：<strong>text
segment(文本区)</strong> ，例如程序代码，<strong>data
segment(数据区)</strong> ，例如变量，<strong>stack
segment(栈区域)</strong> 。数据向上增长而堆栈向下增长，如下图所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4Fguu9"><img
src="https://z3.ax1x.com/2021/09/14/4Fguu9.png"
alt="4Fguu9.png" /></a></p>
<p>上图能说明三个部分的内存分配情况，夹在中间的是空闲区，也就是未分配的区域，堆栈在需要时自动的挤压空闲区域，不过数据段的扩展是显示地通过系统调用
brk 进行的，在数据段扩充后，该系统调用指向一个新地址。但是，这个调用不是
POSIX 标准中定义的，对于存储器的动态分配，鼓励程序员使用 malloc 函数，而
malloc
的内部实现则不是一个适合标准化的主题，因为几乎没有程序员直接使用它。</p>
<h3 id="用于文件管理的系统调用">用于文件管理的系统调用</h3>
<p>许多系统调用都与文件系统有关，要读写一个文件，必须先将其打开。这个系统调用通过绝对路径名或指向工作目录的相对路径名指定要打开文件的名称，而代码
O_RDONLY、 O_WRONLY 或 O_RDWR
的含义分别是只读、只写或者两者都可以，为了创建一个新文件，使用 O_CREATE
参数。然后可使用返回的文件描述符进行读写操作。接着，可以使用 close
关闭文件，这个调用使得文件描述符在后续的 open 中被再次使用。</p>
<p>最常用的调用还是 read 和 write，我们再前面探讨过 read 调用，write
具有与 read 相同的参数。</p>
<p>尽管多数程序频繁的读写文件，但是仍有一些应用程序需要能够随机访问一个文件的任意部分。与每个文件相关的是一个指向文件当前位置的指针。在顺序读写时，该指针通常指向要读出（写入）的下一个字节。Iseek
调用可以改变该位置指针的值，这样后续的 read 或 write
调用就可以在文件的任何地方开始。</p>
<p>Iseek 有三个参数，position =
iseek(fd,offset,whence)，第一个是文件描述符，第二个是文件位置，第三个是说明该文件位置是相对于文件起始位置，当前位置还是文件的结尾。在修改了指针之后，Iseek
所返回的值是文件中的绝对位置。</p>
<p>UNIX
为每个文件保存了该文件的类型（普通文件、特殊文件、目录等）、大小，最后修改时间以及其他信息，程序可以通过
stat 系统调用查看这些信息。s =
stat(name,&amp;buf)，第一个参数指定了被检查的文件；第二个参数是一个指针，该指针指向存放这些信息的结构。对于一个打开的文件而言，fstat
调用完成同样的工作。</p>
<h3 id="用于目录管理的系统调用">用于目录管理的系统调用</h3>
<p>下面我们探讨目录和整个文件系统的系统调用，上面探讨的是和某个文件有关的系统调用。mkdir
和 rmdir 分别用于创建 (s = mkdir(nname,mode)) 和删除 (s = rmdir(name))
空目录，下一个调用是 s = link(name1,name2)。
它的作用是允许同一个文件以两个或者多个名称出现，多数情况下是在不同的目录中使用
link ，下面我们探讨一下 link 是如何工作的</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4VIXgs"><img
src="https://z3.ax1x.com/2021/09/15/4VIXgs.png"
alt="4VIXgs.png" /></a></p>
<p>图中有两个用户 <code>ast</code> 和
<code>jim</code>，每个用户都有他自己的一个目录和一些文件，如果 ast
要执行一个包含下面系统调用的应用程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link(&quot;/usr/jim/memo&quot;, &quot;/usr/ast/note&quot;);</span><br></pre></td></tr></table></figure>
<p>jim 中的 memo 文件现在会进入到 ast 的目录中，在 note
名称下。此后，<code>/usr/jim/memo</code> 和 <code>/usr/ast/note</code>
会有相同的名称。</p>
<p>要理解 link 是如何工作的需要清楚 link 做了什么操作。UNIX
中的每个文件都有一个独一无二的版本，也称作 i -
number，i-编号，它标示着不同文件的版本。这个 i - 编号是 i-nodes,i-节点
表的索引。每个文件都会表明谁拥有这个文件，这个磁盘块的位置在哪，等等。目录只是一个包含一组（i编号，ASCII名称）对应的文件。UNIX
中的第一个版本中，每个目录项都会有 16 个字节，2 个字节对应 i - 编号和 14
个字节对应其名称。现在需要一个更复杂的结构需要支持长文件名，但是从概念上讲一个目录仍是一系列（i-编号，ASCII
名称）的集合。在上图中，mail 的 i-编号为 16，依此类推。link
只是利用某个已有文件的
i-编号，创建一个新目录项（也许用一个新名称）。在上图 b
中，你会发现有两个相同的 70
i-编号的文件，因此它们需要有相同的文件。如果其中一个使用了 unlink
系统调用的话，其中一个会被移除，另一个将保留。如果两个文件都移除了，则
UNIX
会发现该文件不存在任何没有目录项（i-节点中的一个域记录着指向该文件的目录项），就会把该文件从磁盘中移除。</p>
<p>就像我们上面提到过的那样，<code>mount</code> 系统
<code>s = mount(special,name,flag)</code>
调用会将两个文件系统合并为一个。通常的情况是将根文件系统分布在硬盘（子）分区上，并将用户文件分布在另一个（子）分区上，该根文件系统包含常用命令的二进制（可执行）版本和其他使用频繁的文件。然后，用户就会插入可读取的
USB 硬盘。</p>
<p>通过执行 mount 系统调用，USB 文件系统可以被添加到根文件系统中，</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4V7d3Q"><img
src="https://z3.ax1x.com/2021/09/15/4V7d3Q.png"
alt="4V7d3Q.png" /></a></p>
<p>如果用 C 语言来执行那就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount(&quot;/dev/sdb0&quot;,&quot;/mnt&quot;,0)</span><br></pre></td></tr></table></figure>
<p>这里，第一个参数是 USB 驱动器 0
的块特殊文件名称，第二个参数是被安装在树中的位置，第三个参数说明将要安装的文件系统是可读写的还是只读的。</p>
<p>当不再需要一个文件系统时，可以使用 umount 移除之。</p>
<h3 id="其他系统调用">其他系统调用</h3>
<p>除了进程、文件、目录系统调用，也存在其他系统调用的情况，下面我们来探讨一下。我们可以看到上面其他系统调用只有四种，首先来看第一个
chdir，chdir 调用更改当前工作目录，在调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(&quot;/usr/ast/test&quot;);</span><br></pre></td></tr></table></figure>
<p>后，打开 xyz 文件，会打开 /usr/ast/test/xyz
文件，工作目录的概念消除了总是需要输入长文件名的需要。</p>
<p>在 UNIX
系统中，每个文件都会有保护模式，这个模式会有一个读-写-执行位，它用来区分所有者、组和其他成员。chmod
系统调用提供改变文件模式的操作。例如，要使一个文件除了对所有者之外的用户可读，你可以执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod(&quot;file&quot;,0644);	</span><br></pre></td></tr></table></figure>
<p>kill
系统调用是用户和用户进程发送信号的方式，如果一个进程准备好捕捉一个特定的信号，那么在信号捕捉之前，会运行一个信号处理程序。如果进程没有准备好捕捉特定的信号，那么信号的到来会杀掉该进程（此名字的由来）。</p>
<p>POSIX 定义了若干时间处理的进程。例如，time 以秒为单位返回当前时间，0
对应着 1970 年 1月 1日。在一台 32 位字的计算机中，time 的最大值是 (2^32)
- 1秒，这个数字对应 136 年多一点。所以在 2106 年，32 位的 UNIX
系统会发飙。如果读者现在有 32 位 UNIX 系统，建议在 2106 年更换位 64
位操作系统。</p>
<h3 id="win32-api">Win32 API</h3>
<p>上面我们提到的都是 UNIX 系统调用，现在我们来聊聊 Win 32
中的系统调用。Windows 和 UNIX 在各自的编程方式上有着根本的不同。UNIX
程序由执行某些操作或执行其他操作的代码组成，进行系统调用以执行某些服务。Windows
系统则不同，Windows
应用程序通常是由事件驱动的。主程序会等待一些事件发生，然后调用程序去处理。最简单的事件处理是键盘敲击和鼠标滑过，或者是鼠标点击，或者是插入
USB
驱动，然后操作系统调用处理器去处理事件，更新屏幕和更新程序内部状态。这是与
UNIX 不同的设计风格。</p>
<p>当然，Windows 也有系统调用。在 UNIX 中，系统调用（比如
read）和系统调用所使用的调用库（例如 read）几乎是一对一的关系。而在
Windows
中，情况则大不相同。首先，函数库的调用和实际的系统调用几乎是不对应的。微软定义了一系列过程，称为
<code>Win32应用编程接口(Application Programming Interface)</code>，程序员通过这套标准的接口来实现系统调用。这个接口支持从
Windows 95 版本以来所有的 Windows 版本。</p>
<p>Win32 API
调用的数量是非常巨大的，有数千个多。但这些调用并不都是在内核态的模式下运行时，有一些是在用户态的模型下运行。Win32
API
有大量的调用，用来管理视窗、几何图形、文本、字体、滚动条、对话框、菜单以及
GUI
的其他功能。为了使图形子系统在内核态下运行，需要系统调用，否则就只有函数库调用。</p>
<p>我们把关注点放在和 Win32 系统调用中来，我们可以简单看一下 Win32 API
中的系统调用和 UNIX 中有什么不同（并不是所有的系统调用）</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4dA0SK"><img
src="https://z3.ax1x.com/2021/09/23/4dA0SK.png"
alt="4dA0SK.png" /></a></p>
<p>上表中是 UNIX 调用大致对应的 Win32 API
系统调用，简述一下上表。<code>CreateProcess</code>
用于创建一个新进程，它把 UNIX 中的 fork 和 execve
两个指令合成一个，一起执行。它有许多参数用来指定新创建进程的性质。Windows
中没有类似 UNIX
中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。<code>WaitForSingleObject</code>
用于等待一个事件，等待的事件可以是多种可能的事件。如果有参数指定了某个进程，那么调用者将等待指定的进程退出，这通过
<code>ExitProcess</code> 来完成。</p>
<p>然后是6个文件操作，在功能上和 UNIX
的调用类似，然而在参数和细节上是不同的。和 UNIX
中一样，文件可以打开，读取，写入，关闭。SetFilePointer 和
GetFileAttributesEx 设置文件的位置并取得文件的属性。</p>
<p>Windows 中有目录，目录分别用 CreateDirectory 以及 RemoveDirectory API
调用创建和删除。也有对当前的目录的标记，这可以通过 SetCurrentDirectory
来设置。使用GetLocalTime 可获得当前时间。</p>
<p>Win32 接口中没有文件的链接、文件系统的 mount、umount 和 stat ，当然，
Win32 中也有大量 UNIX 中没有的系统调用，特别是对 GUI 的管理和调用。</p>
<h2 id="操作系统结构">操作系统结构</h2>
<p>下面我们会探讨操作系统的几种结构，主要包括单体结构、分层系统、微内核、客户-服务端系统、虚拟机和外核等。下面以此来探讨一下</p>
<h3 id="单体系统">单体系统</h3>
<p>到目前为止，在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序。使用此技术时，如果系统中的每个过程都提供了前者所需的一些有用的计算，则它可以自由调用任何其他过程。在单体系统中，调用任何一个所需要的程序都非常高效，但是上千个不受限制的彼此调用往往非常臃肿和笨拙，而且单体系统必然存在单体问题，那就是只要系统发生故障，那么任何系统和应用程序将不可用，这往往是灾难性的。</p>
<p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中。</p>
<p>对于单体系统，往往有下面几种建议</p>
<ul>
<li><p>需要有一个主程序，用来调用请求服务程序</p></li>
<li><p>需要一套服务过程，用来执行系统调用</p></li>
<li><p>需要一套服务程序，用来辅助服务过程调用</p></li>
</ul>
<p>在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4VjvJx"><img
src="https://z3.ax1x.com/2021/09/15/4VjvJx.png"
alt="4VjvJx.png" /></a></p>
<p>除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如
I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做
<strong>共享库(shared library)</strong> ，在 Windows 中则被称为
<strong>动态链接库(Dynamic Link Library,DLL)</strong> 。他们的扩展名为
<code>.dll</code>，在<code>C:\Windows\system32</code> 目录下存在 1000
多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。</p>
<h3 id="分层系统">分层系统</h3>
<p>分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4VvNlT"><img
src="https://z3.ax1x.com/2021/09/15/4VvNlT.png"
alt="4VvNlT.png" /></a></p>
<p>把上面单体系统进一步通用化，就变为了一个层次式结构的操作系统，它的上层软件都是在下层软件的基础之上构建的。该系统分为六层，如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">层号</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">操作员</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">用户程序</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">输入/输出管理</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">操作员-进程通信</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">存储器和磁鼓管理</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">处理器分配和多道程序编程</td>
</tr>
</tbody>
</table>
<p>处理器在 0 层运行，当中断发生或定时器到期时，由该层完成进程切换；在第
0
层之上，系统由一些连续的进程组成，编写这些进程时不用再考虑在单处理器上多进程运行的细节。内存管理在第
1 层，它分配进程的主存空间。第 1
层软件保证一旦需要访问某一页面，该页面必定已经在内存中，并且在页面不需要的时候将其移出。</p>
<p>第 2 层处理进程与操作员控制台（即用户）之间的通信。第 3 层管理 I/O
设备和相关的信息流缓冲区。第 4
层是用户程序层，用户程序不用考虑进程、内存、控制台或 I/O
设备管理等细节。系统操作员在第 5 层。</p>
<h3 id="微内核">微内核</h3>
<p>在分层方式中，设计者要确定在哪里划分 <strong>内核-用户</strong>
的边界。传统上，所有的层都在内核中，但是这样做没有必要。事实上，尽可能减少内核态中功能可能是更好的做法。因为内核中的错误很难处理，一旦内核态中出错误会拖累整个系统。</p>
<p>所以，为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块
--- 微内核 ---
运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。</p>
<p><code>MINIX 3</code> 是微内核的代表作，它的具体结构如下</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4VzxWq"><img
src="https://z3.ax1x.com/2021/09/15/4VzxWq.png"
alt="4VzxWq.png" /></a></p>
<p>在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问
I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O
设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O
端口，并声称一个内核调用，这样就完成了一次调用过程。</p>
<p>位于用户态的驱动程序上面是<strong>服务器层</strong>
，包含有服务器，它们完成操作系统的多数工作。由一个或多个文件服务器管理着文件系统，进程管理器创建、销毁和管理进程。服务器中有一个特殊的服务器称为
<strong>再生服务器(reincarnation server)</strong>
，它的任务就是检查服务器和驱动程序的功能是否正确，一旦检查出来错误，它就会补上去，无需用户干预。这种方式使得系统具有可恢复性，并具有较高的可靠性。</p>
<p>微内核中的内核还具有一种<code>机制与策略分离</code>的思想。比如系统调度，一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行具有最高优先级的进程。这里，内核机制就是寻找最高的优先级进程并运行。而策略（赋予进程优先级）可以在用户态中的进程完成。在这种模式中，策略和机制是分离的，从而使内核变得更小。</p>
<h3 id="客户-服务器模式">客户-服务器模式</h3>
<p>微内核思想的策略是把进程划分为两类：<code>服务器</code>，每个服务器用来提供服务；<code>客户端</code>，使用这些服务。这个模式就是所谓的
<code>客户-服务器</code>模式。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4ZFmpd"><img
src="https://z3.ax1x.com/2021/09/15/4ZFmpd.png"
alt="4ZFmpd.png" /></a></p>
<p>客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。</p>
<p>越来越多的系统，包括家里的
PC，都成为客户端，而在某地运行的大型机器则成为服务器。许多 web
就是以这种方式运行的。一台 PC 向某个服务器请求一个 Web 页面，服务器把
Web 页面返回给客户端，这就是典型的客服-服务器模式。</p>
<h1 id="进程和线程">进程和线程</h1>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4dgDmt"><img
src="https://z3.ax1x.com/2021/09/23/4dgDmt.png"
alt="4dgDmt.png" /></a></p>
<h2 id="进程-1">进程</h2>
<p>操作系统中最核心的概念就是 <strong>进程</strong>
，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。进程是操作系统提供的最古老也是最重要的概念之一。即使可以使用的
CPU 只有一个，它们也支持 <strong>（伪）并发操作</strong>
。它们会将一个单独的 CPU 抽象为多个虚拟机的
CPU。可以说：没有进程的抽象，现代操作系统将不复存在。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4dX2yq"><img
src="https://z3.ax1x.com/2021/09/23/4dX2yq.png"
alt="4dX2yq.png" /></a></p>
<p>所有现代的计算机会在同一时刻做很多事情，过去使用计算机的人（单
CPU）可能完全无法理解现在这种变化，举个例子更能说明这一点：首先考虑一个
Web 服务器，请求都来自于 Web
网页。当一个请求到达时，服务器会检查当前页是否在缓存中，如果是在缓存中，就直接把缓存中的内容返回。如果缓存中没有的话，那么请求就会交给磁盘来处理。但是，从
CPU
的角度来看，磁盘请求需要更长的时间，因为磁盘请求会很慢。当硬盘请求完成时，更多其他请求才会进入。如果有多个磁盘的话，可以在第一个请求完成前就可以连续的对其他磁盘发出部分或全部请求。很显然，这是一种并发现象，需要有并发控制条件来控制并发现象。</p>
<p>现在考虑只有一个用户的
PC。当系统启动时，许多进程也在后台启动，用户通常不知道这些进程的启动，试想一下，当你自己的计算机启动的时候，你能知道哪些进程是需要启动的么？这些后台进程可能是一个需要输入电子邮件的电子邮件进程，或者是一个计算机病毒查杀进程来周期性的更新病毒库。某个用户进程可能会在所有用户上网的时候打印文件以及刻录
CD-ROM，这些活动都需要管理。于是一个支持多进程的多道程序系统就会显得很有必要了。</p>
<p>在许多多道程序系统中，CPU
会在<strong>进程间</strong>快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU
只能运行一个进程，然而我们如果把时间定位为 1
秒内的话，它可能运行多个进程。这样就会让我们产生<strong>并行</strong>的错觉。有时候人们说的
<strong>伪并行(pseudoparallelism)</strong>
就是这种情况，以此来区分多处理器系统(该系统由两个或多个 CPU
来共享同一个物理内存)。</p>
<blockquote>
<p>再来详细解释一下伪并行：<strong>伪并行</strong>是指单核或多核处理器同时执行多个进程，从而使程序更快。通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感。缺点是
CPU 时间可能分配给下一个进程，也可能不分配给下一个进程。</p>
</blockquote>
<p>因为 CPU
执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪，所以，在经过多年的努力后，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析，对该模型的探讨，也是本篇文章的主题。下面我们就来探讨一下进程模型</p>
<h3 id="进程模块">进程模块</h3>
<p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干<strong>顺序进程(sequential
processes)</strong> ，简称为 <strong>进程(process)</strong>
。一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟
CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4wK178"><img
src="https://z3.ax1x.com/2021/09/23/4wK178.png"
alt="4wK178.png" /></a></p>
<p>如上图所示，这是一个具有 4
个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4wKUcn"><img
src="https://z3.ax1x.com/2021/09/23/4wKUcn.png"
alt="4wKUcn.png" /></a></p>
<p>在上图中，这 4 道程序被抽象为 4
个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>
<p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，<strong>但在任何一个给定的瞬间仅有一个进程真正运行</strong>
。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4wKRj1"><img
src="https://z3.ax1x.com/2021/09/23/4wKRj1.png"
alt="4wKRj1.png" /></a></p>
<p>因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2
个核（或 CPU），<strong>每一个核也只能一次运行一个线程</strong> 。</p>
<p>由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU
中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU
内部的运行时间往往也是不固定的。进程和程序之间的区别是非常微妙的，但是通过一个例子可以让你加以区分：想想一位会做饭的计算机科学家正在为他的女儿制作生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中，做蛋糕的食谱就是程序、计算机科学家就是
CPU、而做蛋糕的各种原料都是输入数据。进程就是科学家阅读食谱、取来各种原料以及烘焙蛋糕等一系列动作的总和。</p>
<p>现在假设科学家的儿子跑过来告诉他，说他的头被蜜蜂蜇了一下，那么此时科学家会记录出来他做蛋糕这个过程到了哪一步，然后拿出急救手册，按照上面的步骤给他儿子实施救助。这里，会涉及到进程之间的切换，科学家（CPU）会从做蛋糕（进程）切换到实施医疗救助（另一个进程）。等待伤口处理完毕后，科学家会回到刚刚记录做蛋糕的那一步，继续制作。</p>
<p>这里的关键思想是认识到一个进程所需的条件，<strong>进程是某一类特定活动的总和，它有程序、输入输出以及状态</strong>
。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。另外需要注意的是，如果一个进程运行了两遍，则被认为是两个进程。那么我们了解到进程模型后，那么进程是如何创建的呢？</p>
<h3 id="进程创建">进程创建</h3>
<p>操作系统需要一些方式来创建进程。下面是一些创建进程的方式</p>
<ul>
<li><p>系统初始化（init）</p></li>
<li><p>正在运行的程序执行了创建进程的系统调用（比如 fork）</p></li>
<li><p>用户请求创建一个新进程</p></li>
<li><p>初始化一个批处理工作</p></li>
</ul>
<h4 id="系统初始化">系统初始化</h4>
<p>启动操作系统时，通常会创建若干个进程。其中有些是<strong>前台进程(numerous
processes)</strong>
，也就是同用户进行交互并替他们完成工作的进程。一些运行在后台，并不与特定的用户进行交互，例如，设计一个进程来接收发来的电子邮件，这个进程大部分的时间都在休眠，但是只要邮件到来后这个进程就会被唤醒。还可以设计一个进程来接收对该计算机上网页的传入请求，在请求到达的进程唤醒来处理网页的传入请求。进程运行在后台用来处理一些活动像是
e-mail，web 网页，新闻，打印等等被称为
<strong>守护进程(daemons)</strong> 。大型系统会有很多守护进程。在 UNIX
中，<strong>ps</strong> 程序可以列出正在运行的进程， 在 Windows
中，可以使用任务管理器。</p>
<h4 id="系统调用创建">系统调用创建</h4>
<p>除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常，一个正在运行的进程会发出<strong>系统调用</strong>用来创建一个或多个新进程来帮助其完成工作。例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的
CPU 上也可以使工作做的更快。</p>
<h4 id="用户请求创建">用户请求创建</h4>
<p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的
UNIX 系统中运行 X，新进程将接管启动它的窗口。在 Windows
中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p>
<blockquote>
<p>交互式系统是以人与计算机之间大量交互为特征的计算机系统，比如游戏、web浏览器，IDE
等集成开发环境。</p>
</blockquote>
<h4 id="批处理创建">批处理创建</h4>
<p>最后一种创建进程的情形会在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p>
<p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</p>
<p>在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是
<code>fork</code> 。这个调用会创建一个与调用进程相关的副本。在 fork
后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。通常，子进程会执行
<code>execve</code>
或者一个简单的系统调用来改变内存映像并运行一个新的程序。例如，当一个用户在
shell 中输出 sort 命令时，shell 会 fork 一个子进程然后子进程去执行 sort
命令。这两步过程的原因是允许子进程在 fork 之后但在 execve
之前操作其文件描述符，以完成标准输入，标准输出和标准错误的重定向。</p>
<p>在 Windows 中，情况正相反，一个简单的 Win32 功能调用
<code>CreateProcess</code>，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有
10
个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。除了
CreateProcess Win 32 中大概有 100
个其他的函数用于处理进程的管理，同步以及相关的事务。下面是 UNIX
操作系统和 Windows 操作系统系统调用的对比</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4wrDQ1"><img
src="https://z3.ax1x.com/2021/09/23/4wrDQ1.png"
alt="4wrDQ1.png" /></a></p>
<p><strong>在 UNIX 和 Windows
中，进程创建之后，父进程和子进程有各自不同的地址空间</strong>
。如果其中某个进程在其地址空间中修改了一个词，这个修改将对另一个进程不可见。在
UNIX
中，子进程的地址空间是父进程的一个拷贝，但是却是两个不同的地址空间；不可写的内存区域是共享的。某些
UNIX
实现是正是在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但是这种情况下内存通过
<code>写时复制(copy-on-write) 共享</code>，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。再次强调，<strong>可写的内存是不能被共享的</strong>
。但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。<strong>在
Windows
中，从一开始父进程的地址空间和子进程的地址空间就是不同的</strong> 。</p>
<h3 id="进程的终止">进程的终止</h3>
<p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p>
<ul>
<li><p>正常退出(自愿的)</p></li>
<li><p>错误退出(自愿的)</p></li>
<li><p>严重错误(非自愿的)</p></li>
<li><p>被其他进程杀死(非自愿的)</p></li>
</ul>
<h4 id="正常退出">正常退出</h4>
<p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在
UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>
。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet
浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。</p>
<h4 id="错误退出">错误退出</h4>
<p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.c    </span><br></pre></td></tr></table></figure>
<p>为了能够编译 <code>foo.c</code>
但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<h4 id="严重错误">严重错误</h4>
<p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是
0 等。在有些系统比如 UNIX
中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<h4 id="被其他进程杀死">被其他进程杀死</h4>
<p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在
UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是
TerminateProcess（注意不是系统调用）。</p>
<h3 id="进程的层次结构">进程的层次结构</h3>
<p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p>
<h4 id="unix-进程体系">UNIX 进程体系</h4>
<p>在 UNIX
中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号
kill 掉。</p>
<p>这里有另一个例子，可以用来说明层次的作用，考虑 UNIX
在启动时如何初始化自己。一个称为 init 的特殊进程出现在启动映像中。当
init
进程开始运行时，它会读取一个文件，文件会告诉它有多少个终端。然后为每个终端创建一个新进程。这些进程等待用户登录。如果登录成功，该登录进程就执行一个
shell
来等待接收用户输入指令，这些命令可能会启动更多的进程，以此类推。因此，整个操作系统中所有的进程都隶属于一个单个以
init 为根的进程树。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4wjfQs"><img
src="https://z3.ax1x.com/2021/09/23/4wjfQs.png"
alt="4wjfQs.png" /></a></p>
<h4 id="windows-进程体系">Windows 进程体系</h4>
<p>相反，Windows 中没有进程层次的概念，Windows
中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在
UNIX 中，进程不能剥夺其子进程的进程权。（这样看来，还是 Windows
比较渣）。</p>
<h3 id="进程状态">进程状态</h3>
<p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在
shell 命令中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure>
<p>第一个进程是 <code>cat</code> ，将三个文件级联并输出。第二个进程是
<code>grep</code> ，它从输入中选择具有包含关键字 tree
的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的
CPU 时间片），可能会发生下面这种情况，<code>grep</code>
准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞 <code>grep</code>
进程，直到输入完毕。</p>
<p>当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4wxJ8e"><img
src="https://z3.ax1x.com/2021/09/23/4wxJ8e.png"
alt="4wxJ8e.png" /></a></p>
<p>图中会涉及三种状态</p>
<ol type="1">
<li><p><strong>运行态</strong> ，运行态指的就是进程实际占用 CPU
时间片运行时</p></li>
<li><p><strong>就绪态</strong>
，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</p></li>
<li><p><strong>阻塞态</strong>
，除非某种外部事件发生，否则进程不能运行</p></li>
</ol>
<p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示<code>进程可运行</code>，但是第二种情况没有获得
CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU
空闲时也不能运行。</p>
<p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生状态1的轮转，在某些系统中进程执行系统调用，例如
<code>pause</code> ，来获取一个阻塞的状态。在其他系统中包括
UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。</p>
<p>转换 2 和转换 3
都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换
2
的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行
CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得
CPU 时间片的时候了，就会发生转换 3。</p>
<blockquote>
<p><strong>程序调度指的是，决定哪个进程优先被运行和运行多久</strong>，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p>
</blockquote>
<p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换
4。如果此时没有其他进程在运行，则立刻触发转换
3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU
空闲后再轮到它运行。</p>
<p>从上面的观点引入了下面的模型</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4wzHFf"><img
src="https://z3.ax1x.com/2021/09/23/4wzHFf.png"
alt="4wzHFf.png" /></a></p>
<p><strong>操作系统最底层的就是调度程序</strong>，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。事实上，调度程序只是一段非常小的程序。</p>
<h3 id="进程的实现">进程的实现</h3>
<p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是
<strong>进程表(process table)</strong>
。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p>
<p>下面展示了一个典型系统中的关键字段</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/40SVX9"><img
src="https://z3.ax1x.com/2021/09/23/40SVX9.png"
alt="40SVX9.png" /></a></p>
<p>第一列内容与<strong>进程管理</strong>有关，第二列内容与<strong>存储管理</strong>有关，第三列内容与<strong>文件管理</strong>有关。</p>
<p>现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU
上如何运行多个顺序进程的错觉做更多的解释。与每一I/O 类相关联的是一个称作
<strong>中断向量(interrupt vector)</strong>
的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程
3
正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</p>
<p>当中断结束后，操作系统会调用一个 C
程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</p>
<ol type="1">
<li><p>硬件压入堆栈程序计数器等</p></li>
<li><p>硬件从中断向量装入新的程序计数器</p></li>
<li><p>汇编语言过程保存寄存器的值</p></li>
<li><p>汇编语言过程设置新的堆栈</p></li>
<li><p>C 中断服务器运行（典型的读和缓存写入）</p></li>
<li><p>调度器决定下面哪个程序先运行</p></li>
<li><p>C 过程返回至汇编代码</p></li>
<li><p>汇编语言过程开始运行新的当前进程</p></li>
</ol>
<p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p>
<h2 id="线程">线程</h2>
<p>在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</p>
<h3 id="线程的使用">线程的使用</h3>
<p>或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</p>
<ul>
<li><p>多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</p></li>
<li><p>线程要比进程更轻量级，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快
10 - 100 倍。</p></li>
<li><p>第三个原因可能是性能方面的探讨，如果多个线程都是 CPU
密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的
I/O
处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</p></li>
</ul>
<h4 id="多线程解决方案">多线程解决方案</h4>
<p>现在考虑一个线程使用的例子：一个万维网服务器，对页面的请求发送给服务器，而所请求的页面发送回客户端。在多数
web
站点上，某些页面较其他页面相比有更多的访问。例如，索尼的主页比任何一个照相机详情介绍页面具有更多的访问，Web
服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，从而改善性能。这种页面的集合称为
<strong>高速缓存(cache)</strong> ，高速缓存也应用在许多场合中，比如说
CPU 缓存。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/40MqhD"><img
src="https://z3.ax1x.com/2021/09/23/40MqhD.png"
alt="40MqhD.png" /></a></p>
<p>上面是一个 web 服务器的组织方式，一个叫做 <strong>调度线程(dispatcher
thread)</strong>
的线程从网络中读入工作请求，在调度线程检查完请求后，它会选择一个空闲的（阻塞的）工作线程来处理请求，通常是将消息的指针写入到每个线程关联的特殊字中。然后调度线程会唤醒正在睡眠中的工作线程，把工作线程的状态从阻塞态变为就绪态。</p>
<p>当工作线程启动后，它会检查请求是否在 web
页面的高速缓存中存在，这个高速缓存是所有线程都可以访问的。如果高速缓存不存在这个
web 页面的话，它会调用一个 read
操作从磁盘中获取页面并且阻塞线程直到磁盘操作完成。当线程阻塞在硬盘操作的期间，为了完成更多的工作，调度线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。</p>
<p>这种模型允许将服务器编写为顺序线程的集合，在分派线程的程序中包含一个死循环，该循环用来获得工作请求并且把请求派给工作线程。每个工作线程的代码包含一个从调度线程接收的请求，并且检查
web
高速缓存中是否存在所需页面，如果有，直接把该页面返回给客户，接着工作线程阻塞，等待一个新请求的到达。如果没有，工作线程就从磁盘调入该页面，将该页面返回给客户机，然后工作线程阻塞，等待一个新请求。</p>
<p>下面是调度线程和工作线程的代码，这里假设 TRUE 为常数 1 ，buf 和 page
分别是保存工作请求和 Web 页面的相应结构。</p>
<p><strong>调度线程的大致逻辑</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="built_in">get_next_request</span>(&amp;buf);</span><br><span class="line">  <span class="built_in">handoff_work</span>(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工作线程的大致逻辑</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="built_in">wait_for_work</span>(&amp;buf);</span><br><span class="line">  <span class="built_in">look_for_page_in_cache</span>(&amp;buf,&amp;page);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">page_not_in_cache</span>(&amp;page))&#123;</span><br><span class="line">    <span class="built_in">read_page_from_disk</span>(&amp;buf,&amp;page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _page(&amp;page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单线程解决方案">单线程解决方案</h4>
<p>现在考虑没有多线程的情况下，如何编写 Web
服务器。我们很容易的就想象为单个线程了，Web
服务器的主循环获取请求并检查请求，并争取在下一个请求之前完成工作。在等待磁盘操作时，服务器空转，并且不处理任何到来的其他请求。结果会导致每秒中只有很少的请求被处理，所以这个例子能够说明多线程提高了程序的并行性并提高了程序的性能。</p>
<h4 id="状态机解决方案">状态机解决方案</h4>
<p>到现在为止，我们已经有了两种解决方案，单线程解决方案和多线程解决方案，其实还有一种解决方案就是
<strong>状态机解决方案</strong> ，它的流程如下</p>
<p>如果目前只有一个非阻塞版本的 read
系统调用可以使用，那么当请求到达服务器时，这个唯一的 read
调用的线程会进行检查，如果能够从高速缓存中得到响应，那么直接返回，如果不能，则启动一个非阻塞的磁盘操作。</p>
<p>服务器在表中记录当前请求的状态，然后进入并获取下一个事件，紧接着下一个事件可能就是一个新工作的请求或是磁盘对先前操作的回答。如果是新工作的请求，那么就开始处理请求。如果是磁盘的响应，就从表中取出对应的状态信息进行处理。对于非阻塞式磁盘
I/O 而言，这种响应一般都是信号中断响应。</p>
<p>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显示的保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为<strong>有限状态机(finite-state
machine)</strong> ，有限状态机被广泛的应用在计算机科学中。</p>
<p>这三种解决方案各有各的特性，多线程使得顺序进程的思想得以保留下来，并且实现了并行性，但是顺序进程会阻塞系统调用；单线程服务器保留了阻塞系统的简易性，但是却放弃了性能。有限状态机的处理方法运用了非阻塞调用和中断，通过并行实现了高性能，但是给编程增加了困难。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BVBAe"><img
src="https://z3.ax1x.com/2021/09/24/4BVBAe.png"
alt="4BVBAe.png" /></a></p>
<h3 id="经典的线程模型">经典的线程模型</h3>
<p>理解进程的另一个角度是，用某种方法把相关的资源集中在一起。进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把这些信息放在进程中会比较容易管理。</p>
<p>另一个概念是，进程中拥有一个执行的线程，通常简写为
<strong>线程(thread)</strong>
。线程会有程序计数器，用来记录接着要执行哪一条指令；线程还拥有寄存器，用来保存线程当前正在使用的变量；线程还会有堆栈，用来记录程序的执行路径。尽管线程必须在某个进程中执行，但是进程和线程完完全全是两个不同的概念，并且他们可以分开处理。进程用于把资源集中在一起，而线程则是
CPU 上调度执行的实体。</p>
<p>线程给进程模型增加了一项内容，即在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。在多个线程中，各个线程共享同一地址空间和其他资源。在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为轻量的进程(lightweight
processes)。<strong>多线程(multithreading)</strong>
一词还用于描述在同一进程中多个线程的情况。</p>
<p>下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BUnjf"><img
src="https://z3.ax1x.com/2021/09/24/4BUnjf.png"
alt="4BUnjf.png" /></a></p>
<p>下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BaeIJ"><img
src="https://z3.ax1x.com/2021/09/24/4BaeIJ.png"
alt="4BaeIJ.png" /></a></p>
<p>线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，因此<strong>一个线程可以读取、写入甚至擦除另一个线程的堆栈</strong>
。线程之间除了共享同一内存空间外，还具有如下不同的内容</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BahQ0"><img
src="https://z3.ax1x.com/2021/09/24/4BahQ0.png"
alt="4BahQ0.png" /></a></p>
<p>上图左边的是同一个进程中<strong>每个线程共享</strong>的内容，上图右边是<strong>每个线程</strong>中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</p>
<p>和进程一样，线程可以处于下面这几种状态：<strong>运行中、阻塞、就绪和终止</strong>（进程图中没有画）。正在运行的线程拥有
CPU
时间片并且状态是运行中。一个被阻塞的线程会等待某个释放它的事件。例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。<strong>线程之间的状态转换和进程之间的状态转换是一样的</strong>
。</p>
<p>每个线程都会有自己的堆栈，如下图所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BdftH"><img
src="https://z3.ax1x.com/2021/09/24/4BdftH.png"
alt="4BdftH.png" /></a></p>
<h4 id="线程系统调用">线程系统调用</h4>
<p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如
<code>thread_create</code>）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</p>
<p>当一个线程完成工作后，可以通过调用一个函数（比如
<code>thread_exit</code>）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如
<code>thread_join</code>
，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p>
<p>另一个常见的线程是调用 <code>thread_yield</code> ，它允许线程自动放弃
CPU
从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出
CPU 的。</p>
<h3 id="posix-线程">POSIX 线程</h3>
<p>为了使编写可移植线程程序成为可能，IEEE 在 IEEE 标准 1003.1c
中定义了线程标准。线程包被定义为 <code>Pthreads</code> 。大部分的 UNIX
系统支持它。这个标准定义了 60
多种功能调用，一一列举不太现实，下面为你列举了一些常用的系统调用。</p>
<blockquote>
<p><strong>POSIX线程</strong>（通常称为<strong>pthreads</strong>）是一种独立于语言而存在的执行模型，以及并行执行模型。它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用POSIX
Threads API来实现对这些流程的创建和控制。可以把它理解为线程的标准。
POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如
FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris，它在现有
Windows API 之上实现了pthread。 IEEE
是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">线程调用</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">pthread_create</td>
<td style="text-align: center;">创建一个新线程</td>
</tr>
<tr class="even">
<td style="text-align: center;">pthread_exit</td>
<td style="text-align: center;">结束调用的线程</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pthread_join</td>
<td style="text-align: center;">等待一个特定的线程退出</td>
</tr>
<tr class="even">
<td style="text-align: center;">pthread_yield</td>
<td style="text-align: center;">释放 CPU 来运行另外一个线程</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pthread_attr_init</td>
<td style="text-align: center;">创建并初始化一个线程的属性结构</td>
</tr>
<tr class="even">
<td style="text-align: center;">pthread_attr_destory</td>
<td style="text-align: center;">删除一个线程的属性结构</td>
</tr>
</tbody>
</table>
<p>所有的 Pthreads
都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</p>
<p>新的线程会通过 <code>pthread_create</code>
创建，新创建的线程的标识符会作为函数值返回。这个调用非常像是 UNIX 中的
<code>fork</code> 系统调用（除了参数之外），其中线程标识符起着
<code>PID</code> 的作用，这么做的目的是为了和其他线程进行区分。</p>
<p>当线程完成指派给他的工作后，会通过 <code>pthread_exit</code>
来终止。这个调用会停止线程并释放堆栈。</p>
<p>一般一个线程在继续运行前需要等待另一个线程完成它的工作并退出。可以通过
<code>pthread_join</code>
线程调用来等待别的特定线程的终止。而要等待线程的线程标识符作为一个参数给出。</p>
<p>有时会出现这种情况：一个线程逻辑上没有阻塞，但感觉上它已经运行了足够长的时间并且希望给另外一个线程机会去运行。这时候可以通过
<code>pthread_yield</code> 来完成。</p>
<p>下面两个线程调用是处理属性的。<code>pthread_attr_init</code>
建立关联一个线程的属性结构并初始化成默认值，这些值（例如优先级）可以通过修改属性结构的值来改变。</p>
<p>最后，<code>pthread_attr_destroy</code>
删除一个线程的结构，释放它占用的内存。它不会影响调用它的线程，这些线程会一直存在。</p>
<p>为了更好的理解 <code>pthread</code>
是如何工作的，考虑下面这个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_OF_THREADS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">print_hello_world</span><span class="params">(<span class="type">void</span> *tid)</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 输出线程的标识符，然后退出 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World. Greetings from thread %d\n&quot;</span>,tid);</span><br><span class="line">  <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 主程序创建 10 个线程，然后退出 */</span></span><br><span class="line">  <span class="type">pthread_t</span> threads[NUMBER_OF_THREADS];</span><br><span class="line">  <span class="type">int</span> status,i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; NUMBER_OF_THREADS;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main here. Creating thread %d\n&quot;</span>,i);</span><br><span class="line">    status = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, print_hello_world, (<span class="type">void</span> *)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Oops. pthread_create returned error code %d\n&quot;</span>,status);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程在宣布它的指责之后，循环 <code>NUMBER_OF_THREADS</code>
次，每次创建一个新的线程。如果线程创建失败，会打印出一条信息后退出。在创建完成所有的工作后，主程序退出。</p>
<h3 id="线程实现">线程实现</h3>
<p>主要有三种实现方式</p>
<ul>
<li><p>在用户空间中实现线程；</p></li>
<li><p>在内核空间中实现线程；</p></li>
<li><p>在用户和内核空间中混合实现线程。</p></li>
</ul>
<p>下面我们分开讨论一下</p>
<h4 id="在用户空间中实现线程">在用户空间中实现线程</h4>
<p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4Bsscd"><img
src="https://z3.ax1x.com/2021/09/24/4Bsscd.png"
alt="4Bsscd.png" /></a></p>
<p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程：<strong>pthread_create,
pthread_exit, pthread_join 和 pthread_yield</strong> 。</p>
<blockquote>
<p><strong>运行时系统(Runtime System)</strong>
也叫做运行时环境，该运行时系统提供了程序在其中运行的环境。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。</p>
</blockquote>
<p>在用户空间管理线程时，每个进程需要有其专用的<strong>线程表(thread
table)</strong>
，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态。该线程表由运行时系统统一管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程的所有信息，与内核在进程表中存放的信息完全一样。</p>
<blockquote>
<p><strong>在用户空间实现线程的优势</strong></p>
</blockquote>
<p>在用户空间中实现线程要比在内核空间中实现线程具有这些方面的优势：考虑如果在线程完成时或者是在调用
<code>pthread_yield</code>
时，必要时会进程线程切换，然后线程的信息会被保存在运行时环境所提供的线程表中，然后，线程调度程序来选择另外一个需要运行的线程。保存线程的状态和调度程序都是<code>本地过程</code>
，<strong>所以启动他们比进行内核调用效率更高。因而不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高</strong>
。</p>
<p>在用户空间实现线程还有一个优势就是它<strong>允许每个进程有自己定制的调度算法</strong>
。例如在某些应用程序中，那些具有垃圾收集线程的应用程序（知道是谁了吧）就不用担心自己线程会不会在不合适的时候停止，这是一个优势。用户线程还具有较好的可扩展性，因为内核空间中的内核线程需要一些表空间和堆栈空间，如果内核线程数量比较大，容易造成问题。</p>
<blockquote>
<p><strong>在用户空间实现线程的劣势</strong></p>
</blockquote>
<p>尽管在用户空间实现线程会具有一定的性能优势，但是劣势还是很明显的，你如何实现<strong>阻塞系统调用</strong>呢？假设在还没有任何键盘输入之前，一个线程读取键盘，让线程进行系统调用是不可能的，因为这会停止所有的线程。所以，<strong>使用线程的一个目标是能够让线程进行阻塞调用，并且要避免被阻塞的线程影响其他线程</strong>
。</p>
<p>与阻塞调用类似的问题是<strong>缺页中断</strong>问题，实际上，计算机并不会把所有的程序都一次性的放入内存中，如果某个程序发生函数调用或者跳转指令到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，这就称为<strong>缺页故障</strong>
。而在对所需的指令进行读入和执行时，相关的进程就会被阻塞。如果只有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘
I/O 完成为止，尽管其他的线程是可以运行的。</p>
<p>另外一个问题是，如果一个线程开始运行，该线程所在进程中的其他线程都不能运行，除非第一个线程自愿的放弃
CPU，在一个单进程内部，没有时钟中断，所以不可能使用轮转调度的方式调度线程。除非其他线程能够以自己的意愿进入运行时环境，否则调度程序没有可以调度线程的机会。</p>
<h4 id="在内核中实现线程">在内核中实现线程</h4>
<p>现在我们考虑使用内核来实现线程的情况，此时不再需要运行时环境了。另外，每个进程中也没有线程表。相反，在内核中会有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BWxds"><img
src="https://z3.ax1x.com/2021/09/24/4BWxds.png"
alt="4BWxds.png" /></a></p>
<p>内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</p>
<p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的
CPU 时间片（或者没有可运行的线程存在了）为止。</p>
<p>由于在内核中创建或者销毁线程的开销比较大，所以某些系统会采用可循环利用的方式来回收线程。当某个线程被销毁时，就把它标志为不可运行的状态，但是其内部结构没有受到影响。稍后，在必须创建一个新线程时，就会重新启用旧线程，把它标志为可用状态。</p>
<p>如果某个进程中的线程造成缺页故障后，内核很容易的就能检查出来是否有其他可运行的线程，如果有的话，在等待所需要的页面从磁盘读入时，就选择一个可运行的线程运行。这样做的缺点是系统调用的代价比较大，所以如果线程的操作（创建、终止）比较多，就会带来很大的开销。</p>
<h4 id="混合实现">混合实现</h4>
<p>结合用户空间和内核空间的优点，设计人员采用了一种<strong>内核级线程</strong>的方式，然后将用户级线程与某些或者全部内核线程多路复用起来。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BhVc8"><img
src="https://z3.ax1x.com/2021/09/24/4BhVc8.png"
alt="4BhVc8.png" /></a></p>
<p>在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p>
<h2 id="进程间通信">进程间通信</h2>
<p>进程是需要频繁的和其他进程进行交流的。例如，在一个 shell
管道中，第一个进程的输出必须传递给第二个进程，这样沿着管道进行下去。因此，进程之间如果需要通信的话，必须要使用一种良好的数据结构以至于不能被中断。下面我们会一起讨论有关
<strong>进程间通信(Inter Process Communication, IPC)</strong>
的问题。</p>
<p>关于进程间的通信，这里有三个问题:</p>
<ul>
<li><p>上面提到了第一个问题，那就是一个进程如何传递消息给其他进程。</p></li>
<li><p>第二个问题是如何确保两个或多个线程之间不会相互干扰。例如，两个航空公司都试图为不同的顾客抢购飞机上的最后一个座位。</p></li>
<li><p>第三个问题是数据的先后顺序的问题，如果进程 A 产生数据并且进程 B
打印数据。则进程 B 打印数据之前需要先等 A
产生数据后才能够进行打印。</p></li>
</ul>
<p>需要注意的是，这三个问题中的后面两个问题同样也适用于线程。</p>
<p>第一个问题在线程间比较好解决，因为它们共享一个地址空间，它们具有相同的运行时环境，可以想象你在用高级语言编写多线程代码的过程中，线程通信问题是不是比较容易解决？</p>
<p>另外两个问题也同样适用于线程，同样的问题可用同样的方法来解决。我们后面会慢慢讨论这三个问题，你现在脑子中大致有个印象即可。</p>
<h3 id="竞态条件">竞态条件</h3>
<p>在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共资源。公共资源可能在内存中也可能在一个共享文件。为了讲清楚进程间是如何通信的，这里我们举一个例子：一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的后台目录(spooler
directory)中。另一个进程 打印后台进程(printer daemon)
会定期的检查是否需要文件被打印，如果有的话，就打印并将该文件名从目录下删除。</p>
<p>假设我们的后台目录有非常多的 <code>槽位(slot)</code>，编号依次为
0，1，2，…，每个槽位存放一个文件名。同时假设有两个共享变量：<strong>out</strong>
，指向下一个需要打印的文件；<strong>in</strong>
，指向目录中下个空闲的槽位。可以把这两个文件保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻，0
至 3 号槽位空，4 号至 6 号槽位被占用。在同一时刻，进程 A 和 进程 B
都决定将一个文件排队打印，情况如下</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4B5Xpq"><img
src="https://z3.ax1x.com/2021/09/24/4B5Xpq.png"
alt="4B5Xpq.png" /></a></p>
<p>墨菲法则(Murphy)
中说过，任何可能出错的地方终将出错，这句话生效时，可能发生如下情况。</p>
<p>进程 A 读到 in 的值为 7，将 7 存在一个局部变量
<code>next_free_slot</code> 中。此时发生一次时钟中断，CPU 认为进程 A
已经运行了足够长的时间，决定切换到进程 B 。进程 B 也读取 in 的值，发现是
7，然后进程 B 将 7 写入到自己的局部变量 <code>next_free_slot</code>
中，在这一时刻两个进程都认为下一个可用槽位是 7 。</p>
<p>进程 B 现在继续运行，它会将打印文件名写入到 slot 7 中，然后把 in
的指针更改为 8 ，然后进程 B 离开去做其他的事情。</p>
<p>现在进程 A 开始恢复运行，由于进程 A 通过检查
<code>next_free_slot</code> 也发现 slot 7
的槽位是空的，于是将打印文件名存入 slot 7 中，然后把 in 的值更新为 8
，由于 slot 7 这个槽位中已经有进程 B 写入的值，所以进程 A
的打印文件名会把进程 B
的文件覆盖，由于打印机内部是无法发现是哪个进程更新的，它的功能比较局限，所以这时候进程
B
永远无法打印输出，类似这种情况，<strong>即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race
condition)</strong>
。调试竞态条件是一种非常困难的工作，因为绝大多数情况下程序运行良好，但在极少数的情况下会发生一些无法解释的奇怪现象。</p>
<h3 id="临界区">临界区</h3>
<p>不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>
。换句话说，我们需要一种
<code>互斥(mutual exclusion) 条件</code>，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。上面问题的纠结点在于，在进程
A 对共享变量的使用未结束之前进程 B
就使用它。在任何操作系统中，为了实现互斥操作而选用适当的原语是一个主要的设计问题，接下来我们会着重探讨一下。</p>
<p>避免竞争问题的条件可以用一种抽象的方式去描述。大部分时间，进程都会忙于内部计算和其他不会导致竞争条件的计算。然而，有时候进程会访问共享内存或文件，或者做一些能够导致竞态条件的操作。我们把对共享内存进行访问的程序片段称作
<code>临界区域(critical region)</code> 或
<code>临界区(critical section)</code>
。如果我们能够正确的操作，使两个不同进程不可能同时处于临界区，就能避免竞争条件，这也是从操作系统设计角度来进行的。</p>
<p>尽管上面这种设计避免了竞争条件，但是不能确保并发线程同时访问共享数据的正确性和高效性。一个好的解决方案，应该包含下面四种条件：</p>
<ol type="1">
<li><p>任何时候两个进程不能同时处于临界区</p></li>
<li><p>不应对 CPU 的速度和数量做任何假设</p></li>
<li><p>位于临界区外的进程不得阻塞其他进程</p></li>
<li><p>不能使任何进程无限等待进入临界区</p></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BHwLV"><img
src="https://z3.ax1x.com/2021/09/24/4BHwLV.png"
alt="4BHwLV.png" /></a></p>
<p>从抽象的角度来看，我们通常希望进程的行为如上图所示，在 t1 时刻，进程
A 进入临界区，在 t2 的时刻，进程 B 尝试进入临界区，因为此时进程 A
正在处于临界区中，所以进程 B 会阻塞直到 t3 时刻进程 A
离开临界区，此时进程 B 能够允许进入临界区。最后，在 t4 时刻，进程 B
离开临界区，系统恢复到没有进程的原始状态。</p>
<h3 id="忙等待互斥">忙等待互斥</h3>
<p>下面我们会继续探讨实现互斥的各种设计，在这些方案中，当一个进程正忙于更新其关键区域的共享内存时，没有其他进程会进入其关键区域，也不会造成影响。</p>
<h4 id="屏蔽中断">屏蔽中断</h4>
<p>在单处理器系统上，最简单的解决方案是<strong>让每个进程在进入临界区后立即屏蔽所有中断，并在离开临界区之前重新启用它们。</strong>
屏蔽中断后，时钟中断也会被屏蔽。CPU
只有发生时钟中断或其他中断时才会进行进程切换。这样，在屏蔽中断后 CPU
不会切换到其他进程。所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。</p>
<p>这个方案可行吗？进程进入临界区域是由谁决定的呢？不是用户进程吗？当进程进入临界区域后，用户进程关闭中断，如果经过一段较长时间后进程没有离开，那么中断不就一直启用不了，结果会如何？可能会造成整个系统的终止。而且如果是多处理器的话，屏蔽中断仅仅对执行
disable 指令的 CPU 有效。其他 CPU 仍将继续运行，并可以访问共享内存。</p>
<p>另一方面，对内核来说，当它在执行更新变量或列表的几条指令期间将中断屏蔽是很方便的。例如，如果多个进程处理就绪列表中的时候发生中断，则可能会发生竞态条件的出现。所以，屏蔽中断对于操作系统本身来说是一项很有用的技术，但是对于用户线程来说，屏蔽中断却不是一项通用的互斥机制。</p>
<h4 id="锁变量">锁变量</h4>
<p>作为第二种尝试，可以寻找一种软件层面解决方案。考虑有单个共享的（锁）变量，初始为值为
0 。当一个线程想要进入关键区域时，它首先会查看锁的值是否为 0
，如果锁的值是 0 ，进程会把它设置为 1
并让进程进入关键区域。如果锁的状态是 1，进程会等待直到锁变量的值变为 0
。因此，锁变量的值是 0 则意味着没有线程进入关键区域。如果是 1
则意味着有进程在关键区域内。我们对上图修改后，如下所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4Bqtuq"><img
src="https://z3.ax1x.com/2021/09/24/4Bqtuq.png"
alt="4Bqtuq.png" /></a></p>
<p>这种设计方式是否正确呢？是否存在纰漏呢？假设一个进程读出锁变量的值并发现它为
0 ，而恰好在它将其设置为 1 之前，另一个进程调度运行，读出锁的变量为0
，并将锁的变量设置为 1 。然后第一个线程运行，把锁变量的值再次设置为
1，此时，临界区域就会有两个进程在同时运行。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4BqOVf"><img
src="https://z3.ax1x.com/2021/09/24/4BqOVf.png"
alt="4BqOVf.png" /></a></p>
<p>也许有的读者可以这么认为，在进入前检查一次，在要离开的关键区域再检查一次不就解决了吗？实际上这种情况也是于事无补，因为在第二次检查期间其他线程仍有可能修改锁变量的值，换句话说，这种
set-before-check
不是一种<strong>原子性</strong>操作，所以同样还会发生竞争条件。</p>
<h4 id="严格轮询法">严格轮询法</h4>
<p>第三种互斥的方式先抛出来一段代码，这里的程序是用 C
语言编写，之所以采用 C 是因为操作系统普遍是用 C 来编写的（偶尔会用
C++），而基本不会使用 Java 、Modula3 或 Pascal 这样的语言，Java 中的
native 关键字底层也是 C 或 C++
编写的源码。对于编写操作系统而言，需要使用 C
语言这种强大、高效、可预知和有特性的语言，而对于 Java
，它是不可预知的，因为它在关键时刻会用完存储器，而在不合适的时候会调用垃圾回收机制回收内存。在
C 语言中，这种情况不会发生，C 语言中不会主动调用垃圾回收回收内存。</p>
<p><strong>进程 0 的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="keyword">while</span>(turn != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">/* 进入关键区域 */</span></span><br><span class="line">    <span class="built_in">critical_region</span>();</span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 离开关键区域 */</span></span><br><span class="line">    <span class="built_in">noncritical_region</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进程 1 的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="keyword">while</span>(turn != <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">critical_region</span>();</span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">noncritical_region</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，变量 turn，初始值为 0
，用于记录轮到那个进程进入临界区，并检查或更新共享内存。开始时，进程 0
检查 turn，发现其值为 0 ，于是进入临界区。进程 1 也发现其值为 0
，所以在一个等待循环中不停的测试 turn，看其值何时变为
1。连续检查一个变量直到某个值出现为止，这种方法称为
<strong>忙等待(busywaiting)</strong> 。由于这种方式浪费 CPU
时间，所以这种方式通常应该要避免。只有在有理由认为等待时间是非常短的情况下，才能够使用忙等待。用于忙等待的锁，称为
<strong>自旋锁(spinlock)</strong> 。</p>
<p>进程 0 离开临界区时，它将 turn 的值设置为 1，以便允许进程 1
进入其临界区。假设进程 1
很快便离开了临界区，则此时两个进程都处于临界区之外，turn 的值又被设置为
0 。现在进程 0 很快就执行完了整个循环，它退出临界区，并将 turn
的值设置为 1。此时，turn 的值为 1，两个进程都在其临界区外执行。</p>
<p>突然，进程 0
结束了非临界区的操作并返回到循环的开始。但是，这时它不能进入临界区，因为
turn 的当前值为 1，此时进程 1 还忙于非临界区的操作，进程 0 只能继续
while 循环，直到进程 1 把 turn 的值改为 0
。这说明，在一个进程比另一个进程执行速度慢了很多的情况下，轮流进入临界区并不是一个好的方法。</p>
<p>这种情况违反了前面的叙述 3 ，即
<strong>位于临界区外的进程不得阻塞其他进程</strong> ，进程 0
被一个临界区外的进程阻塞。由于违反了第三条，所以也不能作为一个好的方案。</p>
<h4 id="peterson-解法">Peterson 解法</h4>
<p>荷兰数学家 T.Dekker
通过将锁变量与警告变量相结合，最早提出了一个不需要严格轮换的软件互斥算法。</p>
<p>后来， G.L.Peterson 发现了一种简单很多的互斥算法，它的算法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N     2                                                    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="type">int</span> turn;                    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有值初始化为 0 (FALSE) */</span></span><br><span class="line"><span class="type">int</span> interested[N];                                            </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程是 0 或 1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enter_region</span><span class="params">(<span class="type">int</span> process)</span></span>&#123;                    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">  <span class="type">int</span> other;                                                        </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 另一个进程 */</span></span><br><span class="line">  other = <span class="number">1</span> - process;                </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 表示愿意进入临界区 */</span></span><br><span class="line">  interested[process] = TRUE;                        </span><br><span class="line">  turn = process;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 空循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(turn == process </span><br><span class="line">        &amp;&amp; interested[other] == <span class="literal">true</span>)&#123;&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leave_region</span><span class="params">(<span class="type">int</span> process)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">  interested[process] == FALSE;                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 0 或
1 作为参数来调用 <code>enter_region</code>
，这个函数调用在需要时将使进程等待，直到能够安全的进入临界区。在完成对共享变量的操作之后，进程将调用
<code>leave_region</code> 表示操作完成，并且允许其他进程进入。</p>
<p>现在来看看这个办法是如何工作的。一开始，没有任何进程处于临界区中，现在进程
0 调用 <code>enter_region</code> 。它通过设置数组元素和将 turn 置为 0
来表示它希望进入临界区。由于进程 1 并不想进入临界区，所以
<code>enter_region</code> 很快便返回。如果进程现在调用
<code>enter_region</code>，进程 1 将在此处挂起直到 interested[0] 变为
FALSE，这种情况只有在进程 0 调用 <code>leave_region</code>
退出临界区时才会发生。</p>
<p>那么上面讨论的是顺序进入的情况，现在来考虑一种两个进程同时调用
<code>enter_region</code> 的情况。它们都将自己的进程存入
turn，但只有最后保存进去的进程号才有效，前一个进程的进程号因为重写而丢失。假如进程
1 是最后存入的，则 turn 为 1 。当两个进程都运行到 while 的时候，进程 0
将不会循环并进入临界区，而进程 1 将会无限循环且不会进入临界区，直到进程
0 退出位置。</p>
<h4 id="tsl-指令">TSL 指令</h4>
<p>现在来看一种需要硬件帮助的方案。一些计算机，特别是那些设计为多处理器的计算机，都会有下面这条指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSL RX,LOCK    </span><br></pre></td></tr></table></figure>
<p>称为 <strong>测试并加锁(test and set lock)</strong> ，它将一个内存字
lock 读到寄存器 RX
中，然后在该内存地址上存储一个非零值。读写指令能保证是一体的，不可分割的，一同执行的。在这个指令结束之前其他处理器均不允许访问内存。执行
TSL 指令的 CPU 将会锁住内存总线，用来禁止其他 CPU
在这个指令结束之前访问内存。</p>
<p>很重要的一点是锁住内存总线和禁用中断不一样。禁用中断并不能保证一个处理器在读写操作之间另一个处理器对内存的读写。也就是说，在处理器
1 上屏蔽中断对处理器 2 没有影响。让处理器 2 远离内存直到处理器 1
完成读写的最好的方式就是锁住总线。这需要一个特殊的硬件（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用）</p>
<p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当
lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为
1，并读写共享内存。当操作结束时，进程使用 move 指令将 lock
的值重新设置为 0 。</p>
<p>这条指令如何防止两个进程同时进入临界区呢？下面是解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">            | 复制锁到寄存器并将锁设为1</span><br><span class="line">            TSL REGISTER,LOCK              </span><br><span class="line">            | 锁是 0 吗？</span><br><span class="line">          CMP REGISTER,#0                             </span><br><span class="line">          | 若不是零，说明锁已被设置，所以循环</span><br><span class="line">          JNE enter_region                            </span><br><span class="line">          | 返回调用者，进入临界区</span><br><span class="line">          RET                                              </span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line"></span><br><span class="line">            | 在锁中存入 0</span><br><span class="line">            MOVE LOCK,#0                  </span><br><span class="line">      | 返回调用者</span><br><span class="line">          RET           </span><br></pre></td></tr></table></figure>
<p>我们可以看到这个解决方案的思想和 Peterson
的思想很相似。假设存在如下共 4 指令的汇编语言程序。第一条指令将 lock
原来的值复制到寄存器中并将 lock 设置为 1 ，随后这个原来的值和 0
做对比。如果它不是零，说明之前已经被加过锁，则程序返回到开始并再次测试。经过一段时间后（可长可短），该值变为
0
（当前处于临界区中的进程退出临界区时），于是过程返回，此时已加锁。要清除这个锁也比较简单，程序只需要将
0 存入 lock 即可，不需要特殊的同步指令。</p>
<p>现在有了一种很明确的做法，那就是进程在进入临界区之前会先调用
<code>enter_region</code> ，判断是否进行循环，如果lock 的值是 1
，进行无限循环，如果 lock 是
0，不进入循环并进入临界区。在进程从临界区返回时它调用
<code>leave_region</code> ，这会把 lock 设置为 0
。与基于临界区问题的所有解法一样，进程必须在正确的时间调用 enter_region
和 leave_region ，解法才能奏效。</p>
<p>还有一个可以替换 TSL 的指令是 <code>XCHG</code>
，它原子性的交换了两个位置的内容，例如，一个寄存器与一个内存字，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">        | 把 1 放在内存器中</span><br><span class="line">        MOVE REGISTER,#1    </span><br><span class="line">    | 交换寄存器和锁变量的内容</span><br><span class="line">        XCHG REGISTER,LOCK          </span><br><span class="line">    | 锁是 0 吗？</span><br><span class="line">        CMP REGISTER,#0     </span><br><span class="line">    | 若不是 0 ，锁已被设置，进行循环</span><br><span class="line">        JNE enter_region                    </span><br><span class="line">    | 返回调用者，进入临界区</span><br><span class="line">        RET                                                     </span><br><span class="line"></span><br><span class="line">leave_region:                </span><br><span class="line">        | 在锁中存入 0 </span><br><span class="line">        MOVE LOCK,#0    </span><br><span class="line">    | 返回调用者</span><br><span class="line">        RET       </span><br></pre></td></tr></table></figure>
<p>XCHG 的本质上与 TSL 的解决办法一样。所有的 Intel x86 CPU
在底层同步中使用 XCHG 指令。</p>
<h3 id="睡眠与唤醒">睡眠与唤醒</h3>
<p>上面解法中的 Peterson 、TSL 和 XCHG
解法都是正确的，但是它们都有忙等待的缺点。这些解法的本质上都是一样的，先检查是否能够进入临界区，若不允许，则该进程将原地等待，直到允许为止。</p>
<p>这种方式不但浪费了 CPU
时间，而且还可能引起意想不到的结果。考虑一台计算机上有两个进程，这两个进程具有不同的优先级，H
是属于优先级比较高的进程，L
是属于优先级比较低的进程。进程调度的规则是不论何时只要 H 进程处于就绪态
H 就开始运行。在某一时刻，L 处于临界区中，此时 H
变为就绪态，准备运行（例如，一条 I/O 操作结束）。现在 H
要开始忙等，但由于当 H 就绪时 L 就不会被调度，L
从来不会有机会离开关键区域，所以 H
会变成死循环，有时将这种情况称为<strong>优先级反转问题(priority
inversion problem)</strong> 。</p>
<p>现在让我们看一下进程间的通信原语，这些原语在不允许它们进入关键区域之前会阻塞而不是浪费
CPU 时间，最简单的是 sleep 和 wakeup。Sleep
是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停直到其他进程唤醒它。wakeup
调用有一个参数，即要唤醒的进程。还有一种方式是 wakeup 和 sleep
都有一个参数，即 sleep 和 wakeup 需要匹配的内存地址。</p>
<h4 id="生产者-消费者问题">生产者-消费者问题</h4>
<p>作为这些私有原语的例子，让我们考虑<strong>生产者-消费者(producer-consumer)</strong>
问题，也称作 <strong>有界缓冲区(bounded-buffer)</strong>
问题。两个进程共享一个公共的固定大小的缓冲区。其中一个是<code>生产者(producer)</code>，将信息放入缓冲区，
另一个是<code>消费者(consumer)</code>，会从缓冲区中取出。也可以把这个问题一般化为
m 个生产者和 n
个消费者的问题，但是我们这里只讨论一个生产者和一个消费者的情况，这样可以简化实现方案。</p>
<p>如果缓冲队列已满，那么当生产者仍想要将数据写入缓冲区的时候，会出现问题。它的解决办法是让生产者睡眠，也就是阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。同样的，当消费者试图从缓冲区中取数据，但是发现缓冲区为空时，消费者也会睡眠，阻塞。直到生产者向其中放入一个新的数据。</p>
<p>这个逻辑听起来比较简单，而且这种方式也需要一种称作
<strong>监听</strong> 的变量，这个变量用于监视缓冲区的数据，我们暂定为
count，如果缓冲区最多存放 N 个数据项，生产者会每次判断 count 是否达到
N，否则生产者向缓冲区放入一个数据项并增量 count
的值。消费者的逻辑也很相似：首先测试 count 的值是否为 0 ，如果为 0
则消费者睡眠、阻塞，否则会从缓冲区取出数据并使 count
数量递减。每个进程也会检查其他线程是否应该被唤醒，如果应该被唤醒，那么就唤醒该线程。下面是生产者消费者的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓冲区 slot 槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100                        </span></span><br><span class="line"><span class="comment">/* 缓冲区数据的数量 */</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>                                        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">producer</span>(<span class="type">void</span>)&#123;</span><br><span class="line">  <span class="type">int</span> item;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;                </span><br><span class="line">    <span class="comment">/* 生成下一项数据 */</span></span><br><span class="line">    item = <span class="built_in">produce_item</span>()                </span><br><span class="line">    <span class="comment">/* 如果缓存区是满的，就会阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span>(count == N)&#123;</span><br><span class="line">      <span class="built_in">sleep</span>();                                    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把当前数据放在缓冲区中 */</span></span><br><span class="line">    <span class="built_in">insert_item</span>(item);</span><br><span class="line">    <span class="comment">/* 增加缓冲区 count 的数量 */</span></span><br><span class="line">    count = count + <span class="number">1</span>;                    </span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">/* 缓冲区是否为空？ */</span></span><br><span class="line">      <span class="built_in">wakeup</span>(consumer);                    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> item;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 如果缓冲区是空的，就会进行阻塞 */</span></span><br><span class="line">      <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;                         </span><br><span class="line">      <span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 从缓冲区中取出一个数据 */</span></span><br><span class="line">       item = <span class="built_in">remove_item</span>();           </span><br><span class="line">    <span class="comment">/* 将缓冲区的 count 数量减一 */</span></span><br><span class="line">    count = count - <span class="number">1</span></span><br><span class="line">    <span class="comment">/* 缓冲区满嘛？ */</span></span><br><span class="line">    <span class="keyword">if</span>(count == N - <span class="number">1</span>)&#123;                    </span><br><span class="line">      <span class="built_in">wakeup</span>(producer);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印数据项 */</span></span><br><span class="line">    <span class="built_in">consumer_item</span>(item);                </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在 C 语言中描述像是 <code>sleep</code> 和 <code>wakeup</code>
的系统调用，我们将以库函数调用的形式来表示。它们不是 C
标准库的一部分，但可以在实际具有这些系统调用的任何系统上使用。代码中未实现的
<code>insert_item</code> 和 <code>remove_item</code>
用来记录将数据项放入缓冲区和从缓冲区取出数据等。</p>
<p>现在让我们回到生产者-消费者问题上来，上面代码中会产生竞争条件，因为
count
这个变量是暴露在大众视野下的。有可能出现下面这种情况：缓冲区为空，此时消费者刚好读取
count 的值发现它为 0
。此时调度程序决定暂停消费者并启动运行生产者。生产者生产了一条数据并把它放在缓冲区中，然后增加
count 的值，并注意到它的值是 1 。由于 count 为
0，消费者必须处于睡眠状态，因此生产者调用 wakeup
来唤醒消费者。但是，消费者此时在逻辑上并没有睡眠，所以 wakeup
信号会丢失。当消费者下次启动后，它会查看之前读取的 count
值，发现它的值是 0
，然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，这样一来两个进程将永远睡眠下去。</p>
<p>引起上面问题的本质是
<strong>唤醒尚未进行睡眠状态的进程会导致唤醒丢失</strong>
。如果它没有丢失，则一切都很正常。一种快速解决上面问题的方式是增加一个<code>唤醒等待位(wakeup waiting bit)</code>
。当一个 wakeup 信号发送给仍在清醒的进程后，该位置为 1
。之后，当进程尝试睡眠的时候，如果唤醒等待位为 1
，则该位清除，而进程仍然保持清醒。</p>
<p>然而，当进程数量有许多的时候，这时你可以说通过增加唤醒等待位的数量来唤醒等待位，于是就有了
2、4、6、8 个唤醒等待位，但是并没有从根本上解决问题。</p>
<h3 id="信号量">信号量</h3>
<p>信号量是 E.W.Dijkstra 在 1965
年提出的一种方法，它使用一个整形变量来累计唤醒次数，以供之后使用。在他的观点中，有一个新的变量类型称作
<strong>信号量(semaphore)</strong> 。一个信号量的取值可以是 0
，或任意正数。0
表示的是不需要任何唤醒，任意的正数表示的就是唤醒次数。</p>
<p>Dijkstra 提出了信号量有两个操作，现在通常使用 <code>down</code> 和
<code>up</code>（分别可以用 sleep 和 wakeup 来表示）。down
这个指令的操作会检查值是否大于 0 。如果大于 0 ，则将其值减 1 ；若该值为
0 ，则进程将睡眠，而且此时 down
操作将会继续执行。检查数值、修改变量值以及可能发生的睡眠操作均为一个单一的、不可分割的
<strong>原子操作(atomic action)</strong>
完成。这会保证一旦信号量操作开始，没有其他的进程能够访问信号量，直到操作完成或者阻塞。这种原子性对于解决同步问题和避免竞争绝对必不可少。</p>
<blockquote>
<p><strong>原子性操作</strong>指的是在计算机科学的许多其他领域中，一组相关操作全部执行而没有中断或根本不执行。</p>
</blockquote>
<p>up 操作会使信号量的值 +
1。如果一个或者多个进程在信号量上睡眠，无法完成一个先前的 down
操作，则由系统选择其中一个并允许该程完成 down
操作。因此，对一个进程在其上睡眠的信号量执行一次 up
操作之后，该信号量的值仍然是 0
，但在其上睡眠的进程却少了一个。信号量的值增 1
和唤醒一个进程同样也是不可分割的。不会有某个进程因执行 up
而阻塞，正如在前面的模型中不会有进程因执行 wakeup
而阻塞是一样的道理。</p>
<h4 id="用信号量解决生产者---消费者问题">用信号量解决生产者 -
消费者问题</h4>
<p>用信号量解决丢失的 <code>wakeup</code> 问题，代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义缓冲区槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="comment">/* 信号量是一种特殊的 int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"><span class="comment">/* 控制关键区域的访问 */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 统计 buffer 空槽的数量 */</span></span><br><span class="line">semaphore empty = N;</span><br><span class="line"><span class="comment">/* 统计 buffer 满槽的数量 */</span></span><br><span class="line">semaphore full = <span class="number">0</span>;                                                </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>)</span></span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> item;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* TRUE 的常量是 1 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;            </span><br><span class="line">    <span class="comment">/* 产生放在缓冲区的一些数据 */</span></span><br><span class="line">    item = <span class="built_in">producer_item</span>();        </span><br><span class="line">    <span class="comment">/* 将空槽数量减 1  */</span></span><br><span class="line">    <span class="built_in">down</span>(&amp;empty);    </span><br><span class="line">    <span class="comment">/* 进入关键区域  */</span></span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);    </span><br><span class="line">    <span class="comment">/* 把数据放入缓冲区中 */</span></span><br><span class="line">    <span class="built_in">insert_item</span>(item);</span><br><span class="line">    <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);    </span><br><span class="line">    <span class="comment">/* 将 buffer 满槽数量 + 1 */</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;full);                                                        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> item;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 缓存区满槽数量 - 1 */</span></span><br><span class="line">    <span class="built_in">down</span>(&amp;full);</span><br><span class="line">    <span class="comment">/* 进入缓冲区 */</span>    </span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">/* 从缓冲区取出数据 */</span></span><br><span class="line">    item = <span class="built_in">remove_item</span>();    </span><br><span class="line">    <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);    </span><br><span class="line">    <span class="comment">/* 将空槽数目 + 1 */</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;empty);    </span><br><span class="line">    <span class="comment">/* 处理数据 */</span></span><br><span class="line">    <span class="built_in">consume_item</span>(item);                                            </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它。通常是将
up 和 down
作为系统调用来实现。而且操作系统只需在执行以下操作时暂时屏蔽全部中断：<strong>检查信号量、更新、必要时使进程睡眠</strong>
。由于这些操作仅需要非常少的指令，因此中断不会造成影响。如果使用多个
CPU，那么信号量应该被锁进行保护。使用 TSL 或者 XCHG
指令用来确保同一时刻只有一个 CPU 对信号量进行操作。</p>
<p>使用 TSL 或者 XCHG 来防止几个 CPU
同时访问一个信号量，与生产者或消费者使用忙等待来等待其他腾出或填充缓冲区是完全不一样的。前者的操作仅需要几个毫秒，而生产者或消费者可能需要任意长的时间。</p>
<p>上面这个解决方案使用了三种信号量：一个称为
full，用来记录充满的缓冲槽数目；一个称为
empty，记录空的缓冲槽数目；一个称为
mutex，用来确保生产者和消费者不会同时进入缓冲区。Full 被初始化为 0
，empty 初始化为缓冲区中插槽数，mutex 初始化为 1。信号量初始化为 1
并且由两个或多个进程使用，以确保它们中同时只有一个可以进入关键区域的信号被称为
<strong>二进制信号量(binary semaphores)</strong>
。如果每个进程都在进入关键区域之前执行 down
操作，而在离开关键区域之后执行 up 操作，则可以确保相互互斥。</p>
<p>现在我们有了一个好的进程间原语的保证。然后我们再来看一下中断的顺序保证</p>
<ol type="1">
<li><p>硬件压入堆栈程序计数器等</p></li>
<li><p>硬件从中断向量装入新的程序计数器</p></li>
<li><p>汇编语言过程保存寄存器的值</p></li>
<li><p>汇编语言过程设置新的堆栈</p></li>
<li><p>C 中断服务器运行（典型的读和缓存写入）</p></li>
<li><p>调度器决定下面哪个程序先运行</p></li>
<li><p>C 过程返回至汇编代码</p></li>
<li><p>汇编语言过程开始运行新的当前进程</p></li>
</ol>
<p>在使用信号量的系统中，隐藏中断的自然方法是让每个 I/O
设备都配备一个信号量，该信号量最初设置为0。在 I/O
设备启动后，中断处理程序立刻对相关联的信号执行一个 down
操作，于是进程立即被阻塞。当中断进入时，中断处理程序随后对相关的信号量执行一个
up操作，能够使已经阻止的进程恢复运行。在上面的中断处理步骤中，其中的第 5
步 C 中断服务器运行 就是中断处理程序在信号量上执行的一个 up
操作，所以在第 6
步中，操作系统能够执行设备驱动程序。当然，如果有几个进程已经处于就绪状态，调度程序可能会选择接下来运行一个更重要的进程，我们会在后面讨论调度的算法。</p>
<p>上面的代码实际上是通过两种不同的方式来使用信号量的，而这两种信号量之间的区别也是很重要的。mutex
信号量用于互斥。它用于确保任意时刻只有一个进程能够对缓冲区和相关变量进行读写。互斥是用于避免进程混乱所必须的一种操作。</p>
<p>另外一个信号量是关于同步(synchronization)的。full 和 empty
信号量用于确保事件的发生或者不发生。在这个事例中，它们确保了缓冲区满时生产者停止运行；缓冲区为空时消费者停止运行。这两个信号量的使用与
mutex 不同。</p>
<h3 id="互斥量">互斥量</h3>
<p>如果不需要信号量的计数能力时，可以使用信号量的一个简单版本，称为
<strong>mutex(互斥量)</strong>
。互斥量的优势就在于在一些共享资源和一段代码中保持互斥。由于互斥的实现既简单又有效，这使得互斥量在实现用户空间线程包时非常有用。</p>
<p>互斥量是一个处于两种状态之一的共享变量：<strong>解锁(unlocked)</strong>
和 <strong>加锁(locked)</strong>
。这样，只需要一个二进制位来表示它，不过一般情况下，通常会用一个
<code>整形(integer)</code> 来表示。0 表示解锁，其他所有的值表示加锁，比
1 大的值表示加锁的次数。</p>
<p><strong>mutex</strong>
使用两个过程，当一个线程（或者进程）需要访问关键区域时，会调用
<code>mutex_lock</code>
进行加锁。如果互斥锁当前处于解锁状态（表示关键区域可用），则调用成功，并且调用线程可以自由进入关键区域。</p>
<p>另一方面，如果 mutex
互斥量已经锁定的话，调用线程会阻塞直到关键区域内的线程执行完毕并且调用了
<code>mutex_unlock</code> 。如果多个线程在 mutex
互斥量上阻塞，将随机选择一个线程并允许它获得锁。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4LvZRA"><img
src="https://z3.ax1x.com/2021/10/03/4LvZRA.png"
alt="4LvZRA.png" /></a></p>
<p>由于 mutex 互斥量非常简单，所以只要有 TSL 或者是 XCHG
指令，就可以很容易地在用户空间实现它们。用于用户级线程包的
<code>mutex_lock</code> 和 <code>mutex_unlock</code> 代码如下，XCHG
的本质也一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">            | 将互斥信号量复制到寄存器，并将互斥信号量置为1</span><br><span class="line">            TSL REGISTER,MUTEX</span><br><span class="line">      | 互斥信号量是 0 吗？</span><br><span class="line">            CMP REGISTER,#0 </span><br><span class="line">      | 如果互斥信号量为0，它被解锁，所以返回</span><br><span class="line">            JZE ok  </span><br><span class="line">      | 互斥信号正在使用；调度其他线程</span><br><span class="line">            CALL thread_yield   </span><br><span class="line">      | 再试一次</span><br><span class="line">            JMP mutex_lock  </span><br><span class="line">      | 返回调用者，进入临界区</span><br><span class="line">ok:     RET                                                     </span><br><span class="line"></span><br><span class="line">mutex_unlcok:</span><br><span class="line">            | 将 mutex 置为 0 </span><br><span class="line">            MOVE MUTEX,#0   </span><br><span class="line">      | 返回调用者</span><br><span class="line">            RET        </span><br></pre></td></tr></table></figure>
<p><strong>mutex_lock</strong> 的代码和上面
<strong>enter_region</strong> 的代码很相似，我们可以对比着看一下</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4LxVTU"><img
src="https://z3.ax1x.com/2021/10/03/4LxVTU.png"
alt="4LxVTU.png" /></a></p>
<p>上面代码最大的区别你看出来了吗？</p>
<ul>
<li><p>根据上面我们对 TSL 的分析，我们知道，如果 TSL
判断没有进入临界区的进程会进行无限循环获取锁，而在 TSL 的处理中，如果
mutex
正在使用，那么就调度其他线程进行处理。所以上面最大的区别其实就是在判断
mutex/TSL 之后的处理。</p></li>
<li><p>在（用户）线程中，情况有所不同，因为没有时钟来停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去，决不会得到锁，因为这个运行的线程不会让其他线程运行从而释放锁，其他线程根本没有获得锁的机会。在后者获取锁失败时，它会调用
thread_yield 将 CPU
放弃给另外一个线程。结果就不会进行忙等待。在该线程下次运行时，它再一次对锁进行测试。</p></li>
</ul>
<p>上面就是 <strong>enter_region</strong> 和 <strong>mutex_lock</strong>
的差别所在。由于 <code>thread_yield</code>
仅仅是一个用户空间的线程调度，所以它的运行非常快捷。这样，mutex_lock 和
mutex_unlock
都不需要任何内核调用。通过使用这些过程，用户线程完全可以实现在用户空间中的同步，这个过程仅仅需要少量的同步。</p>
<p>我们上面描述的互斥量其实是一套调用框架中的指令。从软件角度来说，总是需要更多的特性和同步原语。例如，有时线程包提供一个调用
<code>mutex_trylock</code>
，这个调用尝试获取锁或者返回错误码，但是不会进行加锁操作。这就给了调用线程一个灵活性，以决定下一步做什么，是使用替代方法还是等候下去。</p>
<h4 id="futexes">Futexes</h4>
<p>随着并行的增加，<strong>有效的同步(synchronization)</strong> 和
<strong>锁定(locking)</strong>
对于性能来说是非常重要的。如果进程等待时间很短，那么 <strong>自旋锁(Spin
lock)</strong> 是非常有效；但是如果等待时间比较长，那么这会浪费 CPU
周期。如果进程很多，那么阻塞此进程，并仅当锁被释放的时候让内核解除阻塞是更有效的方式。不幸的是，这种方式也会导致另外的问题：它可以在进程竞争频繁的时候运行良好，但是在竞争不是很激烈的情况下内核切换的消耗会非常大，而且更困难的是，预测锁的竞争数量更不容易。</p>
<p>有一种有趣的解决方案是把两者的优点结合起来，提出一种新的思想，称为
<strong>futex</strong> ，或者是 <strong>快速用户空间互斥(fast user space
mutex)</strong> ，是不是听起来很有意思？</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4OSFaT"><img
src="https://z3.ax1x.com/2021/10/04/4OSFaT.png"
alt="4OSFaT.png" /></a></p>
<p><strong>futex</strong> 是 Linux
中的特性实现了基本的锁定（很像是互斥锁）而且避免了陷入内核中，因为内核的切换的开销非常大，这样做可以大大提高性能。futex
由两部分组成：<strong>内核服务和用户库</strong> 。内核服务提供了了一个
<code>等待队列(wait queue)</code>
允许多个进程在锁上排队等待。除非内核明确的对他们解除阻塞，否则它们不会运行。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4OpMlj"><img
src="https://z3.ax1x.com/2021/10/04/4OpMlj.png"
alt="4OpMlj.png" /></a></p>
<p>对于一个进程来说，把它放到等待队列需要昂贵的系统调用，这种方式应该被避免。在没有竞争的情况下，futex
可以直接在用户空间中工作。这些进程共享一个 <strong>32
位整数(integer)</strong> 作为公共锁变量。假设锁的初始化为
1，我们认为这时锁已经被释放了。线程通过执行原子性的操作<strong>减少并测试(decrement
and test)</strong> 来抢占锁。decrement and set 是 Linux
中的原子功能，由包裹在 C
函数中的内联汇编组成，并在头文件中进行定义。下一步，线程会检查结果来查看锁是否已经被释放。如果锁现在不是锁定状态，那么刚好我们的线程可以成功抢占该锁。然而，如果锁被其他线程持有，抢占锁的线程不得不等待。在这种情况下，futex
库不会<strong>自旋</strong>
，但是会使用一个系统调用来把线程放在内核中的等待队列中。这样一来，切换到内核的开销已经是合情合理的了，因为线程可以在任何时候阻塞。当线程完成了锁的工作时，它会使用原子性的
<strong>增加并测试(increment and test)</strong>
释放锁，并检查结果以查看内核等待队列上是否仍阻止任何进程。如果有的话，它会通知内核可以对等待队列中的一个或多个进程解除阻塞。如果没有锁竞争，内核则不需要参与竞争。</p>
<h4 id="pthreads-中的互斥量">Pthreads 中的互斥量</h4>
<p><strong>Pthreads</strong>
提供了一些功能用来同步线程。最基本的机制是使用互斥量变量，可以锁定和解锁，用来保护每个关键区域。希望进入关键区域的线程首先要尝试获取
mutex。如果 mutex
没有加锁，线程能够马上进入并且互斥量能够自动锁定，从而阻止其他线程进入。如果
mutex 已经加锁，调用线程会阻塞，直到 mutex
解锁。如果多个线程在相同的互斥量上等待，当互斥量解锁时，只有一个线程能够进入并且重新加锁。这些锁并不是必须的，程序员需要正确使用它们。</p>
<p>下面是与互斥量有关的函数调用</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5PNW8g"><img
src="https://z3.ax1x.com/2021/10/08/5PNW8g.png"
alt="5PNW8g.png" /></a></p>
<p>像我们想象中的一样，<strong>mutex</strong>
能够被创建和销毁，扮演这两个角色的分别是 <code>Phread_mutex_init</code>
和 <code>Pthread_mutex_destroy</code> 。<strong>mutex</strong>
也可以通过 <code>Pthread_mutex_lock</code>
来进行加锁，如果互斥量已经加锁，则会阻塞调用者。还有一个调用<code>Pthread_mutex_trylock</code>
用来尝试对线程加锁，当 <strong>mutex</strong>
已经被加锁时，会返回一个错误代码而不是阻塞调用者。这个调用允许线程有效的进行忙等。最后，<code>Pthread_mutex_unlock</code>
会对 <strong>mutex</strong> 解锁并且释放一个正在等待的线程。</p>
<p>除了互斥量以外，<strong>Pthreads</strong> 还提供了第二种同步机制：
<strong>条件变量(condition variables)</strong> 。<code>mutex</code>
可以很好的允许或阻止对关键区域的访问。条件变量允许线程由于未满足某些条件而阻塞。绝大多数情况下这两种方法是一起使用的。下面我们进一步来研究线程、互斥量、条件变量之间的关联。</p>
<p>下面再来重新认识一下生产者和消费者问题：一个线程将东西放在一个缓冲区内，由另一个线程将它们取出。如果生产者发现缓冲区没有空槽可以使用了，生产者线程会阻塞起来直到有一个线程可以使用。生产者使用
mutex
来进行原子性检查从而不受其他线程干扰。但是当发现缓冲区已经满了以后，生产者需要一种方法来阻塞自己并在以后被唤醒。这便是条件变量做的工作。</p>
<p>下面是一些与条件变量有关的最重要的 <strong>pthread 调用</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5PU1JS"><img
src="https://z3.ax1x.com/2021/10/08/5PU1JS.png"
alt="5PU1JS.png" /></a></p>
<p>上表中给出了一些调用用来创建和销毁条件变量。条件变量上的主要属性是
<code>Pthread_cond_wait</code> 和 <code>Pthread_cond_signal</code>
。前者阻塞调用线程，直到其他线程发出信号为止（使用后者调用）。阻塞的线程通常需要等待唤醒的信号以此来释放资源或者执行某些其他活动。只有这样阻塞的线程才能继续工作。条件变量允许等待与阻塞原子性的进程。<code>Pthread_cond_broadcast</code>
用来唤醒多个阻塞的、需要等待信号唤醒的线程。</p>
<blockquote>
<p>需要注意的是，条件变量（不像是信号量）不会存在于内存中。如果将一个信号量传递给一个没有线程等待的条件变量，那么这个信号就会丢失，这个需要注意</p>
</blockquote>
<p>下面是一个使用互斥量和条件变量的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要生产的数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000000000                                        </span></span><br><span class="line"><span class="type">pthread_mutex_t</span> the_mutex;</span><br><span class="line"><span class="comment">/* 使用信号量 */</span></span><br><span class="line"><span class="type">pthread_cond_t</span> condc,condp;                                </span><br><span class="line"><span class="type">int</span> buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生产数据 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *ptr)</span></span>&#123;                                </span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= MAX;i++)&#123;</span><br><span class="line">    <span class="comment">/* 缓冲区独占访问，也就是使用 mutex 获取锁 */</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;the_mutex);                </span><br><span class="line">    <span class="keyword">while</span>(buffer != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">pthread_cond_wait</span>(&amp;condp,&amp;the_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 把他们放在缓冲区中 */</span></span><br><span class="line">    buffer = i;            </span><br><span class="line">    <span class="comment">/* 唤醒消费者 */</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;condc);    </span><br><span class="line">    <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;the_mutex);            </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 消费数据 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consumer</span><span class="params">(<span class="type">void</span> *ptr)</span></span>&#123;                                </span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= MAX;i++)&#123;</span><br><span class="line">    <span class="comment">/* 缓冲区独占访问，也就是使用 mutex 获取锁 */</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;the_mutex);                </span><br><span class="line">    <span class="keyword">while</span>(buffer == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">pthread_cond_wait</span>(&amp;condc,&amp;the_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 把他们从缓冲区中取出 */</span></span><br><span class="line">    buffer = <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">/* 唤醒生产者 */</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;condp);</span><br><span class="line">    <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;the_mutex);            </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;                         </span><br></pre></td></tr></table></figure>
<h3 id="管程">管程</h3>
<p>为了能够编写更加准确无误的程序，Brinch Hansen 和 Hoare
提出了一个更高级的同步原语叫做 <strong>管程(monitor)</strong>
。他们两个人的提案略有不同，通过下面的描述你就可以知道。<strong>管程是程序、变量和数据结构等组成的一个集合，它们组成一个特殊的模块或者包。进程可以在任何需要的时候调用管程中的程序，但是它们不能从管程外部访问数据结构和程序。</strong>
下面展示了一种抽象的，类似 Pascal 语言展示的简洁的管程。不能用 C
语言进行描述，因为管程是语言概念而 C 语言并不支持管程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">monitor example</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    procedure producer();</span><br><span class="line">  ...</span><br><span class="line">    end;    </span><br><span class="line"></span><br><span class="line">    procedure consumer();</span><br><span class="line">    .</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure>
<p><strong>管程</strong>有一个很重要的特性，<strong>即在任何时候管程中只能有一个活跃的进程</strong>，这一特性使管程能够很方便的实现互斥操作。管程是编程语言的特性，所以编译器知道它们的特殊性，因此可以采用与其他过程调用不同的方法来处理对管程的调用。通常情况下，当进程调用管程中的程序时，该程序的前几条指令会检查管程中是否有其他活跃的进程。如果有的话，调用进程将被挂起，直到另一个进程离开管程才将其唤醒。如果没有活跃进程在使用管程，那么该调用进程才可以进入。</p>
<p>进入管程中的互斥由编译器负责，但是一种通用做法是使用
<strong>互斥量(mutex)</strong> 和 <strong>二进制信号量(binary
semaphore)</strong>
。由于编译器而不是程序员在操作，因此出错的几率会大大降低。在任何时候，编写管程的程序员都无需关心编译器是如何处理的。他只需要知道将所有的临界区转换成为管程过程即可。绝不会有两个进程同时执行临界区中的代码。</p>
<p>即使管程提供了一种简单的方式来实现互斥，但在我们看来，这还不够。因为我们还需要一种办法在进程无法执行被阻塞。在生产者-消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放在管程程序中，但是生产者在发现缓冲区满的时候该如何阻塞呢？</p>
<ul>
<li>解决的办法是<strong>引入条件变量(condition variables)
以及相关的两个操作 wait 和 signal</strong>
。当一个管程程序发现它不能运行时（例如，生产者发现缓冲区已满），它会在某个条件变量（如
full）上执行 wait
操作。这个操作造成调用进程阻塞，并且还将另一个以前等在管程之外的进程调入管程。在前面的
pthread
中我们已经探讨过条件变量的实现细节了。另一个进程，比如消费者可以通过执行
signal 来唤醒阻塞的调用进程。</li>
</ul>
<blockquote>
<p>Brinch Hansen 和 Hoare 在对进程唤醒上有所不同，Hoare
建议让新唤醒的进程继续运行；而挂起另外的进程。而 Brinch Hansen
建议让执行 signal 的进程必须退出管程，这里我们采用 Brinch Hansen
的建议，因为它在概念上更简单，并且更容易实现。</p>
</blockquote>
<p>如果在一个条件变量上有若干进程都在等待，则在对该条件执行
<code>signal</code>
操作后，系统调度程序只能选择其中一个进程恢复运行。</p>
<p>顺便提一下，这里还有上面两位教授没有提出的第三种方式，它的理论是让执行
<code>signal</code>
的进程继续运行，等待这个进程退出管程时，其他进程才能进入管程。</p>
<p>条件变量不是计数器。条件变量也不能像信号量那样积累信号以便以后使用。所以，如果向一个条件变量发送信号，但是该条件变量上没有等待进程，那么信号将会丢失。也就是说，<strong>wait
操作必须在 signal 之前执行。</strong></p>
<p>下面是一个使用 Pascal 语言通过管程实现的生产者-消费者问题的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">        condition full,empty;</span><br><span class="line">        integer count;</span><br><span class="line"></span><br><span class="line">        procedure insert(item:integer);</span><br><span class="line">        begin</span><br><span class="line">                if count = N then wait(full);</span><br><span class="line">                insert_item(item);</span><br><span class="line">                count := count + 1;</span><br><span class="line">                if count = 1 then signal(empty);</span><br><span class="line">        end;</span><br><span class="line"></span><br><span class="line">        function remove:integer;</span><br><span class="line">        begin</span><br><span class="line">                if count = 0 then wait(empty);</span><br><span class="line">                remove = remove_item;</span><br><span class="line">                count := count - 1;</span><br><span class="line">                if count = N - 1 then signal(full);</span><br><span class="line">        end;</span><br><span class="line"></span><br><span class="line">        count := 0;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line">procedure producer;</span><br><span class="line">begin</span><br><span class="line">            while true do</span><br><span class="line">      begin </span><br><span class="line">                  item = produce_item;</span><br><span class="line">                  ProducerConsumer.insert(item);</span><br><span class="line">      end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">procedure consumer;</span><br><span class="line">begin </span><br><span class="line">            while true do</span><br><span class="line">            begin</span><br><span class="line">                        item = ProducerConsumer.remove;</span><br><span class="line">                        consume_item(item);</span><br><span class="line">            end</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>读者可能觉得 wait 和 signal 操作看起来像是前面提到的 sleep 和 wakeup
，而且后者存在严重的竞争条件。它们确实很像，但是有个关键的区别：sleep 和
wakeup
之所以会失败是因为当一个进程想睡眠时，另一个进程试图去唤醒它。使用管程则不会发生这种情况。管程程序的自动互斥保证了这一点，如果管程过程中的生产者发现缓冲区已满，它将能够完成
wait 操作而不用担心调度程序可能会在 wait 完成之前切换到消费者。甚至，在
wait
执行完成并且把生产者标志为不可运行之前，是不会允许消费者进入管程的。</p>
<p>尽管类 Pascal 是一种想象的语言，但还是有一些真正的编程语言支持，比如
Java （终于轮到大 Java 出场了），Java 是能够支持管程的，它是一种
面向对象的语言，支持用户级线程，还允许将方法划分为类。只要将关键字
synchronized 关键字加到方法中即可。Java
能够保证一旦某个线程执行该方法，就不允许其他线程执行该对象中的任何
synchronized 方法。没有关键字 synchronized
，就不能保证没有交叉执行。</p>
<p>下面是 Java 使用管程解决的生产者-消费者问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> &#123;</span><br><span class="line">  <span class="comment">// 定义缓冲区大小的长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 初始化一个新的生产者线程</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line">  <span class="comment">// 初始化一个新的消费者线程</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>();        </span><br><span class="line">  <span class="comment">// 初始化一个管程</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Our_monitor</span> <span class="variable">mon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Our_monitor</span>(); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// run 包含了线程代码</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;                                                </span><br><span class="line">      <span class="type">int</span> item;</span><br><span class="line">      <span class="comment">// 生产者循环</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123;                                                        </span><br><span class="line">        item = produce_item();</span><br><span class="line">        mon.insert(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">produce_item</span><span class="params">()</span>&#123;...&#125;                        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// run 包含了线程代码</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">( )</span> &#123;                                            </span><br><span class="line">           <span class="type">int</span> item;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        item = mon.remove();</span><br><span class="line">                consume_item(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">produce_item</span><span class="params">()</span>&#123;...&#125;                        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是管程</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Our_monitor</span> &#123;                                    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> buffer[] = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="comment">// 计数器和索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>,lo = <span class="number">0</span>,hi = <span class="number">0</span>;            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(count == N)&#123;</span><br><span class="line">        <span class="comment">// 如果缓冲区是满的，则进入休眠</span></span><br><span class="line">        go_to_sleep();                                                </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向缓冲区插入内容</span></span><br><span class="line">            buffer[hi] = val;                   </span><br><span class="line">      <span class="comment">// 找到下一个槽的为止</span></span><br><span class="line">      hi = (hi + <span class="number">1</span>) % N;                 </span><br><span class="line">      <span class="comment">// 缓冲区中的数目自增 1 </span></span><br><span class="line">      count = count + <span class="number">1</span>;                                            </span><br><span class="line">      <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果消费者睡眠，则唤醒</span></span><br><span class="line">        notify();                                                            </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 缓冲区是空的，进入休眠</span></span><br><span class="line">        go_to_sleep();                                                </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从缓冲区取出数据</span></span><br><span class="line">      val = buffer[lo];                </span><br><span class="line">      <span class="comment">// 设置待取出数据项的槽</span></span><br><span class="line">      lo = (lo + <span class="number">1</span>) % N;                    </span><br><span class="line">      <span class="comment">// 缓冲区中的数据项数目减 1 </span></span><br><span class="line">      count = count - <span class="number">1</span>;                                            </span><br><span class="line">      <span class="keyword">if</span>(count = N - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果生产者睡眠，唤醒它</span></span><br><span class="line">        notify();                                                            </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go_to_sleep</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        wait( );</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Interr uptedExceptionexc) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中主要设计四个类，外部类(outer class) ProducerConsumer
创建并启动两个线程，p 和 c。第二个类和第三个类 Producer 和 Consumer
分别包含生产者和消费者代码。最后，Our_monitor
是管程，它有两个同步线程，用于在共享缓冲区中插入和取出数据。</p>
<p>在前面的所有例子中，生产者和消费者线程在功能上与它们是相同的。生产者有一个无限循环，该无限循环产生数据并将数据放入公共缓冲区中；消费者也有一个等价的无限循环，该无限循环用于从缓冲区取出数据并完成一系列工作。</p>
<p>程序中比较耐人寻味的就是 Our_monitor
了，它包含缓冲区、管理变量以及两个同步方法。当生产者在 insert
内活动时，它保证消费者不能在 remove
方法中运行，从而保证更新变量以及缓冲区的安全性，并且不用担心竞争条件。变量
count 记录在缓冲区中数据的数量。变量 lo
是缓冲区槽的序号，指出将要取出的下一个数据项。类似地，hi
是缓冲区中下一个要放入的数据项序号。允许 lo = hi，含义是在缓冲区中有 0
个或 N 个数据。</p>
<p>Java 中的同步方法与其他经典管程有本质差别：Java
没有内嵌的条件变量。然而，Java 提供了 wait 和 notify 分别与 sleep 和
wakeup 等价。</p>
<p><strong>通过临界区自动的互斥，管程比信号量更容易保证并行编程的正确性</strong>
。但是管程也有缺点，我们前面说到过管程是一个编程语言的概念，编译器必须要识别管程并用某种方式对其互斥作出保证。C、Pascal
以及大多数其他编程语言都没有管程，所以不能依靠编译器来遵守互斥规则。</p>
<p>与管程和信号量有关的另一个问题是，这些机制都是设计用来解决访问共享内存的一个或多个
CPU 上的互斥问题的。通过将信号量放在共享内存中并用 TSL 或 XCHG
指令来保护它们，可以避免竞争。但是如果是在分布式系统中，可能同时具有多个
CPU 的情况，并且每个 CPU
都有自己的私有内存呢，它们通过网络相连，那么这些原语将会失效。因为信号量太低级了，而管程在少数几种编程语言之外无法使用，所以还需要其他方法。</p>
<h3 id="消息传递">消息传递</h3>
<p>上面提到的其他方法就是 <strong>消息传递(messaage passing)</strong>
。这种进程间通信的方法使用两个原语 <code>send</code> 和
<code>receive</code>
，它们像信号量而不像管程，是系统调用而不是语言级别。示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send(destination, &amp;message);</span><br><span class="line"></span><br><span class="line">receive(source, &amp;message);</span><br></pre></td></tr></table></figure>
<p><code>send</code>
方法用于向一个给定的目标发送一条消息，<code>receive</code>
从一个给定的源接受一条消息。如果没有消息，接受者可能被阻塞，直到接受一条消息或者带着错误码返回。</p>
<h4 id="消息传递系统的设计要点">消息传递系统的设计要点</h4>
<p>消息传递系统现在面临着许多信号量和管程所未涉及的问题和设计难点，尤其对那些在网络中不同机器上的通信状况。例如，消息有可能被网络丢失。为了防止消息丢失，发送方和接收方可以达成一致：一旦接受到消息后，接收方马上回送一条特殊的
<strong>确认(acknowledgement)</strong>
消息。如果发送方在一段时间间隔内未收到确认，则重发消息。</p>
<p>现在考虑消息本身被正确接收，而返回给发送着的确认消息丢失的情况。发送者将重发消息，这样接受者将收到两次相同的消息。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5P00B9"><img
src="https://z3.ax1x.com/2021/10/08/5P00B9.png"
alt="5P00B9.png" /></a></p>
<p>对于接收者来说，如何区分新的消息和一条重发的老消息是非常重要的。通常采用在每条原始消息中嵌入一个连续的序号来解决此问题。如果接受者收到一条消息，它具有与前面某一条消息一样的序号，就知道这条消息是重复的，可以忽略。</p>
<p>消息系统还必须处理如何命名进程的问题，以便在发送或接收调用中清晰的指明进程。<strong>身份验证(authentication)</strong>
也是一个问题，比如客户端怎么知道它是在与一个真正的文件服务器通信，从发送方到接收方的信息有可能被中间人所篡改。</p>
<h4
id="用消息传递解决生产者-消费者问题">用消息传递解决生产者-消费者问题</h4>
<p>现在我们考虑如何使用消息传递来解决生产者-消费者问题，而不是共享缓存。下面是一种解决方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* buffer 中槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100                                                    </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> item;</span><br><span class="line">  <span class="comment">/* buffer 中槽的数量 */</span></span><br><span class="line">  message m;                                                    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 生成放入缓冲区的数据 */</span></span><br><span class="line">    item = <span class="built_in">produce_item</span>();                        </span><br><span class="line">    <span class="comment">/* 等待消费者发送空缓冲区 */</span></span><br><span class="line">    <span class="built_in">receive</span>(consumer,&amp;m);                            </span><br><span class="line">    <span class="comment">/* 建立一个待发送的消息 */</span></span><br><span class="line">    <span class="built_in">build_message</span>(&amp;m,item);                        </span><br><span class="line">    <span class="comment">/* 发送给消费者 */</span></span><br><span class="line">    <span class="built_in">send</span>(consumer,&amp;m);                                </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> item,i;</span><br><span class="line">  message m;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环N次 */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;                        </span><br><span class="line">    <span class="comment">/* 发送N个缓冲区 */</span></span><br><span class="line">    <span class="built_in">send</span>(producer,&amp;m);                                </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 接受包含数据的消息 */</span></span><br><span class="line">    <span class="built_in">receive</span>(producer,&amp;m);                            </span><br><span class="line">    <span class="comment">/* 将数据从消息中提取出来 */</span></span><br><span class="line">      item = <span class="built_in">extract_item</span>(&amp;m);                    </span><br><span class="line">    <span class="comment">/* 将空缓冲区发送回生产者 */</span></span><br><span class="line">    <span class="built_in">send</span>(producer,&amp;m);                                </span><br><span class="line">    <span class="comment">/* 处理数据 */</span></span><br><span class="line">    <span class="built_in">consume_item</span>(item);                                </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设所有的消息都有相同的大小，并且在尚未接受到发出的消息时，由操作系统自动进行缓冲。在该解决方案中共使用
N 条消息，这就类似于一块共享内存缓冲区的 N 个槽。消费者首先将 N
条空消息发送给生产者。当生产者向消费者传递一个数据项时，它取走一条空消息并返回一条填充了内容的消息。通过这种方式，系统中总的消息数量保持不变，所以消息都可以存放在事先确定数量的内存中。</p>
<p>如果生产者的速度要比消费者快，则所有的消息最终都将被填满，等待消费者，生产者将被阻塞，等待返回一条空消息。如果消费者速度快，那么情况将正相反：所有的消息均为空，等待生产者来填充，消费者将被阻塞，以等待一条填充过的消息。</p>
<p>消息传递的方式有许多变体，下面先介绍如何对消息进行
<strong>编址</strong> 。</p>
<ul>
<li><p>一种方法是为每个进程分配一个唯一的地址，让消息按进程的地址编址。</p></li>
<li><p>另一种方式是引入一个新的数据结构，称为
<strong>信箱(mailbox)</strong>
，信箱是一个用来对一定的数据进行缓冲的数据结构，信箱中消息的设置方法也有多种，典型的方法是在信箱创建时确定消息的数量。在使用信箱时，在
send 和 receive
调用的地址参数就是信箱的地址，而不是进程的地址。当一个进程试图向一个满的信箱发送消息时，它将被挂起，直到信箱中有消息被取走，从而为新的消息腾出地址空间。</p></li>
</ul>
<h3 id="屏障">屏障</h3>
<p>最后一个同步机制是准备用于进程组而不是进程间的生产者-消费者情况的。在某些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段，可以通过在每个阶段的结尾安装一个
<strong>屏障(barrier)</strong>
来实现这种行为。当一个进程到达屏障时，它会被屏障所拦截，直到所有的屏障都到达为止。屏障可用于一组进程同步，如下图所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5PDhFI"><img
src="https://z3.ax1x.com/2021/10/08/5PDhFI.png"
alt="5PDhFI.png" /></a></p>
<p>在上图中我们可以看到，有四个进程接近屏障，这意味着每个进程都在进行运算，但是还没有到达每个阶段的结尾。过了一段时间后，A、B、D
三个进程都到达了屏障，各自的进程被挂起，但此时还不能进入下一个阶段呢，因为进程
B 还没有执行完毕。结果，当最后一个 C
到达屏障后，这个进程组才能够进入下一个阶段。</p>
<h3 id="避免锁读-复制-更新">避免锁：读-复制-更新</h3>
<p>最快的锁是根本没有锁。问题在于没有锁的情况下，我们是否允许对共享数据结构的并发读写进行访问。答案当然是不可以。假设进程
A 正在对一个数字数组进行排序，而进程 B 正在计算其平均值，而此时你进行 A
的移动，会导致 B 会多次读到重复值，而某些值根本没有遇到过。</p>
<p>然而，在某些情况下，我们可以允许写操作来更新数据结构，即便还有其他的进程正在使用。窍门在于确保每个读操作要么读取旧的版本，要么读取新的版本，例如下面的树</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5PrJht"><img
src="https://z3.ax1x.com/2021/10/08/5PrJht.png"
alt="5PrJht.png" /></a></p>
<p>上面的树中，读操作从根部到叶子遍历整个树。加入一个新节点 X
后，为了实现这一操作，我们要让这个节点在树中可见之前使它"恰好正确"：我们对节点
X 中的所有值进行初始化，包括它的子节点指针。然后通过原子写操作，使 X
称为 A 的子节点。所有的读操作都不会读到前后不一致的版本</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5Prt9P"><img
src="https://z3.ax1x.com/2021/10/08/5Prt9P.png"
alt="5Prt9P.png" /></a></p>
<p>在上面的图中，我们接着移除 B 和 D。首先，将 A 的左子节点指针指向 C
。所有原本在 A 中的读操作将会后续读到节点 C ，而永远不会读到 B 和
D。也就是说，它们将只会读取到新版数据。同样，所有当前在 B 和 D
中的读操作将继续按照原始的数据结构指针并且读取旧版数据。所有操作均能正确运行，我们不需要锁住任何东西。而不需要锁住数据就能够移除
B 和 D 的主要原因就是
读-复制-更新(Ready-Copy-Update,RCU)，将更新过程中的移除和再分配过程分离开。</p>
<h2 id="调度">调度</h2>
<p>当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争
CPU
时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个
CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做
<strong>调度程序(scheduler)</strong>
的角色存在，它就是做这件事儿的，该程序使用的算法叫做
<strong>调度算法(scheduling algorithm)</strong> 。</p>
<p>尽管有一些不同，但许多适用于进程调度的处理方法同样也适用于线程调度。当内核管理线程的时候，调度通常会以线程级别发生，很少或者根本不会考虑线程属于哪个进程。下面我们会首先专注于进程和线程的调度问题，然后会明确的介绍线程调度以及它产生的问题。</p>
<h3 id="调度介绍">调度介绍</h3>
<p>让我们回到早期以磁带上的卡片作为输入的批处理系统的时代，那时候的调度算法非常简单：依次运行磁带上的每一个作业。对于多道程序设计系统，会复杂一些，因为通常会有多个用户在等待服务。一些大型机仍然将
<code>批处理</code> 和 <code>分时服务</code>
结合使用，需要调度程序决定下一个运行的是一个批处理作业还是终端上的用户。由于在这些机器中
CPU
是稀缺资源，所以好的调度程序可以在提高性能和用户的满意度方面取得很大的成果。</p>
<h4 id="进程行为">进程行为</h4>
<p>几乎所有的进程（磁盘或网络）I/O 请求和计算都是交替运行的</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5PyawQ"><img
src="https://z3.ax1x.com/2021/10/08/5PyawQ.png"
alt="5PyawQ.png" /></a></p>
<p>如上图所示，CPU 不停顿的运行一段时间，然后发出一个系统调用等待 I/O
读写文件。完成系统调用后，CPU
又开始计算，直到它需要读更多的数据或者写入更多的数据为止。当一个进程等待外部设备完成工作而被阻塞时，才是
I/O 活动。</p>
<p>上面 a 是 CPU 密集型进程；b 是 I/O 密集型进程进程，a
因为在计算的时间上花费时间更长，因此称为<strong>计算密集型(compute-bound)</strong>
或者 <strong>CPU 密集型(CPU-bound)</strong> ，b 因为I/O
发生频率比较快因此称为 <strong>I/O 密集型(I/O-bound)</strong>
。计算密集型进程有较长的 CPU 集中使用和较小频度的 I/O 等待。I/O
密集型进程有较短的 CPU 使用时间和较频繁的 I/O
等待。注意到上面两种进程的区分关键在于 CPU 的时间占用而不是 I/O
的时间占用。I/O 密集型的原因是因为它们没有在 I/O
之间花费更多的计算、而不是 I/O
请求时间特别长。无论数据到达后需要花费多少时间，它们都需要花费相同的时间来发出读取磁盘块的硬件请求。</p>
<p>值得注意的是，随着 CPU 的速度越来越快，更多的进程倾向于 I/O
密集型。这种情况出现的原因是 CPU
速度的提升要远远高于硬盘。这种情况导致的结果是，未来对 I/O
密集型进程的调度处理似乎更为重要。这里的基本思想是，如果需要运行 I/O
密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。</p>
<h4 id="何时调度">何时调度</h4>
<p>第一个和调度有关的问题是<strong>何时进行调度决策</strong>
。存在着需要调度处理的各种情形。首先，在创建一个新进程后，需要决定是运行父进程还是子进程。因为二者的进程都处于就绪态下，这是正常的调度决策，可以任意选择，也就是说，调度程序可以任意的选择子进程或父进程开始运行。</p>
<p>第二，在进程退出时需要作出调度决定。因为此进程不再运行（因为它将不再存在），因此必须从就绪进程中选择其他进程运行。如果没有进程处于就绪态，系统提供的空闲进程通常会运行</p>
<blockquote>
<p><strong>什么是空闲进程</strong></p>
</blockquote>
<p><strong>空闲进程(system-supplied idle process)</strong> 是 Microsoft
公司 windows
操作系统带有的系统进程，该进程是在各个处理器上运行的单个线程，它唯一的任务是在系统没有处理其他线程时占用处理器时间。System
Idle Process
并不是一个真正的进程，它是核心虚拟出来的，多任务操作系统都存在。在没有可用的进程时，系统处于空运行状态，此时就是System
Idle Process 在正在运行。你可以简单的理解成，它代表的是 CPU
的空闲状态，数值越大代表处理器越空闲，可以通过 Windows 任务管理器查看
Windows 中的 CPU 利用率。</p>
<p>第三种情况是，当进程阻塞在 I/O
、信号量或其他原因时，必须选择另外一个进程来运行。有时，阻塞的原因会成为选择进程运行的关键因素。例如，如果
A 是一个重要进程，并且它正在等待 B 退出关键区域，让 B 退出关键区域从而使
A 得以运行。但是调度程序一般不会对这种情况进行考量。</p>
<p>第四点，当 I/O 中断发生时，可以做出调度决策。如果中断来自 I/O
设备，而 I/O 设备已经完成了其工作，那么那些等待 I/O
的进程现在可以继续运行。由调度程序来决定是否准备运行新的进程还是重新运行已经中断的进程。</p>
<p>如果硬件时钟以 50 或 60 Hz
或其他频率提供周期性中断，可以在每个时钟中断或第 k
个时钟中断处做出调度决策。根据如何处理时钟中断可以把调度算法可以分为两类。非抢占式(nonpreemptive)
调度算法挑选一个进程，让该进程运行直到被阻塞（阻塞在 I/O
上或等待另一个进程），或者直到该进程自动释放
CPU。即使该进程运行了若干个小时后，它也不会被强制挂起。这样会在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待，则被中断的进程会继续执行。</p>
<p>另外一种情况是 <strong>抢占式</strong>
调度算法，它会选择一个进程，并使其在最大固定时间内运行。如果在时间间隔结束后仍在运行，这个进程会被挂起，调度程序会选择其他进程来运行（前提是存在就绪进程）。进行抢占式调度需要在时间间隔结束时发生时钟中断，以将
CPU
的控制权交还给调度程序。如果没有可用的时钟，那么非抢占式就是唯一的选择。</p>
<h4 id="调度算法的分类">调度算法的分类</h4>
<p>毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</p>
<ul>
<li><p>批处理(Batch)</p></li>
<li><p>交互式(Interactive)</p></li>
<li><p>实时(Real time)</p></li>
</ul>
<p>批处理系统广泛应用于商业领域，比如用来处理工资单、存货清单、账目收入、账目支出、利息计算、索赔处理和其他周期性作业。在批处理系统中，一般会选择使用非抢占式算法或者周期性比较长的抢占式算法。这种方法可以减少线程切换因此能够提升性能。</p>
<p>在交互式用户环境中，为了避免一个进程霸占 CPU
拒绝为其他进程服务，所以需要抢占式算法。即使没有进程有意要一直运行下去，但是，由于某个进程出现错误也有可能无限期的排斥其他所有进程。为了避免这种情况，抢占式也是必须的。服务器也属于此类别，因为它们通常为多个（远程）用户提供服务，而这些用户都非常着急。计算机用户总是很忙。</p>
<p>在实时系统中，抢占有时是不需要的，因为进程知道自己可能运行不了很长时间，通常很快的做完自己的工作并阻塞。实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。</p>
<h4 id="调度算法的目标">调度算法的目标</h4>
<p>为了设计调度算法，有必要考虑一下什么是好的调度算法。有一些目标取决于环境（批处理、交互式或者实时）蛋大部分是适用于所有情况的，下面是一些需要考量的因素，我们会在下面一起讨论。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5P6Ekj"><img
src="https://z3.ax1x.com/2021/10/08/5P6Ekj.png"
alt="5P6Ekj.png" /></a></p>
<ul>
<li>所有系统</li>
</ul>
<p>在所有的情况中，公平是很重要的。对一个进程给予相较于其他等价的进程更多的
CPU
时间片对其他进程来说是不公平的。当然，不同类型的进程可以采用不同的处理方式。</p>
<p>与公平有关的是系统的强制执行，什么意思呢？如果某公司的薪资发放系统计划在本月的15号，那么碰上了疫情大家生活都很拮据，此时老板说要在14号晚上发放薪资，那么调度程序必须强制使进程执行
14 号晚上发放薪资的策略。</p>
<p>另一个共同的目标是保持系统的所有部分尽可能的忙碌。如果 CPU 和所有的
I/O
设备能够一直运行，那么相对于让某些部件空转而言，每秒钟就可以完成更多的工作。例如，在批处理系统中，调度程序控制哪个作业调入内存运行。在内存中既有一些
CPU 密集型进程又有一些 I/O
密集型进程是一个比较好的想法，好于先调入和运行所有的 CPU
密集型作业，然后在它们完成之后再调入和运行所有 I/O
密集型作业的做法。使用后者这种方式会在 CPU 密集型进程启动后，争夺 CPU
，而磁盘却在空转，而当 I/O 密集型进程启动后，它们又要为磁盘而竞争，CPU
却又在空转。。。。。。显然，通过结合 I/O 密集型和 CPU
密集型，能够使整个系统运行更流畅，效率更高。</p>
<ul>
<li>批处理系统</li>
</ul>
<p>通常有三个指标来衡量系统工作状态：吞吐量、周转时间和 CPU
利用率，吞吐量(throughout)
是系统每小时完成的作业数量。综合考虑，每小时完成 50 个工作要比每小时完成
40 个工作好。周转时间(Turnaround time)
是一种平均时间，它指的是从一个批处理提交开始直到作业完成时刻为止平均时间。该数据度量了用户要得到输出所需的平均等待时间。周转时间越小越好。</p>
<p>CPU 利用率(CPU utilization) 通常作为批处理系统上的指标。即使如此，
CPU
利用率也不是一个好的度量指标，真正有价值的衡量指标是系统每小时可以完成多少作业（吞吐量），以及完成作业需要多长时间（周转时间）。把
CPU
利用率作为度量指标，就像是引擎每小时转动了多少次来比较汽车的性能一样。而且知道
CPU 的利用率什么时候接近 100%
要比什么什么时候要求得到更多的计算能力要有用。</p>
<ul>
<li>交互式系统</li>
</ul>
<p>对于交互式系统，则有不同的指标。最重要的是尽量减少响应时间。这个时间说的是从执行指令开始到得到结果的时间。再有后台进程运行（例如，从网络上读取和保存
E-mail
文件）的个人计算机上，用户请求启动一个程序或打开一个文件应该优先于后台的工作。能够让所有的交互式请求首先运行的就是一个好的服务。</p>
<p>一个相关的问题是
均衡性(proportionality)，用户对做一件事情需要多长时间总是有一种固定（不过通常不正确）的看法。当认为一个请求很复杂需要较多时间时，用户会认为很正常并且可以接受，但是一个很简单的程序却花费了很长的运行时间，用户就会很恼怒。可以拿彩印和复印来举出一个简单的例子，彩印可能需要1分钟的时间，但是用户觉得复杂并且愿意等待一分钟，相反，复印很简单只需要
5 秒钟，但是复印机花费 1 分钟却没有完成复印操作，用户就会很焦躁。</p>
<ul>
<li>实时系统</li>
</ul>
<p>实时系统则有着和交互式系统不同的考量因素，因此也就有不同的调度目标。实时系统的特点是必须满足最后的截止时间。例如，如果计算机控制着以固定速率产生数据的设备，未能按时运行的话可能会导致数据丢失。因此，实时系统中最重要的需求是满足所有（或大多数）时间期限。</p>
<p>在一些实时系统中，特别是涉及到多媒体的，可预测性很重要。偶尔不能满足最后的截止时间不重要，但是如果音频多媒体运行不稳定，声音质量会持续恶化。视频也会造成问题，但是耳朵要比眼睛敏感很多。为了避免这些问题，进程调度必须能够高度可预测的而且是有规律的。</p>
<h3 id="批处理中的调度">批处理中的调度</h3>
<p>现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</p>
<h4 id="先来先服务">先来先服务</h4>
<p>可能最简单的非抢占式调度算法的设计就是
<strong>先来先服务(first-come,first-serverd)</strong>
。使用此算法，将按照请求顺序为进程分配
CPU。最基本的，会有一个就绪进程的等待队列。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5P6y4A"><img
src="https://z3.ax1x.com/2021/10/08/5P6y4A.png"
alt="5P6y4A.png" /></a></p>
<p>这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p>
<p>不过，先来先服务也是有缺点的，那就是没有优先级的关系，试想一下，如果有
100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等
100 个 I/O 进程运行完毕才会等到一个 CPU
密集型进程运行，这在实际情况下根本不可能，所以需要优先级或者抢占式进程的出现来优先选择重要的进程运行。</p>
<h4 id="最短作业优先">最短作业优先</h4>
<p>批处理中，第二种调度算法是 <strong>最短作业优先(Shortest Job
First)</strong>
，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理
1000
个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5P6oNj"><img
src="https://z3.ax1x.com/2021/10/08/5P6oNj.png"
alt="5P6oNj.png" /></a></p>
<p>如上图 a 所示，这里有 4 个作业 A、B、C、D ，运行时间分别为 8、4、4、4
分钟。若按图中的次序运行，则 A 的周转时间为 8 分钟，B 为 12 分钟，C 为
16 分钟，D 为 20 分钟，平均时间内为 14 分钟。</p>
<p>现在考虑使用最短作业优先算法运行 4 个作业，如上图 b
所示，目前的周转时间分别为 4、8、12、20，平均为 11
分钟，可以证明最短作业优先是最优的。考虑有 4
个作业的情况，其运行时间分别为 a、b、c、d。第一个作业在时间 a
结束，第二个在时间 a + b 结束，以此类推。平均周转时间为 (4a + 3b + 2c +
d) / 4 。显然 a 对平均值的影响最大，所以 a 应该是最短优先作业，其次是
b，然后是 c ，最后是 d 它就只能影响自己的周转时间了。</p>
<blockquote>
<p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p>
</blockquote>
<h4 id="最短剩余时间优先">最短剩余时间优先</h4>
<p>最短作业优先的抢占式版本被称作为 <strong>最短剩余时间优先(Shortest
Remaining Time Next)</strong>
算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。</p>
<h3 id="交互式系统中的调度">交互式系统中的调度</h3>
<p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p>
<h4 id="轮询调度">轮询调度</h4>
<p>一种最古老、最简单、最公平并且最广泛使用的算法就是
<strong>轮询算法(round-robin)</strong>
。每个进程都会被分配一个时间段，称为 <strong>时间片(quantum)</strong>
，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个
CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU
立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的
a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5PoR0I"><img
src="https://z3.ax1x.com/2021/10/08/5PoR0I.png"
alt="5PoR0I.png" /></a></p>
<p>时间片轮询调度中唯一有意思的一点就是时间片的长度。从一个进程切换到另一个进程需要一定的时间进行管理处理，包括保存寄存器的值和内存映射、更新不同的表格和列表、清除和重新调入内存高速缓存等。这种切换称作
<strong>进程间切换(process switch)</strong> 和
<strong>上下文切换(context switch)</strong> 。如果进程间的切换时间需要
1ms，其中包括内存映射、清除和重新调入高速缓存等，再假设时间片设为 4
ms，那么 CPU 在做完 4 ms 有用的工作之后，CPU 将花费 1 ms
来进行进程间的切换。因此，CPU 的时间片会浪费 20%
的时间在管理开销上。耗费巨大。</p>
<p>为了提高 CPU 的效率，我们把时间片设置为 100 ms。现在时间的浪费只有
1%。但是考虑会发现下面的情况，如果在一个非常短的时间内到达 50
个请求，并且对 CPU 有不同的需求，此时会发生什么？50
个进程都被放在可运行进程列表中。如果 CPU
是空闲的，第一个进程会立即开始执行，第二个直到 100 ms
以后才会启动，以此类推。不幸的是最后一个进程需要等待 5
秒才能获得执行机会。大部分用户都会觉得对于一个简短的指令运行 5
秒中是很慢的。如果队列末尾的某些请求只需要几毫秒钟的运行时间的话，这种设计就非常糟糕了。</p>
<p>另外一个因素是如果时间片设置长度要大于 CPU
使用长度，那么抢占就不会经常发生。相反，在时间片用完之前，大多数进程都已经阻塞了，那么就会引起进程间的切换。消除抢占可提高性能，因为进程切换仅在逻辑上必要时才发生，即流程阻塞且无法继续时才发生。</p>
<p>结论可以表述如下：将上下文切换时间设置得太短会导致过多的进程切换并降低
CPU
效率，但设置时间太长会导致一个短请求很长时间得不到响应。最好的切换时间是在
20 - 50 毫秒之间设置。</p>
<h4 id="优先级调度">优先级调度</h4>
<p>轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<strong>优先级调度(priority
scheduling)</strong></p>
<p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p>
<p>但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。</p>
<p>可以静态或者动态的为进程分配优先级。在一台军用计算机上，可以把将军所启动的进程设为优先级
100，上校为 90 ，少校为 80，上尉为 70，中尉为 60，以此类推。UNIX
中有一条命令为 nice
，它允许用户为了照顾他人而自愿降低自己进程的优先级，但是一般没人用。</p>
<p>优先级也可以由系统动态分配，用于实现某种目的。例如，有些进程为 I/O
密集型，其多数时间用来等待 I/O 结束。当这样的进程需要 CPU 时，应立即分配
CPU，用来启动下一个 I/O 请求，这样就可以在另一个进程进行计算的同时执行
I/O 操作。这类 I/O 密集型进程长时间的等待 CPU
只会造成它长时间占用内存。使 I/O
密集型进程获得较好的服务的一种简单算法是，将其优先级设为 1/f，f
为该进程在上一时间片中所占的部分。一个在 50 ms 的时间片中只使用 1 ms
的进程将获得优先级 50 ，而在阻塞之前用掉 25 ms 的进程将具有优先级
2，而使用掉全部时间片的进程将得到优先级 1。</p>
<p>可以很方便的将一组进程按优先级分成若干类，并且在各个类之间采用优先级调度，而在各类进程的内部采用轮转调度。下面展示了一个四个优先级类的系统</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5P7Erj"><img
src="https://z3.ax1x.com/2021/10/08/5P7Erj.png"
alt="5P7Erj.png" /></a></p>
<p>它的调度算法主要描述如下：上面存在优先级为 4
类的可运行进程，首先会按照轮转法为每个进程运行一个时间片，此时不理会较低优先级的进程。若第
4 类进程为空，则按照轮询的方式运行第三类进程。若第 4 类和第 3
类进程都为空，则按照轮转法运行第 2
类进程。如果不对优先级进行调整，则低优先级的进程很容易产生饥饿现象。</p>
<h4 id="多级队列">多级队列</h4>
<p>最早使用优先级调度的系统是 <strong>CTSS(Compatible TimeSharing
System)</strong> 。CTSS
是一种兼容分时系统，它有一个问题就是进程切换太慢，其原因是 IBM 7094
内存只能放进一个进程。</p>
<p>CTSS
在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。CTSS
的设计者很快就认识到，为 CPU
密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行
2 个时间片，再下面一级运行 4
个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</p>
<h4 id="最短进程优先">最短进程优先</h4>
<p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互式进程，那将是非常好的。在某种程度上，的确可以做到这一点。交互式进程通常遵循下列模式：等待命令、执行命令、等待命令、执行命令。。。如果我们把每个命令的执行都看作一个分离的作业，那么我们可以通过首先运行最短的作业来使响应时间最短。这里唯一的问题是如何从当前可运行进程中找出最短的那一个进程。</p>
<p>一种方式是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为
T0，现在假设测量到其下一次运行时间为
T1，可以用两个值的加权来改进估计时间，即aT0+ (1- 1)T1。通过选择 a
的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当
a = 1/2 时，可以得到下面这个序列</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5P7YZR"><img
src="https://z3.ax1x.com/2021/10/08/5P7YZR.png"
alt="5P7YZR.png" /></a></p>
<p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p>
<p>有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作
老化(aging)。这种方法会使用很多预测值基于当前值的情况。</p>
<h4 id="保证调度">保证调度</h4>
<p>一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有
n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n
个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的
CPU 时间。</p>
<h4 id="彩票调度">彩票调度</h4>
<p>对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是
彩票调度(lottery scheduling)算法。</p>
<p>其基本思想是为进程提供各种系统资源（例如 CPU
时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到
CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的
CPU 时间作为奖励。</p>
<p>George Orwell 关于
所有的进程是平等的，但是某些进程能够更平等一些。一些重要的进程可以给它们额外的彩票，以便增加他们赢得的机会。如果出售了
100 张彩票，而且有一个进程持有了它们中的 20 张，它就会有 20%
的机会去赢得彩票中奖。在长时间的运行中，它就会获得 20%
的CPU。相反，对于优先级调度程序，很难说明拥有优先级 40
究竟是什么意思，这里的规则很清楚，拥有彩票 f
份额的进程大约得到系统资源的 f 份额。</p>
<p>如果希望进程之间协作的话可以交换它们之间的票据。例如，客户端进程给服务器进程发送了一条消息后阻塞，客户端进程可能会把自己所有的票据都交给服务器，来增加下一次服务器运行的机会。当服务完成后，它会把彩票还给客户端让其有机会再次运行。事实上，如果没有客户机，服务器也根本不需要彩票。</p>
<blockquote>
<p>可以把彩票理解为 buff，这个 buff 有 15% 的几率能让你产生 速度之靴
的效果。</p>
</blockquote>
<h4 id="公平分享调度">公平分享调度</h4>
<p>到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户
1 启动了 9 个进程，而用户 2
启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的
CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p>
<p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU
时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的
CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU
份额。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5P7fW8"><img
src="https://z3.ax1x.com/2021/10/08/5P7fW8.png"
alt="5P7fW8.png" /></a></p>
<h3 id="实时系统中的调度">实时系统中的调度</h3>
<p>实时系统(real-time)
是一个时间扮演了重要作用的系统。典型的，一种或多种外部物理设备发给计算机一个服务请求，而计算机必须在一个确定的时间范围内恰当的做出反应。例如，在
CD
播放器中的计算机会获得从驱动器过来的位流，然后必须在非常短的时间内将位流转换为音乐播放出来。如果计算时间过长，那么音乐就会听起来有异常。再比如说医院特别护理部门的病人监护装置、飞机中的自动驾驶系统、列车中的烟雾警告装置等，在这些例子中，正确但是却缓慢的响应要比没有响应甚至还糟糕。</p>
<p>实时系统可以分为两类，硬实时(hard real time) 和 软实时(soft real
time)
系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。在这两种情形中，实时都是通过把程序划分为一组进程而实现的，其中每个进程的行为是可预测和提前可知的。这些进程一般寿命较短，并且极快的运行完成。在检测到一个外部信号时，调度程序的任务就是按照满足所有截止时间的要求调度进程。</p>
<p>实时系统中的事件可以按照响应方式进一步分类为周期性(以规则的时间间隔发生)事件或
非周期性(发生时间不可预知)事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有
m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU
时间处理一个事件，那么可以处理负载的条件是</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5P7LF0"><img
src="https://z3.ax1x.com/2021/10/08/5P7LF0.png"
alt="5P7LF0.png" /></a></p>
<p>只有满足这个条件的实时系统称为可调度的，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的
CPU 时间总和大于 CPU 能提供的时间。</p>
<p>举一个例子，考虑一个有三个周期性事件的软实时系统，其周期分别是 100
ms、200 m 和 500 ms。如果这些事件分别需要 50 ms、30 ms 和 100 ms 的 CPU
时间，那么该系统时可调度的，因为 0.5 + 0.15 + 0.2 &lt;
1。如果此时有第四个事件加入，其周期为 1 秒，那么此时这个事件如果不超过
150 ms，那么仍然是可以调度的。忽略上下文切换的时间。</p>
<p>实时系统的调度算法可以是静态的或动态的。前者在系统开始运行之前做出调度决策；后者在运行过程中进行调度决策。只有在可以提前掌握所完成的工作以及必须满足的截止时间等信息时，静态调度才能工作，而动态调度不需要这些限制。</p>
<h3 id="调度策略和机制">调度策略和机制</h3>
<p>到目前为止，我们隐含的假设系统中所有进程属于不同的分组用户并且进程间存在相互竞争
CPU
的情况。通常情况下确实如此，但有时也会发生一个进程会有很多子进程并在其控制下运行的情况。例如，一个数据库管理系统进程会有很多子进程。每一个子进程可能处理不同的请求，或者每个子进程实现不同的功能（如请求分析、磁盘访问等）。主进程完全可能掌握哪一个子进程最重要（或最紧迫），而哪一个最不重要。但是，以上讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。</p>
<p>解决问题的办法是将 调度机制(scheduling mechanism) 和
调度策略(scheduling policy)
分开，这是长期一贯的原则。这也就意味着调度算法在某种方式下被参数化了，但是参数可以被用户进程填写。让我们首先考虑数据库的例子。假设内核使用优先级调度算法，并提供了一条可供进程设置优先级的系统调用。这样，尽管父进程本身并不参与调度，但它可以控制如何调度子进程的细节。调度机制位于内核，而调度策略由用户进程决定，调度策略和机制分离是一种关键性思路。</p>
<h3 id="线程调度">线程调度</h3>
<p>当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。在这样的系统中调度处理有本质的差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。</p>
<p>首先考虑用户级线程，由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，假设为
A，并给予 A 以时间片控制。A 中的线程调度程序决定哪个线程运行。假设为
A1。由于多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片，内核就会选择另一个进程继续运行。</p>
<p>在进程 A 终于又一次运行时，线程 A1 会接着运行。该线程会继续耗费 A
进程的所有时间，直到它完成工作。不过，线程运行不会影响到其他进程。其他进程会得到调度程序所分配的合适份额，不会考虑进程
A 内部发生的事情。</p>
<p>现在考虑 A 线程每次 CPU 计算的工作比较少的情况，例如：在 50 ms
的时间片中有 5 ms 的计算工作。于是，每个线程运行一会儿，然后把 CPU
交回给线程调度程序。这样在内核切换到进程 B 之前，就会有序列
A1,A2,A3,A1,A2,A3,A1,A2,A3,A1 。 如下所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5PHVSO"><img
src="https://z3.ax1x.com/2021/10/08/5PHVSO.png"
alt="5PHVSO.png" /></a></p>
<p>运行时系统使用的调度算法可以是上面介绍算法的任意一种。从实用方面考虑，轮转调度和优先级调度更为常用。唯一的局限是，缺乏一个时钟中断运行过长的线程。但由于线程之间的合作关系，这通常也不是问题。</p>
<p>现在考虑使用内核线程的情况，内核选择一个特定的线程运行。它不用考虑线程属于哪个进程，不过如果有必要的话，也可以这么做。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。一个线程在
50 ms 的时间片内，5 ms 之后被阻塞，在 30 ms 的时间片中，线程的顺序会是
A1,B1,A2,B2,A3,B3。如下图所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5PH0kq"><img
src="https://z3.ax1x.com/2021/10/08/5PH0kq.png"
alt="5PH0kq.png" /></a></p>
<p>用户级线程和内核级线程之间的主要差别在于性能。用户级线程的切换需要少量的机器指令（想象一下Java程序的线程切换），而内核线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这会导致了若干数量级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在
I/O 上就不需要在用户级线程中那样将整个进程挂起。</p>
<p>从进程 A 的一个线程切换到进程 B 的一个线程，其消耗要远高于运行进程 A
的两个线程（涉及修改内存映像，修改高速缓存），内核对这种切换的消耗是了解到，可以通过这些信息作出决定。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" rel="prev" title="操作系统笔记（三）">
      <i class="fa fa-chevron-left"></i> 操作系统笔记（三）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="操作系统学习笔记">
      操作系统学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.</span> <span class="nav-text">计算机硬件简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu"><span class="nav-number">1.2.1.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E6%A0%B8%E8%8A%AF%E7%89%87"><span class="nav-number">1.2.2.</span> <span class="nav-text">多线程和多核芯片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">高速缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">主存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98"><span class="nav-number">1.2.4.</span> <span class="nav-text">磁盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io-%E8%AE%BE%E5%A4%87"><span class="nav-number">1.2.5.</span> <span class="nav-text">I&#x2F;O 设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-number">1.2.6.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.7.</span> <span class="nav-text">计算机启动过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.</span> <span class="nav-text">操作系统概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.3.2.</span> <span class="nav-text">地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.3.</span> <span class="nav-text">文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.3.4.</span> <span class="nav-text">保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shell"><span class="nav-number">1.3.5.</span> <span class="nav-text">shell</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">用于进程管理的系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">用于文件管理的系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">用于目录管理的系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.4.</span> <span class="nav-text">其他系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#win32-api"><span class="nav-number">1.4.5.</span> <span class="nav-text">Win32 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">操作系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.5.1.</span> <span class="nav-text">单体系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">分层系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="nav-number">1.5.3.</span> <span class="nav-text">微内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.4.</span> <span class="nav-text">客户-服务器模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-1"><span class="nav-number">2.1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9D%97"><span class="nav-number">2.1.1.</span> <span class="nav-text">进程模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.2.</span> <span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">系统初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">系统调用创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">用户请求创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">批处理创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-number">2.1.3.</span> <span class="nav-text">进程的终止</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E9%80%80%E5%87%BA"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">正常退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E9%80%80%E5%87%BA"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">错误退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A5%E9%87%8D%E9%94%99%E8%AF%AF"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">严重错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A2%AB%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E6%9D%80%E6%AD%BB"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">被其他进程杀死</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.4.</span> <span class="nav-text">进程的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unix-%E8%BF%9B%E7%A8%8B%E4%BD%93%E7%B3%BB"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">UNIX 进程体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#windows-%E8%BF%9B%E7%A8%8B%E4%BD%93%E7%B3%BB"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">Windows 进程体系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.5.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.6.</span> <span class="nav-text">进程的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">线程的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">多线程解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">单线程解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">状态机解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text">经典的线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">线程系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#posix-%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.3.</span> <span class="nav-text">POSIX 线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.4.</span> <span class="nav-text">线程实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">在用户空间中实现线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">在内核中实现线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">混合实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">2.3.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.3.1.</span> <span class="nav-text">竞态条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">2.3.2.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%99%E7%AD%89%E5%BE%85%E4%BA%92%E6%96%A5"><span class="nav-number">2.3.3.</span> <span class="nav-text">忙等待互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">屏蔽中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%8F%98%E9%87%8F"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">锁变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E8%BD%AE%E8%AF%A2%E6%B3%95"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">严格轮询法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#peterson-%E8%A7%A3%E6%B3%95"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">Peterson 解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tsl-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.3.3.5.</span> <span class="nav-text">TSL 指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92"><span class="nav-number">2.3.4.</span> <span class="nav-text">睡眠与唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">生产者-消费者问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.3.5.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85---%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">用信号量解决生产者 -
消费者问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">2.3.6.</span> <span class="nav-text">互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#futexes"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">Futexes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthreads-%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">Pthreads 中的互斥量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">2.3.7.</span> <span class="nav-text">管程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">2.3.8.</span> <span class="nav-text">消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9"><span class="nav-number">2.3.8.1.</span> <span class="nav-text">消息传递系统的设计要点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.8.2.</span> <span class="nav-text">用消息传递解决生产者-消费者问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E9%9A%9C"><span class="nav-number">2.3.9.</span> <span class="nav-text">屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%94%81%E8%AF%BB-%E5%A4%8D%E5%88%B6-%E6%9B%B4%E6%96%B0"><span class="nav-number">2.3.10.</span> <span class="nav-text">避免锁：读-复制-更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.</span> <span class="nav-text">调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.4.1.</span> <span class="nav-text">调度介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">进程行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">何时调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">调度算法的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">调度算法的目标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.2.</span> <span class="nav-text">批处理中的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">先来先服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">最短作业优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">最短剩余时间优先</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.3.</span> <span class="nav-text">交互式系统中的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">轮询调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">优先级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">多级队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">最短进程优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.3.5.</span> <span class="nav-text">保证调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.3.6.</span> <span class="nav-text">彩票调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E5%88%86%E4%BA%AB%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.3.7.</span> <span class="nav-text">公平分享调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.4.</span> <span class="nav-text">实时系统中的调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">2.4.5.</span> <span class="nav-text">调度策略和机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.6.</span> <span class="nav-text">线程调度</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

