<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="如果我们不能结婚 你怎么受得了 宝贝 我知道 虽然你不说。如果我们就要结婚 我怎么能受得了 宝贝 别在夜里等我">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="如果我们不能结婚 你怎么受得了 宝贝 我知道 虽然你不说。如果我们就要结婚 我怎么能受得了 宝贝 别在夜里等我">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.470Z">
<meta property="article:modified_time" content="2022-03-09T09:29:11.173Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-09 17:29:11" itemprop="dateModified" datetime="2022-03-09T17:29:11+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">如果我们不能结婚 你怎么受得了 宝贝 我知道 虽然你不说。如果我们就要结婚 我怎么能受得了 宝贝 别在夜里等我</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="tcp与udp的区别">TCP与UDP的区别</h1>
<p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和
UDP，介绍下这两者以及它们之间的区别。</p>
<h2 id="tcpip网络模型">TCP/IP网络模型</h2>
<p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为<strong>协议（protocol）</strong>。</p>
<p><strong>TCP/IP</strong>
是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP
等都属于 TCP/IP 族内的协议。</p>
<p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<ul>
<li><strong>链路层</strong>：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li>
<li><strong>网络层</strong>：负责路由以及把分组报文发送给目标网络或主机。</li>
<li><strong>传输层</strong>：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li>
<li><strong>应用层</strong>：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oGZg9e"><img
src="https://z3.ax1x.com/2021/12/01/oGZg9e.md.png"
alt="oGZg9e.md.png" /></a></p>
<p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。
在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP
中有两个具有代表性的传输层协议----<strong>TCP</strong> 和
<strong>UDP</strong>。</p>
<h2 id="udp">UDP</h2>
<p><strong>UDP协议</strong>全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它有以下几个特点：</p>
<ol type="1">
<li><strong>面向无连接</strong></li>
</ol>
<ul>
<li><p>首先 UDP 是不需要和 TCP
一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP
只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了。</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP
报文头就传递给应用层，不会任何拼接操作。</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>有单播，多播，广播的功能</strong></li>
</ol>
<ul>
<li>UDP
不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说
UDP 提供了单播，多播，广播的功能。</li>
</ul>
<ol start="3" type="1">
<li><strong>UDP是面向报文的</strong></li>
</ol>
<ul>
<li>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。</li>
</ul>
<ol start="4" type="1">
<li><strong>不可靠性</strong></li>
</ol>
<ul>
<li><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p></li>
<li><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p></li>
<li><p>再者网络环境时好时坏，但是 UDP
因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用
UDP 而不是 TCP。</p></li>
</ul>
<p>UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p>
<ol start="5" type="1">
<li><strong>头部开销小，传输数据报文时是很高效的。</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oGKcy4"><img
src="https://z3.ax1x.com/2021/12/01/oGKcy4.png"
alt="oGKcy4.png" /></a></p>
<ul>
<li><p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选
字段），该字段用于发现头部信息和数据中的错误</li>
</ul></li>
<li><p>因此 UDP 的头部开销小，只有八字节，相比 TCP
的至少二十字节要少得多，在传输数据报文时是很高效的。</p></li>
</ul>
<h2 id="tcp">TCP</h2>
<p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。</p>
<p><strong>TCP协议</strong>全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由
IETF 的RFC 793定义。<strong>TCP
是面向连接的、可靠的流协议</strong>。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p>
<h3 id="tcp连接过程">TCP连接过程</h3>
<p>如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oGMdje"><img
src="https://z3.ax1x.com/2021/12/01/oGMdje.png"
alt="oGMdje.png" /></a></p>
<p><strong>第一次握手</strong></p>
<p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入
SYN-SENT 状态。</p>
<p><strong>第二次握手</strong></p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入
SYN-RECEIVED 状态。</p>
<p><strong>第三次握手</strong></p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入
ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED
状态，此时连接建立成功。</p>
<p>这里可能大家会有个疑惑：为什么 TCP
建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p>
<h3 id="tcp断开链接">TCP断开链接</h3>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oGJl2q"><img
src="https://z3.ax1x.com/2021/12/01/oGJl2q.png"
alt="oGJl2q.png" /></a></p>
<p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p>
<p><strong>第一次握手</strong></p>
<p>若客户端 A 认为数据发送完成，则它需要向服务端 B
发送连接释放请求。</p>
<p><strong>第二次握手</strong></p>
<p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK
包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A
发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p>
<p><strong>第三次握手</strong></p>
<p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A
发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p>
<p><strong>第四次握手</strong></p>
<p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT
状态。该状态会持续
2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）
时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B
收到确认应答后，也便进入 CLOSED 状态。</p>
<h3 id="tcp协议的特点">TCP协议的特点</h3>
<ol type="1">
<li><strong>面向连接</strong></li>
</ol>
<ul>
<li>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</li>
</ul>
<ol start="2" type="1">
<li><strong>仅支持单播传输</strong></li>
</ol>
<ul>
<li>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</li>
</ul>
<ol start="3" type="1">
<li><strong>面向字节流</strong></li>
</ol>
<ul>
<li>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</li>
</ul>
<ol start="4" type="1">
<li><strong>可靠传输</strong></li>
</ol>
<ul>
<li>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</li>
</ul>
<ol start="5" type="1">
<li><strong>提供拥塞控制</strong></li>
</ol>
<ul>
<li>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</li>
</ul>
<ol start="6" type="1">
<li><strong>TCP提供全双工通信</strong></li>
</ol>
<ul>
<li>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</li>
</ul>
<h2 id="tcp和udp的比较">TCP和UDP的比较</h2>
<ol type="1">
<li><strong>对比</strong></li>
</ol>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">UDP</th>
<th style="text-align: center;">TCP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">是否连接</td>
<td style="text-align: center;">无连接</td>
<td style="text-align: center;">面向连接</td>
</tr>
<tr class="even">
<td style="text-align: center;">是否可靠</td>
<td
style="text-align: center;">不可靠传输，不使用流量控制和拥塞控制</td>
<td style="text-align: center;">可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr class="odd">
<td style="text-align: center;">连接对象个数</td>
<td
style="text-align: center;">支持一对一，一对多，多对一和多对多交互通信</td>
<td style="text-align: center;">只能是一对一通信</td>
</tr>
<tr class="even">
<td style="text-align: center;">传输方式</td>
<td style="text-align: center;">面向报文</td>
<td style="text-align: center;">面向字节流</td>
</tr>
<tr class="odd">
<td style="text-align: center;">首部开销</td>
<td style="text-align: center;">首部开销小，仅8字节</td>
<td style="text-align: center;">首部最小20字节，最大60字节</td>
</tr>
<tr class="even">
<td style="text-align: center;">适用场景</td>
<td
style="text-align: center;">适用于实时应用（IP电话、视频会议、直播等）</td>
<td
style="text-align: center;">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li><strong>总结</strong></li>
</ol>
<ul>
<li>TCP向上层提供面向连接的可靠服务
，UDP向上层提供无连接不可靠服务。</li>
<li>虽然 UDP 并没有 TCP
传输来的准确，但是也能在很多实时性要求高的地方有所作为。</li>
<li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP。</li>
</ul>
<h2 id="tcp与udp区别总结">TCP与UDP区别总结</h2>
<ol type="1">
<li><strong>TCP面向连接</strong> （如打电话要先拨号建立连接）;
<strong>UDP是无连接的</strong>，即发送数据之前不需要建立连接。</li>
<li><strong>TCP提供可靠的服务</strong>。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;<strong>UDP尽最大努力交付，即不保证可靠交付</strong>。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li><strong>UDP具有较好的实时性</strong>，工作效率比TCP高，适用于对高速传输和实时性有较高要求的通信或广播通信。</li>
<li>每一条<strong>TCP</strong>连接只能是<strong>一对一通信</strong>;<strong>UDP支持一对一，一对多，多对一和多对多的交互通信</strong>。</li>
<li><strong>TCP</strong>对系统资源要求较多，<strong>UDP</strong>对系统资源要求较少。</li>
</ol>
<h1 id="为什么udp有时比tcp更有优势">为什么UDP有时比TCP更有优势</h1>
<p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。</p>
<ol type="1">
<li>网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</li>
<li>TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。</li>
</ol>
<p>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p>
<h1 id="详解tcp三次握手四次握手">详解TCP三次握手、四次握手</h1>
<h2 id="tcp-报文段简介">TCP 报文段简介</h2>
<p>在介绍三次握手和四次挥手之前，先来简单认识一下 TCP 报文段的结构</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oJfQXV"><img
src="https://z3.ax1x.com/2021/12/01/oJfQXV.md.png"
alt="oJfQXV.md.png" /></a></p>
<p><strong>TCP
首部</strong>包含以下内容，请留意其中的<strong>控制位</strong>，在三次握手和四次挥手过程中会频繁出现：</p>
<ul>
<li><p><strong>端口号 (Source Port and Destination Port)</strong>：每个
TCP
报文段都包含源端和目的端的端口号，用于寻找发送端和接收端应用进程。这两个值加上
IP 首部中的源端 IP 地址和目的端 IP 地址就可以确定一个唯一的 TCP
连接。</p></li>
<li><p><strong>序号 (Sequence
Number)</strong>：这个字段的主要作用是用于将失序的数据重新排列。TCP
会隐式地对字节流中的每个字节进行编号，而 TCP
报文段的序号被设置为其数据部分的第一个字节的编号。序号是 32 bit
的无符号数，取值范围是0到 232 - 1。</p></li>
<li><p><strong>确认序号 (Acknowledgment
Number)</strong>：接收方在接受到数据后，会回复确认报文，其中包含确认序号，作用就是告诉发送方自己接收到了哪些数据，下一次数据从哪里开始发，因此，确认序号应当是上次已成功收到数据字节序号加
1。只有 ACK 标志为 1 时确认序号字段才有效。</p></li>
<li><p><strong>首部长度 (Header
Length)</strong>：首部中的选项部分的长度是可变的，因此首部的长度也是可变的，所以需要这个字段来明确表示首部的长度，这个字段占
4 bit，4 位的二进制数最大可以表示 15，而首部长度是以 4
个字节为一个单位的，因此首部最大长度是 15 * 4 = 60 字节。</p></li>
<li><p><strong>保留字段 (Reserved)</strong>：占 6
位，未来可能有具体用途，目前默认值为0.</p></li>
<li><p><strong>控制位 (Control
Bits)</strong>：在三次握手和四次挥手中会经常看到 SYN、ACK 和 FIN
的身影，一共有 6 个标志位，它们表示的意义如下：</p>
<ul>
<li><code>URG (Urgent Bit)</code>：值为 1 时，紧急指针生效</li>
<li><code>ACK (Acknowledgment Bit)</code>：值为 1 时，确认序号生效</li>
<li><code>PSH (Push Bit)</code>：接收方应尽快将这个报文段交给应用层</li>
<li><code>RST (Reset Bit)</code>：发送端遇到问题，想要重建连接</li>
<li><code>SYN (Synchronize Bit)</code>：同步序号，用于发起一个连接</li>
<li><code>FIN (Finish Bit)</code>：发送端要求关闭连接</li>
</ul></li>
<li><p><strong>窗口大小 (Window)</strong>：
TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个
16 bit 字段，单位是字节， 因而窗口大小最大为 65535 字节。</p></li>
<li><p><strong>检验和
(Checksum)</strong>：功能类似于数字签名，用于验证数据完整性，也就是确保数据未被修改。检验和覆盖了整个
TCP 报文段，包括 TCP 首部和 TCP
数据，发送端根据特定算法对整个报文段计算出一个检验和，接收端会进行计算并验证。</p></li>
<li><p><strong>紧急指针 (Urgent Pointer)</strong>：当 URG 控制位值为 1
时，此字段生效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。
TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p></li>
<li><p><strong>选项
(Options)</strong>：这一部分是可选字段，也就是非必须字段，最常见的可选字段是“最长报文大小
(MSS，Maximum Segment Size)”。</p></li>
<li><p><strong>有效数据部分
(Data)</strong>：这部分也不是必须的，比如在建立和关闭 TCP
连接的阶段，双方交换的报文段就只包含 TCP 首部。</p></li>
</ul>
<h2 id="tcp-的连接控制">TCP 的连接控制</h2>
<h3 id="建立连接">建立连接</h3>
<h4 id="三次握手">三次握手</h4>
<p>TCP
的重要特性之一就是面向连接，连接双方在发送数据之前必须经历握手的阶段，那具体的过程是怎样的呢？</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oJ4OmV"><img
src="https://z3.ax1x.com/2021/12/01/oJ4OmV.png"
alt="oJ4OmV.png" /></a></p>
<blockquote>
<p><strong>三次握手过程</strong></p>
</blockquote>
<p>如图所示，双方之间的三个蓝色箭头就表示了三次握手过程中所发生的数据交换：</p>
<ol type="1">
<li><strong>第一次握手</strong>：客户端向服务器发送报文段1，其中的 SYN
标志位 (前文已经介绍过各种标志位的作用)的值为
1，表示这是一个用于请求发起连接的报文段，其中的序号字段 (Sequence
Number，图中简写为seq)被设置为初始序号x (Initial Sequence
Number，ISN)，TCP
连接双方均可随机选择初始序号。发送完报文段1之后，客户端进入
<strong>SYN-SENT 状态</strong>，等待服务器的确认。</li>
<li><strong>第二次握手</strong>：服务器在收到客户端的连接请求后，向客户端发送报文段2作为应答，其中
ACK 标志位设置为 1，表示对客户端做出应答，其确认序号字段 (Acknowledgment
Number，图中简写为小写 ack) 生效，该字段值为 x +
1，也就是从客户端收到的报文段的序号加一，代表服务器期望下次收到客户端的数据的序号。此外，报文段2的
SYN 标志位也设置为1，代表这同时也是一个用于发起连接的报文段，序号 seq
设置为服务器初始序号y。发送完报文段2后，服务器进入 <strong>SYN-RECEIVED
状态</strong>。</li>
<li><strong>第三次握手</strong>：客户端在收到报文段2后，向服务器发送报文段3，其
ACK 标志位为1，代表对服务器做出应答，确认序号字段 ack 为 y + 1，序号字段
seq 为 x + 1。此报文段发送完毕后，双方都进入 <strong>ESTABLISHED
状态</strong>，表示连接已建立。</li>
</ol>
<blockquote>
<p>简答</p>
</blockquote>
<p><strong>第一次握手</strong>：客户端发送连接请求包(SYN=1,seq=x)到服务器，并进入<strong>SYN_SEND</strong>状态，等待服务器确认；</p>
<p><strong>第二次握手</strong>：服务器收到连接请求包，必须发送响应包（ACK=1，ack=x+1），由于TCP是全双工连接，所以同时自己也发送一个连接请求包（SYN=1，seq=y），即SYN+ACK包，此时服务器进入<strong>SYN_RECV</strong>状态；</p>
<p><strong>第三次握手</strong>：客户端收到服务器的SYN＋ACK包，向服务器发送确认包（ACK=1，ack=y+1)，此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP
连接都将被一直保持下去。</p>
<h4 id="tcp-建立连接为什么要三次握手而不是两次">TCP
建立连接为什么要三次握手而不是两次？</h4>
<ol type="1">
<li><strong>防止已过期的连接请求报文突然又传送到服务器，因而产生错误</strong></li>
</ol>
<ul>
<li>在双方两次握手即可建立连接的情况下，假设客户端发送 A
报文段请求建立连接，由于网络原因造成 A
暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段，客户端在长时间得不到应答的情况下重新发送请求报文段
B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED
状态，客户端在收到 确认报文后也进入 ESTABLISHED
状态，双方建立连接并传输数据，之后正常断开连接。此时姗姗来迟的 A
报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED
状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入
ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。</li>
</ul>
<ol start="2" type="1">
<li><strong>三次握手才能让双方均确认自己和对方的发送和接收能力都正常</strong></li>
</ol>
<ul>
<li><p>第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；</p></li>
<li><p>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p></li>
<li><p>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p></li>
<li><p>可见<strong>三次握手才能让双方都确认自己和对方的发送和接收能力全部正常</strong>，这样就可以愉快地进行通信了。</p></li>
</ul>
<ol start="3" type="1">
<li>告知对方自己的初始序号值，并确认收到对方的初始序号值</li>
</ol>
<ul>
<li>TCP 实现了可靠的数据传输，原因之一就是 TCP
报文段中维护了序号字段和确认序号字段，也就是图中的 seq 和
ack，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</li>
</ul>
<h4 id="tcp-建立连接为什么要三次握手而不是四次">TCP
建立连接为什么要三次握手而不是四次？</h4>
<p>相比上个问题而言，这个问题就简单多了。因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p>
<h4
id="有一种网络攻击是利用了-tcp-建立连接机制的漏洞你了解吗这个问题怎么解决">有一种网络攻击是利用了
TCP 建立连接机制的漏洞，你了解吗？这个问题怎么解决？</h4>
<p>答：在三次握手过程中，服务器在收到了客户端的 SYN
报文段后，会分配并初始化连接变量和缓存，并向客户端发送 SYN + ACK
报文段，这相当于是打开了一个“半开连接 (half-open
connection)”，会消耗服务器资源。如果客户端正常返回了 ACK
报文段，那么双方可以正常建立连接，否则，服务器在等待一分钟后会终止这个“半开连接”并回收资源。这样的机制为
SYN洪泛攻击 (SYN flood attack)提供了机会，这是一种经典的 DoS攻击 (Denial
of
Service，拒绝服务攻击)，所谓的拒绝服务攻击就是通过进行攻击，使受害主机或网络不能提供良好的服务，从而间接达到攻击的目的。在
SYN 洪泛攻击中，攻击者发送大量的 SYN
报文段到服务器请求建立连接，但是却不进行第三次握手，这会导致服务器打开大量的半开连接，消耗大量的资源，最终无法进行正常的服务。</p>
<p><strong>解决方法</strong>：<code>SYN Cookies</code>，现在大多数主流操作系统都有这种防御系统。SYN
Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN
洪泛攻击的一种手段。它的原理是，在服务器接收到 SYN 报文段并返回 SYN +
ACK 报文段时，不再打开一个半开连接，也不分配资源，而是根据这个 SYN
报文段的重要信息 (包括源和目的 IP
地址，端口号可一个秘密数)，利用特定散列函数计算出一个 cookie 值。这个
cookie 作为将要返回的SYN + ACK 报文段的初始序列号(ISN)。当客户端返回一个
ACK 报文段时，服务器根据首部字段信息计算
cookie，与返回的确认序号(初始序列号 +
1)进行对比，如果相同，则是一个正常连接，然后分配资源并建立连接，否则拒绝建立连接。</p>
<h4 id="同时打开">同时打开</h4>
<p>这是 TCP
建立连接的特殊情况，有时会出现两台机器同时执行主动打开的情况，不过概率非常小，这种情况大家仅作了解即可。在这种情况下就无所谓发送方和接收方了，双放都可以称为客户端和服务器，同时打开的过程如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oJ7xzQ"><img
src="https://z3.ax1x.com/2021/12/01/oJ7xzQ.md.png"
alt="oJ7xzQ.md.png" /></a></p>
<blockquote>
<p>同时打开的过程</p>
</blockquote>
<p>如图所示，双方在同一时刻发送 SYN 报文段，并进入 SYN-SENT 状态，在收到
SYN 后，状态变为 SYN-RECEIVED，同时它们都再发送一个 SYN + ACK
的报文段，状态都变为
ESTABLISHED，连接成功建立。在此过程中双方一共交换了4个报文段，比三次握手多一个。</p>
<h3 id="关闭连接">关闭连接</h3>
<h4 id="四次挥手">四次挥手</h4>
<p>建立一个连接需要三次握手，<strong>而终止一个连接要经过 4次握手。这由
TCP 的半关闭( half-close) 造成的</strong>。既然一个 TCP 连接是全双工
(即数据在两个方向上能同时传递)，
因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据发送任务后就能发送一个
FIN 来终止这个方向连接。当一端收到一个
FIN，它必须通知应用层另一端已经终止了数据传送。理论上客户端和服务器都可以发起主动关闭，但是更多的情况下是<strong>客户端主动发起</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oJqoM4"><img
src="https://z3.ax1x.com/2021/12/01/oJqoM4.png"
alt="oJqoM4.png" /></a></p>
<blockquote>
<p>四次挥手过程</p>
</blockquote>
<p>四次挥手详细过程如下：</p>
<ol type="1">
<li>客户端发送关闭连接的报文段，FIN
标志位1，请求关闭连接，并停止发送数据。序号字段 seq = x
(等于之前发送的所有数据的最后一个字节的序号加一)，然后客户端会进入
<strong>FIN-WAIT-1 状态</strong>，等待来自服务器的确认报文。</li>
<li>服务器收到 FIN 报文后，发回确认报文，ACK = 1， ack = x +
1，并带上自己的序号 seq = y，然后服务器就进入 <strong>CLOSE-WAIT
状态</strong>。服务器还会通知上层的应用程序对方已经释放连接，此时 TCP
处于半关闭状态，也就是说客户端已经没有数据要发送了，但是服务器还可以发送数据，客户端也还能够接收。</li>
<li>客户端收到服务器的 ACK 报文段后随即进入 <strong>FIN-WAIT-2
状态</strong>，此时还能收到来自服务器的数据，直到收到 FIN 报文段。</li>
<li>服务器发送完所有数据后，会向客户端发送 <strong>FIN
报文段</strong>，各字段值如图所示，随后服务器进入 <strong>LAST-ACK
状态</strong>，等待来自客户端的确认报文段。</li>
<li>客户端收到来自服务器的 FIN 报文段后，向服务器发送 ACK 报文，随后进入
<strong>TIME-WAIT 状态</strong>，等待 2MSL(2 * Maximum Segment
Lifetime，两倍的报文段最大存活时间)
，这是任何报文段在被丢弃前能在网络中存在的最长时间，常用值有30秒、1分钟和2分钟。如无特殊情况，客户端会进入
CLOSED 状态。</li>
<li>服务器在接收到客户端的 ACK 报文后会随即进入 <strong>CLOSED
状态</strong>，由于没有等待时间，一般而言，服务器比客户端更早进入 CLOSED
状态。</li>
</ol>
<h4 id="为什么-tcp-关闭连接为什么要四次而不是三次">为什么 TCP
关闭连接为什么要四次而不是三次？</h4>
<p>答：服务器在收到客户端的 FIN
报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回
ACK
报文段，接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送
FIN
报文，表示数据已经发送完毕，请求关闭连接，然后客户端再做出应答，因此一共需要四次挥手。</p>
<h4 id="tcp为什么要四次挥手">TCP为什么要四次挥手</h4>
<p>第一次挥手客户端发起关闭连接的请求给服务端；</p>
<p>第二次挥手：服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想要关闭连接了，但是因为数据还没传输完，所以还需要等待；</p>
<p>第三次挥手：当数据传输完了，服务端会主动发送一个 FIN
报文，告诉客户端，表示数据已经发送完了，服务端这边准备关闭连接了。</p>
<p>第四次挥手：当客户端收到服务端的 FIN 报文过后，会回复一个 ACK
报文，告诉服务端自己知道了，再等待一会就关闭连接。</p>
<h4
id="客户端为什么需要在-time-wait-状态等待-2msl-时间才能进入-closed-状态">客户端为什么需要在
TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？</h4>
<p>按照常理，在网络正常的情况下，四个报文段发送完后，双方就可以关闭连接进入
CLOSED 状态了，但是网络并不总是可靠的，如果客户端发送的 ACK
报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN
报文段，这显然不是我们想要的。因此客户端为了确保服务器收到了
ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL
的时间，如果在此期间又收到了来自服务器的 FIN
报文段，那么客户端会重新设置计时器并再次等待 2MSL
的时间，如果在这段时间内没有收到来自服务器的 FIN
报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED
状态了。</p>
<h4 id="同时关闭">同时关闭</h4>
<p>之前在介绍 TCP
建立连接的时候会有一种特殊情况，那就是同时打开，与之对应地， TCP
关闭时也会有一种特殊情况，那就是同时关闭，这种情况仅作了解即可，流程图如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/otGoY4"><img
src="https://z3.ax1x.com/2021/12/02/otGoY4.md.png"
alt="otGoY4.md.png" /></a></p>
<blockquote>
<p>同时关闭过程</p>
</blockquote>
<p>这种情况下，双方应用层同时发出关闭命令，这将导致双方各发送一个
FIN，两端均从 ESTABLISHED 变为 FIN_WAIT_1，两个 FIN
经过网络传送后分别到达另一端。收到 FIN 后，状态由 FIN_WAIT_1 变迁到
CLOSING，并发送最后的 ACK，当收到最后的 ACK 时，为确保对方也收到
ACK，状态变化为 TIME_WAIT，并等待 2MSL 时间，如果一切正常，随后会进入
CLOSED 状态。</p>
<h1
id="tcp第四次挥手后为什么要经过time_wait状态">TCP第四次挥手后为什么要经过TIME_WAIT状态？</h1>
<p>第四次挥手后为什么要经过<strong>TIME_WAIT状态</strong>之后才进入CLOSED状态，为什么不直接进入CLOSED状态？</p>
<p>因为客户端发送的第四次挥手的ACK应答数据包，服务端可能没有收到，如果服务端在发送第三次挥手的FIN数据包后，等待一段时间后没有收到ACK应答，那么会重新发送第三次挥手的FIN数据包，客户端收到后再次发送第四次挥手的ACK数据包。</p>
<p>这TIME_WAIT状态的等待时间就是为了<strong>防止服务端没有收到客户端发送的第四次挥手的ACK数据包</strong>，从而向客户端重新发送第三次挥手的FIN数据包时，客户端能正常接收到FIN数据包并且向服务端发送第四次挥手的ACK应答数据包。</p>
<h1
id="time_wait状态为什么是2msl的时长为什么不是等待其他时长">TIME_WAIT状态为什么是2MSL的时长？为什么不是等待其他时长？</h1>
<p><strong>MSL</strong>，Maximum Segment
Lifetime，最大报文段生存时间。即任何TCP报文在网络中存在的最大时长，如果超过这个时间，这个TCP报文就会被丢弃。</p>
<p><strong>2MSL</strong>，即两个最大报文段生存时间。</p>
<p>TIME_WAIT状态为什么是2MSL的时长？因为客户端不知道服务端是否能收到ACK应答数据包，服务端如果没有收到ACK，会进行重传FIN，考虑最坏的一种情况：第四次挥手的ACK包的最大生存时长(MSL)+服务端重传的FIN包的最大生存时长(MSL)=2MSL。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TIME-WAIT - represents waiting for enough time to pass to be sure</span><br><span class="line">   the remote TCP received the acknowledgment of its connection</span><br><span class="line">   termination request.</span><br></pre></td></tr></table></figure>
<p>为了确保远端TCP端能够收到它发出的终止连接请求的ACK应答包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIME-WAIT STATE</span><br><span class="line"></span><br><span class="line">  The only thing that can arrive in this state is a</span><br><span class="line">  retransmission of the remote FIN.  Acknowledge it, and restart</span><br><span class="line">  the 2 MSL timeout.</span><br></pre></td></tr></table></figure>
<p>TIME-WAIT状态唯一可能收到的是服务端发送的FIN数据包，每次收到FIN数据包，回送ACK应答，并且重置2MSL的等待超时时间。</p>
<p>如果客户端不经过2MSL时长的TIME_WAIT状态，发送ACK之后就立马关闭TCP链接，释放端口号和内存资源，会出现什么情况？</p>
<p>可能会出现服务端并没有收到ACK，然后重新发送第三次挥手的FIN包，而此时客户端又新建了到服务端的TCP链接，并且客户端使用的还是之前的端口号，那么网络中延迟到达的FIN包就会被这个新的TCP链接接收到，这不是客户端希望接收到的数据，因此要等待2MSL的时长，确保网络中的FIN包全都不存在了，才关闭TCP链接，释放端口号和内存资源，这个时候客户端就可以重新使用这个端口号连接任何服务器，包括刚断开的这台服务器。</p>
<p>因此，上次TCP连接的依然存活的报文对未来的新TCP连接是会产生很大影响的，为了防止这种情况的出现，除了TIME_WAIT状态的2MSL时长机制，TCP协议中还有
The TCP Quiet Time Concept (在 3.3. Sequence Numbers
章节中)的概念，按照这个理念，2MSL时长的设定是一比较宽裕的值。</p>
<p>因此，TIME_WAIT状态需要等待2MSL的时长，确保本次TCP连接的四次挥手的关闭流程的正确可靠。</p>
<p>总结，<strong>TIME_WAIT状态的时长设置为2MSL的主要原因</strong>：</p>
<ol type="1">
<li>确保被动关闭TCP连接的一端能收到第四次挥手的ACK。</li>
<li>避免上一次TCP连接的数据包影响到下一次的TCP连接。</li>
</ol>
<h1 id="tcp协议如何保证传输可靠性">TCP协议如何保证传输可靠性</h1>
<p>TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。讨论一下TCP协议如何确保传输的可靠性的。</p>
<h2 id="确保传输可靠性的方式">确保传输可靠性的方式</h2>
<p>TCP协议保证数据传输可靠性的方式主要有：</p>
<ol type="1">
<li>校验和</li>
<li>序列号</li>
<li>确认应答</li>
<li>超时重传</li>
<li>连接管理</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ol>
<h2 id="校验和">校验和</h2>
<ul>
<li><p><strong>计算方式</strong>：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。</p></li>
<li><p><strong>发送方</strong>：在发送数据之前计算检验和，并进行校验和的填充。</p></li>
<li><p><strong>接收方</strong>：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/otWARs"><img
src="https://z3.ax1x.com/2021/12/02/otWARs.png"
alt="otWARs.png" /></a></p>
<p><strong>注意</strong>：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p>
<h2 id="确认应答与序列号">确认应答与序列号</h2>
<p><strong>序列号</strong>：TCP传输时将每个字节的数据都进行了编号，这就是序列号。</p>
<p><strong>确认应答</strong>：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/otWyQI"><img
src="https://z3.ax1x.com/2021/12/02/otWyQI.png"
alt="otWyQI.png" /></a></p>
<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p>
<h2 id="超时重传">超时重传</h2>
<p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？</p>
<p>首先，发送方没有介绍到响应的ACK报文原因可能有两点：</p>
<ol type="1">
<li>数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。</li>
<li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</li>
</ol>
<p>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制</strong>。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。</p>
<p>那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？</p>
<p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。</p>
<blockquote>
<p>在Linux中（BSD
Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2<em>500ms的时间后，再次重传。等待4</em>500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。</p>
</blockquote>
<h2 id="连接管理">连接管理</h2>
<p>连接管理就是<strong>三次握手与四次挥手的过程</strong>
，在前面详细讲过这个过程，这里不再赘述。保证可靠的连接，是保证可靠性的前提。</p>
<h2 id="流量控制">流量控制</h2>
<p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致<strong>接收端的结束缓冲区</strong>很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是<strong>流量控制</strong>
。</p>
<p>在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ot4Sqx"><img
src="https://z3.ax1x.com/2021/12/02/ot4Sqx.md.png"
alt="ot4Sqx.md.png" /></a></p>
<p>注：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。</p>
<h2 id="拥塞控制">拥塞控制</h2>
<p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p>
<p>所以TCP引入了<strong>慢启动</strong>的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为
1，每次收到ACK应答，拥塞窗口加
1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</p>
<p>拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为
1。</p>
<p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p>
<h1 id="tcp粘包拆包原因以及解决办法">TCP粘包拆包原因以及解决办法</h1>
<h2 id="粘包拆包发生原因">粘包、拆包发生原因</h2>
<ol type="1">
<li><p>要发送的数据大于TCP缓冲区剩余的大小，发生<strong>拆包</strong>。</p></li>
<li><p>要发送的数据大于MSS(最大报文长度)，发生<strong>拆包</strong>。</p></li>
<li><p>要发送的数据小于TCP缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，发生<strong>粘包</strong>。</p></li>
<li><p>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生<strong>粘包</strong>。</p></li>
</ol>
<h2 id="粘包拆包表现形式">粘包、拆包表现形式</h2>
<p>现在假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：</p>
<p><strong>第一种情况</strong>，接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/otb4b9"><img
src="https://z3.ax1x.com/2021/12/02/otb4b9.md.png"
alt="otb4b9.md.png" /></a></p>
<p><strong>第二种情况</strong>，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/otbvbd"><img
src="https://z3.ax1x.com/2021/12/02/otbvbd.md.png"
alt="otbvbd.md.png" /></a></p>
<p><strong>第三种情况</strong>，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/otqeVs"><img
src="https://z3.ax1x.com/2021/12/02/otqeVs.md.png"
alt="otqeVs.md.png" /></a></p>
<h2 id="粘包拆包解决办法">粘包、拆包解决办法</h2>
<ol type="1">
<li>发送端给每个数据包添加一个首部，首部至少包含此次数据包的长度,那么服务端每次按照首部的长度读取。</li>
<li>发送固定长度的数据包，不够的补0。</li>
<li>添加结束标识，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</li>
<li>上面三种组合使用。</li>
</ol>
<h1 id="避免粘包现象解决办法">避免粘包现象解决办法</h1>
<p>可采取以下几种措施：</p>
<ol type="1">
<li>对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</li>
<li>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</li>
<li>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。</li>
</ol>
<p><strong>以上提到的三种措施，都有其不足之处：</strong></p>
<ol type="1">
<li>第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</li>
<li>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</li>
<li>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li>
</ol>
<p><strong>一种比较周全的对策是</strong>：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。对这种方法我们进行了实验，证明是高效可行的。</p>
<h1 id="滑动窗口">滑动窗口</h1>
<h2 id="滑动窗口的定义">滑动窗口的定义</h2>
<p>1.“窗口”对应的是一段可以被发送的字节序列，其连续的范围称为窗口；
2.“滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。</p>
<h2 id="滑动窗口的作用">滑动窗口的作用</h2>
<p>是一种<strong>流量控制</strong>方法，该协议允许发送方在停止等待确认前可以连续发送多个分组。由于发送方不必每发送一个分组就停下来等待确认，因此该协议可以加速数据的传输。</p>
<h1 id="udp如何实现可靠传输">UDP如何实现可靠传输</h1>
<p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p>
<p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li><strong>添加seq/ack机制，确保数据发送到对端</strong></li>
<li><strong>添加发送和接收缓冲区，主要是用户超时重传。</strong></li>
<li><strong>添加超时重传机制。</strong></li>
</ul>
<p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为**RUDP、RTP、UDT**。</p>
<h1
id="在浏览器地址栏输入url按下回车后究竟发生了什么">在浏览器地址栏输入URL，按下回车后究竟发生了什么？</h1>
<ul>
<li><p><strong>第一步：浏览器输入域名</strong></p></li>
<li><p><strong>第二步：浏览器查找域名的IP地址</strong></p></li>
</ul>
<p>浏览器会把输入的域名解析成对应的IP，其过程如下：</p>
<ol type="1">
<li><p>查找浏览器缓存：因为浏览器一般会缓存DNS记录一段时间，不同浏览器的时间可能不一样，一般2-30分钟不等，浏览器去查找这些缓存，如果有缓存，直接返回IP，否则下一步。</p></li>
<li><p>查找系统缓存：浏览器缓存中找不到IP之后，浏览器会进行系统调用（windows中是gethostbyname），查找本机的hosts文件，如果找到，直接返回IP，否则下一步。</p></li>
<li><p>查找路由器缓存：如果1,2步都查询无果，则需要借助网络，路由器一般都有自己的DNS缓存，将前面的请求发给路由器，查找ISP
服务商缓存
DNS的服务器，如果查找到IP则直接返回，没有的话继续查找。</p></li>
<li><p>递归查询：如果以上步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。（本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的）</p></li>
<li><p>迭代查询：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）。</p></li>
</ol>
<p>本例子中：根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.net的IP地址。本地域名服务器向顶级域名服务器dns.net进行查询。顶级域名服务器dns.net告诉本地域名服务器，下一次应查询的权限域名服务器dns.csdn.net的IP地址。本地域名服务器向权限域名服务器dns.csdn.net进行查询。权限域名服务器dns.csdn.net告诉本地域名服务器，所查询的主机www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。</p>
<ul>
<li><strong>第三步 ：浏览器与目标服务器建立TCP连接</strong></li>
</ul>
<ol type="1">
<li><p>主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。</p></li>
<li><p>TCP3次握手连接：浏览器所在的客户机向服务器发出连接请求报文（SYN标志为1）；服务器接收报文后，同意建立连接，向客户机发出确认报文（SYN，ACK标志位均为1）；客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文；此处客户机与服务器之间的TCP连接建立完成，开始通信。</p></li>
</ol>
<ul>
<li><strong>第四步：浏览器通过http协议发送请求</strong></li>
</ul>
<p>浏览器向主机发起一个HTTP-GET方法报文请求。请求中包含访问的URL，也就是http://www.csdn.com/
，KeepAlive，长连接，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。</p>
<ul>
<li><strong>第五步：某些服务会做永久重定向响应</strong></li>
</ul>
<p>对于大型网站存在多个主机站点，了负载均衡或者导入流量，提高SEO排名，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。</p>
<p><strong>重定向的作用</strong>：重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于baidu.com，www.baidu.com会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。</p>
<ul>
<li><strong>第六步：浏览器跟踪重定向地址</strong></li>
</ul>
<p>当浏览器知道了重定向后最终的访问地址之后，重新发送一个http请求，发送内容同上。</p>
<ul>
<li><strong>第七步：服务器处理请求</strong></li>
</ul>
<p>服务器接收到获取请求，然后处理并返回一个响应。</p>
<ul>
<li><strong>第八步：服务器发出一个HTML响应</strong></li>
</ul>
<p>返回状态码200
OK，表示服务器可以响应请求，返回报文，由于在报头中Content-type为“text/html”，浏览器以HTML形式呈现，而不是下载文件。</p>
<ul>
<li><strong>第九步：释放TCP连接</strong></li>
</ul>
<ol type="1">
<li><p>浏览器所在主机向服务器发出连接释放报文，然后停止发送数据；</p></li>
<li><p>服务器接收到释放报文后发出确认报文，然后将服务器上未传送完的数据发送完；</p></li>
<li><p>服务器数据传输完毕后，向客户机发送连接释放报文；</p></li>
<li><p>客户机接收到报文后，发出确认，然后等待一段时间后，释放TCP连接；</p></li>
</ol>
<ul>
<li><strong>第十步：浏览器显示页面</strong></li>
</ul>
<p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器接收到返回的数据包，根据浏览器的渲染机制对相应的数据进行渲染。渲染后的数据，进行相应的页面呈现和脚步的交互。</p>
<ul>
<li><strong>第十一步：浏览器发送获取嵌入在HTML中的其他内容</strong></li>
</ul>
<p>比如一些样式文件，图片url，js文件url等，浏览器会通过这些url重新发送请求，请求过程依然是HTML读取类似的过程，查询域名，发送请求，重定向等。不过这些静态文件是可以缓存到浏览器中的，有时访问这些文件不需要通过服务器，直接从缓存中取。某些网站也会使用第三方CDN进行托管这些静态文件。</p>
<h1 id="http与https的区别">HTTP与HTTPS的区别</h1>
<p><strong>超文本传输协议HTTP协议</strong>被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：<strong>安全套接字层超文本传输协议HTTPS</strong>，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<h2
id="http和https的基本概念"><strong>HTTP和HTTPS的基本概念</strong></h2>
<ul>
<li><p><strong>HTTP</strong>：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p></li>
<li><p><strong>HTTPS</strong>：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入<code>SSL层</code>，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></li>
</ul>
<p><strong>HTTPS协议的主要作用</strong>可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h2
id="http与https有什么区别"><strong>HTTP与HTTPS有什么区别？</strong></h2>
<p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure
Sockets
Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<blockquote>
<p>HTTPS和HTTP的区别主要如下：</p>
</blockquote>
<ol type="1">
<li><strong>https协议</strong>
需要到ca申请证书，一般免费证书较少，因而需要一定费用。 　　2.
<strong>http</strong>是<code>超文本传输协议</code>，信息是明文传输，<strong>https</strong>则是<code>具有安全性的SSL加密传输协议</code>。
　　3.
<strong>http</strong>和<strong>https</strong>使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
　　4.
<strong>http</strong>的连接很简单，是无状态的；<strong>https协议</strong>是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<h1
id="https证书验证失败的原因及解决方法"><strong>https证书验证失败的原因及解决方法</strong></h1>
<ol type="1">
<li><strong>无法找到https证书的颁发者</strong>。</li>
</ol>
<ul>
<li><code>解决方法</code>：https证书要选择可信权威的SSL证书品牌商，如<a
target="_blank" rel="noopener" href="https://www.sslinfo.org/330.html">DigiCert</a>、GeoTrust、GlobalSign等知名品牌。它们颁发的https证书安全性会更高，受各大浏览器信任。</li>
</ul>
<ol start="2" type="1">
<li><strong>https证书过期</strong></li>
</ol>
<ul>
<li><code>解决方法</code>：目前https证书的有效期是13个月，超过这个时间会提示证书过期，这时需要重新签发证书，流程和第一次申请时相似。</li>
</ul>
<ol start="3" type="1">
<li><strong>无法找到锚点证书(即在证书链的顶端没有找到合法的根证书)</strong></li>
</ol>
<ul>
<li><code>解决方法</code>：如果无法找到合法根证书时，需要重新签发https证书，安装所缺失的根证书。</li>
</ul>
<ol start="4" type="1">
<li><strong>访问的server的dns地址和证书中的地址不同</strong></li>
</ol>
<ul>
<li><code>解决方法</code>：仔细检查域名地址与https申请时提交的地址。一个https证书所匹配的域名注册是具备唯一性的，如果您网站包含多个域名，那么建议申请多域名SSL证书或通配符证书。</li>
</ul>
<h1 id="cookie和session的区别">cookie和session的区别</h1>
<blockquote>
<p><strong>二者的定义：</strong></p>
</blockquote>
<p>当你在浏览网站的时候，<code>WEB 服务器</code>会先送一小小资料放在你的计算机上，<code>Cookie</code>
会帮你在网站上所打的文字或是一些选择，都纪录下来。当下次你再光临同一个网站，<code>WEB 服务器</code>会先看看有没有它上次留下的
<code>Cookie</code> 资料，有的话，就会依据 <code>Cookie</code>
里的内容来判断使用者，送出特定的网页内容给你。 <code>Cookie</code>
的使用很普遍，许多有提供个人化服务的网站，都是利用 <code>Cookie</code>
来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email
网站，都要用到 <code>Cookie</code>。</p>
<p>具体来说<strong>cookie机制采用的是在客户端保持状态的方案</strong>，而<strong>session机制采用的是在服务器端保持状态的方案</strong>。</p>
<p>同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。</p>
<p><strong>cookie机制</strong>。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</p>
<p><strong>cookie的内容</strong>主要包括：<code>名字，值，过期时间，路径和域</code>。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。</p>
<p>会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。</p>
<p><strong>session机制</strong>是一种<code>服务器端的机制</code>，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>
<p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session
id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session
id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session
id，则为此客户端创建一个session并且生成一个与此session相关联的session
id，session
id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session
id将被在本次响应中返回给客户端保存。</p>
<p>保存这个session
id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session
id传递回服务器。</p>
<p>经常被使用的一种技术叫做<strong>URL重写</strong>，就是把session
id直接附加在URL路径的后面。还有一种技术叫做<strong>表单隐藏字段</strong>。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session
id传递回服务器。</p>
<p>实际上这种技术可以简单的用对action应用URL重写来代替。</p>
<blockquote>
<p><strong>cookie 和session 的区别：</strong></p>
</blockquote>
<ol type="1">
<li><p><strong>cookie数据</strong>存放在客户的浏览器上，<strong>session数据</strong>放在服务器上。</p></li>
<li><p><strong>cookie</strong>不是很安全，别人可以分析存放在本地的cookie并进行<strong>cookie欺骗</strong>，考虑到安全应当使用session。</p></li>
<li><p><strong>session</strong>会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</p></li>
<li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p></li>
<li><p>所以个人建议：</p>
<ul>
<li>将登陆信息等重要信息存放为session；</li>
<li>其他信息如果需要保留，可以放在cookie中。</li>
</ul></li>
</ol>
<h1 id="https的加密流程">Https的加密流程</h1>
<p>由于HTTP的内容在网络上实际是明文传输，并且也没有身份验证之类的安全措施，所以容易遭到挟持与攻击。</p>
<p>HTTPS是通过<strong>SSL(安全套接层)和TLS(安全传输协议)</strong>的组合使用，<strong>加密TCP载荷</strong>即HTTP报文内容，同时通过不<strong>对称密钥方式</strong>认证身份，保证传输的安全可靠。</p>
<p>即：<strong>HTTP+加密+认证+完整性保护</strong>=HTTPS</p>
<h1 id="get-和-post-的区别">GET 和 POST 的区别</h1>
<p>总结来说就是：<strong>它们的本质都是 TCP 链接，并无区别。但是由于
HTTP
的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。</strong></p>
<ul>
<li><strong>GET：当客户端要从服务器中读取某个资源时，使用GET
方法</strong>。GET 方法要求服务器将URL
定位的资源放在响应报文的部分，回<a
target="_blank" rel="noopener" href="http://www.chinabyte.com/keyword/送给/">送给</a>客户端，即向服务器请求某个资源。使用GET
方法时，请求参数和对应的值附加在 URL 后面，利用一个问号(“?”)代表URL
的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind。</li>
<li><strong>POST：当客户端给服务器提供信息较多时可以使用POST
方法</strong>，POST
方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。<strong>GET
一般用于获取/查询资源信息，POST
会附带用户数据，一般用于更新资源信息。</strong>POST 方法将请求参数<a
target="_blank" rel="noopener" href="http://www.chinabyte.com/keyword/封装/">封装</a>在HTTP
请求数据中，以名称/值的形式出现，可以传输大量数据;</li>
</ul>
<h1
id="http请求报文格式和响应报文格式">http请求报文格式和响应报文格式</h1>
<p><code>HTTP 请求报文</code>由<strong>请求行、请求头部、空行 和
请求包体</strong> 4 个部分组成。</p>
<p><code>HTTP 响应报文</code><strong>由状态行、响应头部、空行 和
响应包体</strong> 4 个部分组成。</p>
<h1 id="http1.0-http1.1-http2.0特性及区别">http1.0 http1.1
http2.0特性及区别</h1>
<h2 id="http1.0特性">http1.0特性</h2>
<p><strong>无状态</strong>：服务器不跟踪不记录请求过的状态
<strong>无连接</strong>：浏览器每次请求都需要建立tcp连接</p>
<h3 id="无状态">无状态</h3>
<p>对于无状态的特性可以借助<code>cookie/session机制</code>来做身份认证和状态记录</p>
<h3 id="无连接">无连接</h3>
<p>无连接导致的性能缺陷有两种：</p>
<ol type="1">
<li><p><strong>无法复用连接</strong>
每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</p></li>
<li><p><strong>队头阻塞</strong>
http1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</p></li>
</ol>
<h2 id="http1.1特性">http1.1特性</h2>
<p>为了解决http1.0的性能缺陷，http1.1出现了</p>
<blockquote>
<p><strong>http1.1特性：</strong></p>
</blockquote>
<ul>
<li><strong>长连接</strong>：新增Connection字段，可以设置keep-alive值保持连接不断开</li>
<li><strong>管道化</strong>：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回</li>
<li><strong>缓存处理</strong>：新增字段cache-control</li>
<li><strong>断点传输</strong></li>
</ul>
<h3 id="长连接">长连接</h3>
<p>http1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据</p>
<h3 id="管道化">管道化</h3>
<p>基于长连接的基础，我们先看没有管道化请求响应：</p>
<p>tcp没有断开，用的同一个通道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3`</span><br></pre></td></tr></table></figure>
<p>管道化的请求响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3</span><br></pre></td></tr></table></figure>
<p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p>
<p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p>
<h3 id="缓存处理">缓存处理</h3>
<p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求</p>
<p>通过设置字段<code>cache-control</code>来控制</p>
<h3 id="断点传输">断点传输</h3>
<p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p>
<p>在 Header 里两个参数实现的，客户端发请求时对应的是 Range
服务器端响应时对应的是 Content-Range</p>
<h2 id="http2.0特性">http2.0特性</h2>
<ul>
<li><strong>二进制分帧</strong></li>
<li><strong>多路复用</strong>：
在共享TCP链接的基础上同时发送请求和响应</li>
<li><strong>头部压缩</strong></li>
<li><strong>服务器推送</strong>：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li>
</ul>
<h3 id="二进制分帧">二进制分帧</h3>
<p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</p>
<h3 id="多路复用">多路复用</h3>
<p>基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来</p>
<h2 id="区别">区别</h2>
<ul>
<li>http1.0 到http1.1的主要区别，就是从无连接到长连接</li>
<li>http2.0对比1.X版本主要区别就是多路复用</li>
</ul>
<h1 id="http协议的几种方法">http协议的几种方法</h1>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">方法</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">GET</td>
<td
style="text-align: center;">发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。另外get支持快取、缓存、可保留书签等。幂等</td>
</tr>
<tr class="even">
<td style="text-align: center;">POST</td>
<td
style="text-align: center;">和get一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中，不支持快取。非幂等。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">HEAD</td>
<td
style="text-align: center;">本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。</td>
</tr>
<tr class="even">
<td style="text-align: center;">PUT</td>
<td
style="text-align: center;">和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置；比如post是在一个集合上（/province），而put是具体某一个资源上（/province/123）。所以put是安全的，无论请求多少次，都是在123上更改，而post可能请求几次创建了几次资源。幂等</td>
</tr>
<tr class="odd">
<td style="text-align: center;">DELETE</td>
<td
style="text-align: center;">请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。幂等</td>
</tr>
<tr class="even">
<td style="text-align: center;">CONNECT</td>
<td
style="text-align: center;">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">OPTIONS</td>
<td
style="text-align: center;">获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</td>
</tr>
<tr class="even">
<td style="text-align: center;">TRACE</td>
<td
style="text-align: center;">回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。</td>
</tr>
</tbody>
</table>
<h1 id="dns工作原理">DNS工作原理</h1>
<p><strong>DNS</strong>（Domain Name
System）：称之为域名系统,工作在应用层协议,是互联网的一项服务。它作为<strong>将域名和IP地址相互映射的一个分布式数据库</strong>，能够使人更方便地访问互联网。简单的来说就是当我们在浏览器输入一个网址时，电脑主机通过DNS将网址解析成网络设备能够识别的IP地址，以便电脑主机和远在地球另一端的服务器进行通讯最终在浏览器显示我们最终想要的内容。DNS是基于C/S架构的，客户端是地球上数以亿万的接入互联网的网络设备，服务器是13台根服务器、互联网通用各顶级域服务器、国家和地区顶级域名服务器以及各个网络运营商、互联网公司提供的DNS解析服务。</p>
<h2 id="dns域名结构">DNS域名结构</h2>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HC7pF"><img
src="https://s4.ax1x.com/2022/01/25/7HC7pF.md.png"
alt="7HC7pF.md.png" /></a></p>
<h2
id="dns服务由客户端到服务器的工作原理">DNS服务由客户端到服务器的工作原理</h2>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HCX01"><img
src="https://s4.ax1x.com/2022/01/25/7HCX01.md.png"
alt="7HCX01.md.png" /></a></p>
<ol type="1">
<li>客户端输入域名，查询本地缓存</li>
<li>本地DNS服务器查询，本地DNS服务器内部缓存</li>
<li>本地DNS向根域名服务器查询，根域服务器返回一级域地址</li>
<li>本地DNS向根域返回的一级域服务器查询，一级域的本地缓存</li>
<li>查询到终结果，返回给本地DNS服务器</li>
<li>本地DNS服务器，将解析的结果返回客户端</li>
<li>客户端根据返回结果的Ip浏览互联网</li>
</ol>
<h1
id="osi七层五层模型每一层的作用">OSI七层、五层模型，每一层的作用</h1>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7jG7kj"><img
src="https://s4.ax1x.com/2022/01/27/7jG7kj.md.png"
alt="7jG7kj.md.png" /></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7jN0Cd"><img
src="https://s4.ax1x.com/2022/01/27/7jN0Cd.md.gif"
alt="7jN0Cd.md.gif" /></a></p>
<blockquote>
<p><strong>第一层：物理层</strong></p>
</blockquote>
<p>在OSI参考模型中，物理层是参考模型的最低层，也是OSI模型的第一层。物理层的主要功能是：<strong>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输</strong>。物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p>
<blockquote>
<p><strong>第二层：数据链路层</strong></p>
</blockquote>
<p>数据链路层（Data Link
Layer）是OSI模型的第二层，负责建立和管理节点间的链路。在计算机网络中由于各种干扰的存在，导致物理链路是不可靠的。因此这一层的主要功能是：<strong>在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</strong></p>
<blockquote>
<p><strong>第三层：网络层</strong></p>
</blockquote>
<p>网络层（Network
Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层，它在下两层的基础上向资源子网提供服务。其主要功能是：在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接，将数据设法从源端经过若干个中间节点传送到目的端（点到点），从而向传输层提供最基本的端到端的数据传输服务。具体地说，<strong>数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</strong>数据链路层和网络层的区别为：数据链路层的目的是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。</p>
<blockquote>
<p><strong>第四层：传输层</strong></p>
</blockquote>
<p>OSI下3层的任务是数据通信，上3层的任务是数据处理。而传输层（Transport
Layer）是OSI模型的第4层。该层提供建立、维护和拆除传输连接的功能，起到承上启下的作用。该层的主要功能是：<strong>向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，同时向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。</strong></p>
<blockquote>
<p><strong>第五层：会话层</strong></p>
</blockquote>
<p>会话层是OSI模型的第5层，是用户应用程序和网络之间的接口，该层的主要功能是：<strong>组织和协调两个会话进程之间的通信，并对数据交换进行管理。</strong>当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名就是一种网络上使用的远程地址。会话层的具体功能如下：</p>
<ol type="1">
<li>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。</li>
<li>会话流量控制：提供会话流量控制和交叉会话功能。</li>
<li>寻址：使用远程地址建立会话连接。</li>
<li>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。</li>
</ol>
<blockquote>
<p><strong>第六层：表示层</strong></p>
</blockquote>
<p>表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。该层的主要功能是：处<strong>理用户信息的表示问题，如编码、数据格式转换和加密解密等。</strong>表示层的具体功能如下：</p>
<ol type="1">
<li>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。</li>
<li>数据的编码：处理字符集和数字的转换。</li>
<li>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。</li>
<li>数据的加密和解密：可以提高网络的安全性。</li>
</ol>
<blockquote>
<p><strong>第七层：应用层</strong></p>
</blockquote>
<p>应用层是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，该层的主要功能是：<strong>直接向用户提供服务，完成用户希望在网络上完成的各种工作</strong>。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外该层还负责协调各个应用程序间的工作。应用层的具体功能如下：</p>
<p>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。
实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</p>
<h2 id="osi七层模型举例">OSI七层模型举例</h2>
<p>​ 举例：以A公司向B公司发送一次商业报价单为例。</p>
<pre><code>   应用层：A公司相当于实际的电脑用户，要发送的商业报价单相当于应用层提供的一种网络服务，当然A公司也可以选择其他服务，比如发一份商业合同，发一份询价单等等。

   表示层：由于A公司和B公司是不同国家的公司，他们之间商定统一用英语作为交流语言，所以此时A公司的文秘（表示层）将从上级手中（应用层）获取到的商业报价单的语言转翻译成英语，同时为了防止被别的公司盗取机密信息，A公司的文秘也会对这份报价单做一些加密的处理。这就是表示层的作用，将应用层的数据转换翻译。

   会话层：A公司外联部同事（会话层）掌握着其他许多公司的联系方式，他们负责管理本公司与外界许多公司的联系会话。当外联部同事拿到文秘（表示层）转换成英文的商业报价单后，他首先要找到B公司的地址信息，并附上自己的地址和联系方式，然后将整份资料放进信封准备寄出。等确认B公司接收到此报价单后，外联部的同事就去办其他的事情了，继而终止此次会话。

   传输层：传输层就相当于A公司中的负责收发快递邮件的人，A公司自己的投递员负责将上一层（会话层）要寄出的资料投递到快递公司或邮局。

   网络层：网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说从深圳发往北京的顺丰快递，首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。

   数据链路层：相当于顺丰快递内部为了保证效率和质量的一种内部操作。

   物理层：快递寄送过程中的交通工具，就相当于物理层，例如汽车，火车，飞机，船。</code></pre>
<h2 id="osi七层模型总结">OSI七层模型总结</h2>
<p>应用层：产生网络流量的程序</p>
<p>表示层：传输之前是否进行加密或者压缩处理</p>
<p>会话层：查看会话，查木马 netstat-n</p>
<p>传输层：可靠传输、流量控制、不可靠传输</p>
<p>网络层：负责选择最佳路径、规划ip地址</p>
<p>数据链路层：帧的开始和结束、透明传输、差错校验</p>
<p>物理层：接口标准、电器标准、如何更快传输数据</p>
<h1
id="浏览器禁用了cookie以后还能用session吗">浏览器禁用了Cookie以后还能用Session吗</h1>
<p>一般默认情况下，在会话中，服务器存储 session 的 sessionid 是通过
cookie 存到浏览器里。</p>
<p>如果浏览器禁用了 cookie，浏览器请求服务器无法携带
sessionid，服务器无法识别请求中的用户身份，session失效。</p>
<p>但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用session。</p>
<ul>
<li>通过url重写，把 sessionid 作为参数追加到原 url
中，后续的浏览器与服务器交互中携带 sessionid 参数。</li>
<li>服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid
参数。</li>
<li>通过 Http 协议其他 header 字段，服务器每次返回时设置该 header
字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该
header 字段。</li>
</ul>
<h1 id="http响应状态码">Http响应状态码</h1>
<p>下面是常见的 HTTP 状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h2 id="http-状态码分类">HTTP 状态码分类</h2>
<p>HTTP
状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误
(500–599)：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">分类</th>
<th style="text-align: left;">分类描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1**</td>
<td
style="text-align: left;">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr class="even">
<td style="text-align: left;">2**</td>
<td style="text-align: left;">成功，操作被成功接收并处理</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3**</td>
<td style="text-align: left;">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr class="even">
<td style="text-align: left;">4**</td>
<td
style="text-align: left;">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5**</td>
<td
style="text-align: left;">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<h1
id="http的四种请求方法getpostputdelete">HTTP的四种请求方法GET、POST、PUT、DELETE</h1>
<p>一直在测试REST模式的WEB
SERVICE接口，客户端的HTTP的请求方式一般分为四种：GET、POST、PUT、DELETE，这四种请求方式有什么不同呢。简单的说，<strong>GET就是获取资源，POST用来新建资源（也可以用于更新资源），PUT也是更改资源，DELETE就是删除资源</strong>。具体来说：</p>
<ul>
<li><strong>PUT</strong>：PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来<strong>修改数据的内容</strong>，但是<strong>不会增加数据的种类</strong>等，也就是说无论进行多少次PUT操作，资源不会增加。</li>
<li><strong>DELETE</strong>：DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。</li>
<li><strong>GET</strong>：GET操作是<strong>安全</strong>的。所谓安全是指不管进行多少次操作，资源的状态都不会改变，GET只是访问和查看资源。</li>
<li><strong>POST</strong>：操作<strong>不是安全</strong>的，每次请求都会创建资源，当我们多次发出POST请求后，其结果是创建出了多个资源。还有一点需要注意的就是，创建操作可以使用POST，也可以使用PUT，区别在于POST
是作用在一个集合资源之上的（/uri），而PUT操作是作用在一个具体资源之上的（/uri/xxx），再通俗点说，如果URL可以在客户端确定，那么就使用PUT，如果是在服务端确定，那么就使用POST，比如说很多资源使用数据库自增主键作为标识信息，而创建的资源的标识信息到底是什么只能由服务端提供，这个时候就必须使用POST。</li>
</ul>
<h1 id="close_wait的作用">close_wait的作用</h1>
<p>服务器保持了大量CLOSE_WAIT状态，简单来说CLOSE_WAIT数目过大是由于<strong>被动关闭连接处理不当</strong>导致的。</p>
<p>如果服务器程序TCP连接一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出<code>ack</code>信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="prev" title="操作系统">
      <i class="fa fa-chevron-left"></i> 操作系统
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%A1%86%E6%9E%B6/" rel="next" title="框架">
      框架 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E4%B8%8Eudp%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">TCP与UDP的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">TCP&#x2F;IP网络模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#udp"><span class="nav-number">1.2.</span> <span class="nav-text">UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp"><span class="nav-number">1.3.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">TCP连接过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp%E6%96%AD%E5%BC%80%E9%93%BE%E6%8E%A5"><span class="nav-number">1.3.2.</span> <span class="nav-text">TCP断开链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.3.</span> <span class="nav-text">TCP协议的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E5%92%8Cudp%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.4.</span> <span class="nav-text">TCP和UDP的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E4%B8%8Eudp%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.</span> <span class="nav-text">TCP与UDP区别总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88udp%E6%9C%89%E6%97%B6%E6%AF%94tcp%E6%9B%B4%E6%9C%89%E4%BC%98%E5%8A%BF"><span class="nav-number">2.</span> <span class="nav-text">为什么UDP有时比TCP更有优势</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%A6%E8%A7%A3tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">3.</span> <span class="nav-text">详解TCP三次握手、四次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">TCP 报文段简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text">TCP 的连接控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.1.</span> <span class="nav-text">建立连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">TCP
建立连接为什么要三次握手而不是两次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">TCP
建立连接为什么要三次握手而不是四次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E4%B8%80%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%98%AF%E5%88%A9%E7%94%A8%E4%BA%86-tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BC%8F%E6%B4%9E%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">有一种网络攻击是利用了
TCP 建立连接机制的漏洞，你了解吗？这个问题怎么解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">同时打开</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.2.</span> <span class="nav-text">关闭连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-tcp-%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%89%E6%AC%A1"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">为什么 TCP
关闭连接为什么要四次而不是三次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">TCP为什么要四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9C%A8-time-wait-%E7%8A%B6%E6%80%81%E7%AD%89%E5%BE%85-2msl-%E6%97%B6%E9%97%B4%E6%89%8D%E8%83%BD%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">客户端为什么需要在
TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E5%85%B3%E9%97%AD"><span class="nav-number">3.2.2.5.</span> <span class="nav-text">同时关闭</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%8F%E8%BF%87time_wait%E7%8A%B6%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">TCP第四次挥手后为什么要经过TIME_WAIT状态？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#time_wait%E7%8A%B6%E6%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2msl%E7%9A%84%E6%97%B6%E9%95%BF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%AD%89%E5%BE%85%E5%85%B6%E4%BB%96%E6%97%B6%E9%95%BF"><span class="nav-number">5.</span> <span class="nav-text">TIME_WAIT状态为什么是2MSL的时长？为什么不是等待其他时长？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text">TCP协议如何保证传输可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AE%E4%BF%9D%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">确保传输可靠性的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">6.2.</span> <span class="nav-text">校验和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="nav-number">6.3.</span> <span class="nav-text">确认应答与序列号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="nav-number">6.4.</span> <span class="nav-text">超时重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">6.5.</span> <span class="nav-text">连接管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">6.6.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">6.7.</span> <span class="nav-text">拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">TCP粘包拆包原因以及解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%91%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="nav-number">7.1.</span> <span class="nav-text">粘包、拆包发生原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">粘包、拆包表现形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">粘包、拆包解决办法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">避免粘包现象解决办法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">9.</span> <span class="nav-text">滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">9.1.</span> <span class="nav-text">滑动窗口的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">9.2.</span> <span class="nav-text">滑动窗口的作用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#udp%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">10.</span> <span class="nav-text">UDP如何实现可靠传输</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E7%A9%B6%E7%AB%9F%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">11.</span> <span class="nav-text">在浏览器地址栏输入URL，按下回车后究竟发生了什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">HTTP与HTTPS的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E5%92%8Chttps%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">12.1.</span> <span class="nav-text">HTTP和HTTPS的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E4%B8%8Ehttps%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">12.2.</span> <span class="nav-text">HTTP与HTTPS有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#https%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">https证书验证失败的原因及解决方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">cookie和session的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#https%E7%9A%84%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="nav-number">15.</span> <span class="nav-text">Https的加密流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">GET 和 POST 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">17.</span> <span class="nav-text">http请求报文格式和响应报文格式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http1.0-http1.1-http2.0%E7%89%B9%E6%80%A7%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">http1.0 http1.1
http2.0特性及区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#http1.0%E7%89%B9%E6%80%A7"><span class="nav-number">18.1.</span> <span class="nav-text">http1.0特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="nav-number">18.1.1.</span> <span class="nav-text">无状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5"><span class="nav-number">18.1.2.</span> <span class="nav-text">无连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http1.1%E7%89%B9%E6%80%A7"><span class="nav-number">18.2.</span> <span class="nav-text">http1.1特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="nav-number">18.2.1.</span> <span class="nav-text">长连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%8C%96"><span class="nav-number">18.2.2.</span> <span class="nav-text">管道化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86"><span class="nav-number">18.2.3.</span> <span class="nav-text">缓存处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E7%82%B9%E4%BC%A0%E8%BE%93"><span class="nav-number">18.2.4.</span> <span class="nav-text">断点传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http2.0%E7%89%B9%E6%80%A7"><span class="nav-number">18.3.</span> <span class="nav-text">http2.0特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7"><span class="nav-number">18.3.1.</span> <span class="nav-text">二进制分帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">18.3.2.</span> <span class="nav-text">多路复用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">18.4.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">19.</span> <span class="nav-text">http协议的几种方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dns%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">20.</span> <span class="nav-text">DNS工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dns%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84"><span class="nav-number">20.1.</span> <span class="nav-text">DNS域名结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dns%E6%9C%8D%E5%8A%A1%E7%94%B1%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">20.2.</span> <span class="nav-text">DNS服务由客户端到服务器的工作原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#osi%E4%B8%83%E5%B1%82%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">21.</span> <span class="nav-text">OSI七层、五层模型，每一层的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%BE%E4%BE%8B"><span class="nav-number">21.1.</span> <span class="nav-text">OSI七层模型举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="nav-number">21.2.</span> <span class="nav-text">OSI七层模型总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8%E4%BA%86cookie%E4%BB%A5%E5%90%8E%E8%BF%98%E8%83%BD%E7%94%A8session%E5%90%97"><span class="nav-number">22.</span> <span class="nav-text">浏览器禁用了Cookie以后还能用Session吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">23.</span> <span class="nav-text">Http响应状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#http-%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB"><span class="nav-number">23.1.</span> <span class="nav-text">HTTP 状态码分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95getpostputdelete"><span class="nav-number">24.</span> <span class="nav-text">HTTP的四种请求方法GET、POST、PUT、DELETE</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#close_wait%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">25.</span> <span class="nav-text">close_wait的作用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

