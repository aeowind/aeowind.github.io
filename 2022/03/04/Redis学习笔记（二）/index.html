<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="文明能压碎，情怀不衰，无论枯干山水">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习笔记（二）">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="文明能压碎，情怀不衰，无论枯干山水">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.431Z">
<meta property="article:modified_time" content="2021-09-02T02:24:23.400Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="工具">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis学习笔记（二） | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis学习笔记（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 10:24:23" itemprop="dateModified" datetime="2021-09-02T10:24:23+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/%E5%B7%A5%E5%85%B7/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">文明能压碎，情怀不衰，无论枯干山水</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="事务">事务</h2>
<p><strong>redis
事务</strong>一次可以执行多条命令，服务器在执行命令期间，不会去执行其他客户端的命令请求。</p>
<p>事务中的<strong>多条命令被一次性发送</strong>给服务器，而不是一条一条地发送，这种方式被称为<code>流水线</code>，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>Redis 最简单的事务实现方式是使用 <code>MULTI</code> 和
<code>EXEC</code> 命令将事务操作包围起来。</p>
<p>批量操作在发送 EXEC 命令前被放入队列缓存。</p>
<p>收到 EXEC
命令后进入事务执行，事务中任意命令执行失败，其余命令依然被执行。也就是说
Redis 事务不保证原子性。</p>
<p>在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>一个事务从开始到执行会经历以下<strong>三个阶段</strong>：</p>
<ol type="1">
<li><p>开始事务。</p></li>
<li><p>命令入队。</p></li>
<li><p>执行事务。</p></li>
</ol>
<h3 id="实例">实例</h3>
<p>以下是一个事务的例子，它先以 <code>MULTI</code>
开始一个事务，然后将多个命令入队到事务中，最后由 <code>EXEC</code>
命令触发事务， 一并执行事务中的所有命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET book-name <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD tag <span class="string">&quot;C++&quot;</span> <span class="string">&quot;Programming&quot;</span> <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">3</span></span><br><span class="line"><span class="number">4</span>) <span class="number">1</span>) <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;C++&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;Programming&quot;</span></span><br></pre></td></tr></table></figure>
<p>单个 Redis 命令的执行是原子性的，但 Redis
没有在事务上增加任何维持原子性的机制，所以 <strong>Redis
事务的执行并不是原子性的</strong>。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<h3 id="redis-事务命令">Redis 事务命令</h3>
<p>下表列出了 <strong>redis 事务的相关命令</strong>：</p>
<p>序号命令及描述：</p>
<ol type="1">
<li><p><code>DISCARD</code>
取消事务，放弃执行事务块内的所有命令。</p></li>
<li><p><code>EXEC</code> 执行所有事务块内的命令。</p></li>
<li><p><code>MULTI</code> 标记一个事务块的开始。</p></li>
<li><p><code>UNWATCH</code> 取消 WATCH 命令对所有 key 的监视。</p></li>
<li><p><code>WATCH key [key …]</code>监视一个 (或多个) key
，如果在事务执行之前这个 (或这些) key
被其他命令所改动，那么事务将被打断。</p></li>
</ol>
<h3 id="事务异常">事务异常</h3>
<blockquote>
<p>编译型异常</p>
</blockquote>
<p>编译型异常（语法错误），编译不能通过,事务中所有的命令都不会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6379&gt; MULTI</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; set k1 v1</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; set k2 v2</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; getset k3 v33</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; getset k2   #错误的命令语法</span><br><span class="line"> (error) ERR wrong number of arguments for &#x27;getset&#x27; command</span><br><span class="line"> 127.0.0.1:6379&gt; set k4 v4</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; EXEC</span><br><span class="line"> (error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"> 127.0.0.1:6379&gt; get k1</span><br><span class="line"> (nil)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行时异常</p>
</blockquote>
<p>运行时异常就是命令逻辑错误,但编译时可以通过</p>
<p>运行时异常事务中的逻辑错误命令不会被执行,其他命令正常执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6379&gt; MULTI</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; set k1 v1</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; incr k1  #命令逻辑错误</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; set k2 v2</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; set k3 v3</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; EXEC  #执行事务</span><br><span class="line"> 1) OK</span><br><span class="line"> 2) (error) ERR value is not an integer or out of range #运行时异常事务中的逻辑错误命令不会被执行,其他命令正常执行</span><br><span class="line"> 3) OK</span><br><span class="line"> 4) OK</span><br><span class="line"> 127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line"> 1) &quot;v1&quot;</span><br><span class="line"> 2) &quot;v2&quot;</span><br><span class="line"> 3) &quot;v3&quot;</span><br></pre></td></tr></table></figure>
<h3 id="监视事务">监视事务</h3>
<p><code>Redis Watch</code> 命令用于<strong>监视一个(或多个)
key</strong>，如果在事务执行之前这个(或这些) key
被其他命令所改动，那么事务将被打断。</p>
<blockquote>
<p>正常执行事务并监控</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6379&gt; set money 100  #模拟账户余额</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; set out 0  #模拟支出金额</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; watch money  #监控money</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; MULTI</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; DECRBY money 20  #账户余额减少20</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; INCRBY out 20  #支出金额变为20</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; EXEC  #执行事务，事务正常执行</span><br><span class="line"> 1) (integer) 80</span><br><span class="line"> 2) (integer) 20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模拟事务执行前key被改动</p>
</blockquote>
<ol type="1">
<li>监控money，在事务队列中放入指令，先不执行：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6379&gt; watch money</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; MULTI</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; DECRBY money 10</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; INCRBY out 10</span><br><span class="line"> QUEUED</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>开启一个redis 客户端，修改money 这个key的值：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6379&gt; get money</span><br><span class="line"> &quot;80&quot;</span><br><span class="line"> 127.0.0.1:6379&gt; set money 1000</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; get money</span><br><span class="line"> &quot;1000&quot;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>执行事务，事务执行失败：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6379&gt; watch money</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; MULTI</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; DECRBY money 10</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; INCRBY out 10</span><br><span class="line"> QUEUED</span><br><span class="line"> 127.0.0.1:6379&gt; EXEC</span><br><span class="line"> (nil)</span><br></pre></td></tr></table></figure>
<p><strong>watch指令</strong>类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用<code>EXEC</code>执行事务时，事务队列将不会被执行，同时返回<code>Nullmulti-bulk</code>应答以通知调用者事务执行失败。</p>
<blockquote>
<p>unwatch</p>
</blockquote>
<p><strong>Unwatch</strong> 命令用于<strong>取消</strong> WATCH
命令对所有 key 的监视。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6379&gt; watch money</span><br><span class="line"> OK</span><br><span class="line"> 127.0.0.1:6379&gt; unwatch</span><br><span class="line"> OK</span><br></pre></td></tr></table></figure>
<h2 id="持久化">持久化</h2>
<p><strong>Redis</strong>
是<strong>内存型数据库</strong>，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h3 id="rdb-持久化">RDB 持久化</h3>
<p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p>
<p>如果数据量大，保存快照的时间会很长。</p>
<p><strong>RDB持久化</strong>是指在指定的时间间隔内将内存中的所有数据快照写入磁盘。也是默认的持久化方式，这种方式是就是把内存中数据以快照的形式保存在磁盘上写入到二进制文件中,默认的文件名为<code>dump.rdb</code>。</p>
<h4 id="是什么">是什么</h4>
<ul>
<li><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是<strong>Snapshot快照</strong>，它恢复时是将快照文件直接读到内存里。</p></li>
<li><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<code>RDB的缺点</code>是<strong>最后一次持久化后的数据可能丢失</strong>。</p></li>
</ul>
<blockquote>
<p><strong>Fork</strong><br />
<code>Fork的作用</code>是<strong>复制</strong>一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）
数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</blockquote>
<p><strong>rdb</strong> 保存的是<code>dump.rdb文件</code></p>
<p>相关配置在配置文件的位置 -
在<code>redis.conf</code>搜寻<code>### SNAPSHOTTING ###</code></p>
<h4 id="触发rdb持久化的三种机制">触发RDB持久化的三种机制</h4>
<ol type="1">
<li><strong>save触发方式</strong></li>
</ol>
<p>该命令会阻塞<strong>当前Redis服务器</strong>，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hBWVwF"><img
src="https://z3.ax1x.com/2021/09/01/hBWVwF.png"
alt="hBWVwF.png" /></a></p>
<ol start="2" type="1">
<li><strong>bgsave触发方式</strong></li>
</ol>
<p>执行该命令时，Redis会在<strong>后台异步进行快照操作</strong>，快照同时还可以响应客户端请求。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hBWJTe"><img
src="https://z3.ax1x.com/2021/09/01/hBWJTe.png"
alt="hBWJTe.png" /></a></p>
<p>上面两种是<code>手动</code>让 Redis 进行数据集保存操作。</p>
<ol start="3" type="1">
<li><strong>自动触发</strong></li>
</ol>
<p><strong>自动触发</strong>是由 <code>redis.conf</code>
配置文件来完成的。关于自动触发的配置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#============================ SNAPSHOTTING ============================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#save 设置redis进行数据库镜像的频率</span><br><span class="line"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）</span><br><span class="line">save 900 1</span><br><span class="line"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）</span><br><span class="line">save 300 10</span><br><span class="line"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在开启了 RDB 快照后，如果最近的一次 RDB 快照在后台生成失败的话，Redis 默认会拒绝所有的写请求。这样以一种强硬的方式让用#户知道数据不能正确的持久化到磁盘，否则就会没人注意到灾难的发生。如果后台保存进程重新启动工作了，redis 也将自动的允许写操#作。如果你已经为你的 Redis 实例和持久化配置了合适的监控手段，你可能不希望 redis 这样做，就改成 no 好了。</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在生成 rdb（关系数据库）文件的时候使用 LZF 压缩算法 String 对象，yes：压缩，但是需要一些cpu的消耗。</span><br><span class="line">#no：不压缩，需要更多的磁盘空间</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#从 5.0 版本开始 RDB 文件的末尾会默认放置一个 CRC64 的校验码。</span><br><span class="line">#是否校验rdb文件，这会让文件的格式更加容易检验验证，代价是生成和加载 RDB 文件的性能会损失 10% 左右。你可以把该配置关闭以#求更佳的性能。</span><br><span class="line">#没有开启校验码配置的 RDB 文件会将校验码设置为 0，加载该文件的程序就会跳过校验过程。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置 rdb 文件的名称。默认值为 dump.rdb</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#rdb文件是否删除同步锁</span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure>
<p><strong>自动触发持久化</strong>，本质是 <code>Redis</code>
通过判断，如果满足设置的触发条件，自动执行一次 <code>bgsave</code>
命令。 注意：当设置多个 <code>save m n</code>
命令时，满足任意一个条件都会触发持久化。</p>
<h4 id="rdb快照的运作方式">RDB快照的运作方式</h4>
<p>当 Redis 需要保存 <code>dump.rdb</code> 文件时，
服务器执行以下操作：</p>
<ol type="1">
<li>Redis 调用 <code>fork()</code> ，同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个<code>临时 RDB 文件</code>中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB
文件，并删除旧的 RDB 文件。</li>
</ol>
<p>这种工作方式使得 Redis
可以从<code>写时复制（copy-on-write）机制</code>中获益。</p>
<h4 id="优势与劣势">优势与劣势</h4>
<blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
<blockquote>
<p>劣势</p>
</blockquote>
<ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就
会丢失最后一次快照后的所有修改</li>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ul>
<h4 id="小结">小结</h4>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hZe8qe"><img
src="https://z3.ax1x.com/2021/08/25/hZe8qe.png"
alt="hZe8qe.png" /></a></p>
<ul>
<li><p><strong>RDB</strong>是一个非常紧凑的文件。</p></li>
<li><p><strong>RDB</strong>在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他I0操作，所以RDB持久化方式可以最大化redis的性能。</p></li>
<li><p>与AOF相比，在恢复大的数据集的时候，<strong>RDB</strong>方式会更快一些。
数据丢失风险大。</p></li>
<li><p><strong>RDB</strong>需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候fork的过程是非常耗时的，可能会导致Redis在一些毫秒级不能回应客户端请求。</p></li>
</ul>
<h3 id="aof-持久化">AOF 持久化</h3>
<p>将写命令添加到 <strong>AOF 文件（append only
file）末尾</strong>。</p>
<p>使用<code>AOF 持久化</code>需要<strong>设置同步选项</strong>，从而确保写命令同步到磁盘文件上的时机。</p>
<p>这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。</p>
<p>选项同步频率always每个写命令都同步eyerysec每秒同步一次no让操作系统来决定何时同步</p>
<p><strong>always 选项</strong>会严重减低服务器的性能</p>
<p><strong>everysec
选项</strong>比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且
Redis 每秒执行一次同步对服务器几乎没有任何影响。</p>
<p><strong>no
选项</strong>并不能给服务器性能带来多大的提升，而且会增加系统崩溃时数据丢失的数量。</p>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF
重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h4 id="是什么-1">是什么</h4>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<h4 id="aof配置">AOF配置</h4>
<ul>
<li><p>相关配置在配置文件的位置 -
在<code>redis.conf</code>搜寻<code>### APPEND ONLY MODE ###</code></p></li>
<li><p>AOF保存的是<code>appendonly.aof</code>文件（在配置文件可修改文件名）</p></li>
</ul>
<h4 id="aof启动修复恢复">AOF启动/修复/恢复</h4>
<ul>
<li>正常恢复
<ul>
<li>启动：设置Yes
<ul>
<li>修改默认的appendonly no，改为yes</li>
</ul></li>
<li>将有数据的AOF文件复制一份保存到对应目录(config get dir)</li>
<li>恢复：重启redis然后重新加载</li>
</ul></li>
<li>异常恢复
<ul>
<li>启动：设置Yes
<ul>
<li>修改默认的appendonly no，改为yes</li>
</ul></li>
<li>备份被写坏的AOF文件</li>
<li>修复：
<ul>
<li>Redis-check-aof --fix进行修复</li>
</ul></li>
<li>恢复：重启redis然后重新加载</li>
</ul></li>
</ul>
<h4 id="rewrite">rewrite</h4>
<ul>
<li><p><strong>是什么</strong><br />
AOF采用文件追加方式，文件会越来越大。为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令bgrewriteaof。</p></li>
<li><p><strong>重写原理</strong><br />
AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写AOF文件的操作，并没有读取旧的AOF文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</p></li>
<li><p><strong>触发机制</strong><br />
Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p></li>
</ul>
<h4 id="优势与劣势-1">优势与劣势</h4>
<ul>
<li><p><strong><em>优势</em></strong></p>
<ul>
<li><p><strong>每修改同步</strong>：appendfsync always 同步持久化
每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p></li>
<li><p><strong>每秒同步</strong>：appendfsync everysec
异步操作，每秒记录 如果一秒内宕机，有数据丢失</p></li>
<li><p><strong>不同步</strong>：appendfsync no 从不同步</p></li>
</ul></li>
<li><p><strong><em>劣势</em></strong></p>
<ul>
<li><p>相同数据集的数据而言AOF文件要远大于RDB文件，恢复速度慢于RDB</p></li>
<li><p>AOF运行效率要慢于RDB,每秒同步策略效率较好，不同步效率和RDB相同</p></li>
</ul></li>
</ul>
<h4 id="小结-1">小结</h4>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hniDJ0"><img
src="https://z3.ax1x.com/2021/08/26/hniDJ0.png"
alt="hniDJ0.png" /></a></p>
<ul>
<li><p>AOF文件是一个只进行追加的日志文件</p></li>
<li><p>Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写</p></li>
<li><p>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松</p></li>
<li><p>对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积</p></li>
<li><p>根据所使用的fsync策略，AOF的速度可能会慢于RDB</p></li>
</ul>
<h2 id="复制">复制</h2>
<p>通过使用
<code>slaveof host port 命令</code>来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h3 id="连接过程">连接过程</h3>
<ol type="1">
<li><p>主服务器创建快照文件，即 RDB
文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。</p></li>
<li><p>快照文件发送完毕之后，开始像从服务器发送存储在缓冲区的写命令。</p></li>
<li><p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。</p></li>
<li><p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p></li>
</ol>
<h3 id="主从链">主从链</h3>
<p>随着负载不断上升，主服务器无法很快的更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。</p>
<p>为了解决这个问题，可以<strong>创建一个中间层</strong>来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<h2 id="哨兵">哨兵</h2>
<p><strong>Sentinel（哨兵）</strong>
可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h3 id="哨兵模式概述">哨兵模式概述</h3>
<blockquote>
<p>主从切换</p>
</blockquote>
<p>当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了<strong>Sentinel
(哨兵）模式</strong>来解决这个问题。</p>
<blockquote>
<p>哨兵模式概述</p>
</blockquote>
<p><strong>Sentinel
哨兵模式</strong>是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其<code>原理</code>是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
<p><code>哨兵模式作用：</code></p>
<ul>
<li><p>监控（Monitoring）： Sentinel
会不断地检查你的主服务器和从服务器是否运作正常。</p></li>
<li><p>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时，
Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p></li>
<li><p><strong>自动故障迁移（Automatic failover）</strong>：
当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作，
它会将失效主服务器的其中一个从服务器升级为新的主服务器，
并让失效主服务器的其他从服务器改为复制新的主服务器；
当客户端试图连接失效的主服务器时，
集群也会向客户端返回新主服务器的地址，
使得集群可以使用新主服务器代替失效服务器。<strong>在只有少数 Sentinel
进程正常运作的情况下， Sentinel
是不能执行自动故障迁移的。</strong></p></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hBz24A"><img
src="https://z3.ax1x.com/2021/09/01/hBz24A.png"
alt="hBz24A.png" /></a></p>
<blockquote>
<p>多哨兵模式</p>
</blockquote>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hBzoDS"><img
src="https://z3.ax1x.com/2021/09/01/hBzoDS.png"
alt="hBzoDS.png" /></a></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover（故障转移）过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<h3 id="搭建-sentinel-集群">搭建 Sentinel 集群</h3>
<blockquote>
<p>redis 集群搭建</p>
</blockquote>
<p>在主从复制中，已经搭建好了一个"一主二从"的redis服务集群</p>
<p>主节点的配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=32942,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=32942,lag=1</span><br><span class="line">master_replid:082b4fc582bc5ced7fde2b9566d13fbfe87ee8e5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:32942</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:32942</span><br></pre></td></tr></table></figure>
<p>两个从节点的配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:5</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:32816</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:082b4fc582bc5ced7fde2b9566d13fbfe87ee8e5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:32816</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:32816</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:32830</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:082b4fc582bc5ced7fde2b9566d13fbfe87ee8e5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:32830</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:729</span><br><span class="line">repl_backlog_histlen:32102</span><br></pre></td></tr></table></figure>
<blockquote>
<p>搭建 Sentinel 集群</p>
</blockquote>
<ol type="1">
<li>创建<code>sentinel.conf</code>配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>配置文件说明：</li>
</ol>
<ul>
<li><p><code>port</code>：当前Sentinel服务运行的端口</p></li>
<li><p><code>dir</code>： Sentinel服务运行时使用的临时文件夹</p></li>
<li><p><code>sentinel monitor master001 127.0.0.1 6379 2</code>：Sentinel
去监视一个名为 mymaster 的主服务器， 这个主服务器的 IP 地址为 127.0.0.1
， 端口号为 6379 ， 而将这个主服务器判断为失效至少需要 2 个 Sentinel
同意 （只要同意 Sentinel
的数量不达标，自动故障迁移就不会执行）。</p></li>
<li><p><code>sentinel down-after-milliseconds master001 60000</code>：指定了Sentinel认为Redis实例已经失效所需的毫秒数。当实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线。只有一个
Sentinel进程将实例标记为主观下线并不一定会引起redis实例的自动故障迁移，只有在足够数量的Sentinel都将一个redis实例标记为主观下线之后，实例才会被标记为客观下线，这时自动故障迁移才会执行</p></li>
<li><p><code>sentinel parallel-syncs master001 1</code>：指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</p></li>
<li><p><code>sentinel failover-timeout master001 180000</code>：如果在该时间（ms）内未能完成failover操作，则认为该failover失败</p></li>
</ul>
<ol start="3" type="1">
<li>需要三份 <code>sentinel.conf</code> 配置文件</li>
</ol>
<p>分别为
<code>sentinel26379.conf</code>，<code>sentinel36379.conf</code>，<code>sentinel46379.conf</code>，配置文件中端口号分别为：26379、36379、46379</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hDpZJs"><img
src="https://z3.ax1x.com/2021/09/01/hDpZJs.png"
alt="hDpZJs.png" /></a></p>
<ol start="4" type="1">
<li>启动 <code>sentinel</code> 集群</li>
</ol>
<p>端口号为 26379的 <code>sentinel</code> 服务启动成功：</p>
<p><strong>Sentinel
可以通过发布与订阅功能来自动发现正在监视相同主服务器的其他
Sentinel</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hDpgSI"><img
src="https://z3.ax1x.com/2021/09/01/hDpgSI.png"
alt="hDpgSI.png" /></a></p>
<p>端口号为 36379的 sentinel 服务启动成功</p>
<p>端口号为 46379的 sentinel 服务启动成功</p>
<h3 id="sentinel-集群测试">sentinel 集群测试</h3>
<ol type="1">
<li>测试主节点宕机的情况</li>
</ol>
<p>关闭主节点的redis服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; exit</span><br></pre></td></tr></table></figure>
<p>查看三个 <code>sentinel</code> 服务输出的日志信息：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hD9ptJ"><img
src="https://z3.ax1x.com/2021/09/01/hD9ptJ.png"
alt="hD9ptJ.png" /></a></p>
<p>再查看6381节点的配置信息：6381节点的角色为主节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=264493,lag=1</span><br><span class="line">master_replid:b596a14ae6f36ff8cae2592f66c5a8fedf471817</span><br><span class="line">master_replid2:082b4fc582bc5ced7fde2b9566d13fbfe87ee8e5</span><br><span class="line">master_repl_offset:264759</span><br><span class="line">second_repl_offset:202192</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:729</span><br><span class="line">repl_backlog_histlen:264031</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>原主节点重新启动后的情况</li>
</ol>
<p>原主节点重新启动后，sentinel 服务输出了下面这样一行日志信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23349:X 21 Aug 2021 21:50:29.596 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure>
<p>意思为：6379 redis节点转换为了从节点，主节点为6381 redis节点</p>
<p>原主节点的配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6381</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:0</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:311402</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:b596a14ae6f36ff8cae2592f66c5a8fedf471817</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:311402</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:309105</span><br><span class="line">repl_backlog_histlen:2298</span><br></pre></td></tr></table></figure>
<p><strong>验证</strong>：发现原主节点还在redis集群中，确实变为了新主节点的从节点。</p>
<h3 id="哨兵模式的所有配置详解">哨兵模式的所有配置详解</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf </span><br><span class="line"># 哨兵sentinel实例运行的端口 默认26379 </span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 哨兵sentinel的工作目录 </span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="line"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。 </span><br><span class="line"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了 </span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供 密码</span><br><span class="line"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt; </span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 </span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 </span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; </span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那 里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时， slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># SCRIPTS EXECUTION</span><br><span class="line"></span><br><span class="line">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。 </span><br><span class="line">#对于脚本的运行结果有以下规则： </span><br><span class="line">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 </span><br><span class="line">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 </span><br><span class="line">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 </span><br><span class="line">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 </span><br><span class="line">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信 息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。 </span><br><span class="line">#通知脚本 </span><br><span class="line"># shell编程 </span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"># 客户端重新配置主节点参数脚本 </span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已 经发生改变的信息。 </span><br><span class="line"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line"># 目前&lt;state&gt;总是“failover”,</span><br><span class="line"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="line"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通 信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的。 </span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; </span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！</span><br></pre></td></tr></table></figure>
<h2 id="分片">分片</h2>
<p><strong>分片</strong>是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0, R1, R2, R3, 还有很多表示用户的键 user:1,
user:2, … , 有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<p>最简单的是<strong>范围分片</strong>，例如用户 id 从 0 ~ 1000
的存储到实例 R0 中，用户 id 从 1001 ~ 2000 的存储到实例
R1中，等等。但是这样需要维护一张映射范围表，维护操作代价高。</p>
<p>还有一种是<strong>哈希分片</strong>。使用 CRC32
哈希函数将键转换为一个数字，再对实例数量求模就能知道存储的实例。</p>
<p>根据执行分片的位置，可以分为<code>三种分片方式</code>：</p>
<p><strong>客户端分片</strong>：客户端使用一致性哈希等算法决定应当分布到哪个节点。</p>
<p><strong>代理分片</strong>：将客户端的请求发送到代理上，由代理转发到正确的节点上。</p>
<p><strong>服务器分片</strong>：Redis Cluster。</p>
<h2 id="jedis">Jedis</h2>
<h3 id="jedis概述">Jedis概述</h3>
<p><code>Jedis</code>
是Redis官方推荐的<strong>Java连接开发工具</strong>。</p>
<p><code>Jedis</code> 是一个非常小且智能的<strong>Redis
java客户端</strong>，并且易于使用。</p>
<p><code>Jedis</code> 与redis 2.8.x、3.x.x及以上版本完全兼容。</p>
<blockquote>
<p>如何下载 Jedis</p>
</blockquote>
<ol type="1">
<li>下载最新版本使用</li>
</ol>
<p>Jedis下载地址：<a
target="_blank" rel="noopener" href="https://github.com/redis/jedis/releases/">github.com/redis/jedis…</a></p>
<ol start="2" type="1">
<li>导入依赖使用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用jedis">使用Jedis</h3>
<blockquote>
<p>连接 Redis 服务</p>
</blockquote>
<ol type="1">
<li>新建一个<code>maven项目</code>，导入依赖：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="attr">https</span>:<span class="comment">//mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="attr">https</span>:<span class="comment">//mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.78<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>启动本地 Redis 服务，启动完成！</p></li>
<li><p>连接本地 Redis 服务</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);<span class="comment">//连接本地redis服务</span></span><br><span class="line">        System.out.println(jedis.ping()); <span class="comment">//PONG</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接成功！</p>
<p><strong><em>补充：连接远程 Redis 的步骤：</em></strong></p>
<ol type="1">
<li>配置<code>redis.conf</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 设置访问redis的密码：requirepass 要设置的密码</span><br><span class="line">2. 注释bind 127.0.0.1</span><br><span class="line">3. 重启redis-server服务,进入redis后要先验证密码,用这个命令：auth 密码 ,然后ping一下看有没有配置成功</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>idea访问时添加<code>auth密码</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(服务器的外网ip,<span class="number">6379</span>);</span><br><span class="line">jedis.auth(redis的密码);</span><br><span class="line">System.out.println(jedis.ping());</span><br></pre></td></tr></table></figure>
<p>输出<strong>PONG</strong>的话就成功了</p>
<blockquote>
<p>测试 Redis 实例</p>
</blockquote>
<p><code>Redis Keys</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);<span class="comment">//连接本地redis服务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;清空当前数据库数据：&quot;</span>+jedis.flushDB());</span><br><span class="line">        System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;设置键值对：&quot;</span>+jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wanli&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;设置键值对：&quot;</span>+jedis.set(<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;123456&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;设置键值对：&quot;</span>+jedis.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;查看所有key：&quot;</span>+jedis.keys(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;删除key：&quot;</span>+jedis.keys(<span class="string">&quot;pwd&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;查看key的类型：&quot;</span>+jedis.type(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;随机返回一个key：&quot;</span>+jedis.randomKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;按下标查询key：&quot;</span>+jedis.select(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回当前数据库key的数目：&quot;</span>+jedis.dbSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;清空所有数据库的数据：&quot;</span>+jedis.flushAll());    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Redis String(字符串)</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);<span class="comment">//连接本地redis服务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========增加数据===========&quot;</span>);</span><br><span class="line">        System.out.println(jedis.set(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>));</span><br><span class="line">        System.out.println(jedis.set(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>));</span><br><span class="line">        System.out.println(jedis.set(<span class="string">&quot;k3&quot;</span>,<span class="string">&quot;v3&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;在k2后面追加值：&quot;</span>+jedis.append(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;LAST&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;k2的值：&quot;</span>+jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;增加多个k-v：&quot;</span>+jedis.mset(<span class="string">&quot;k4&quot;</span>,<span class="string">&quot;v4&quot;</span>,<span class="string">&quot;k5&quot;</span>,<span class="string">&quot;v5&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;获取多个k-v：&quot;</span>+jedis.mset(<span class="string">&quot;k4&quot;</span>,<span class="string">&quot;k5&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;删除多个k-v：&quot;</span>+jedis.del(<span class="string">&quot;k4&quot;</span>,<span class="string">&quot;k5&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.flushDB());</span><br><span class="line">        System.out.println(<span class="string">&quot;==========新增键值对防止覆盖原先值===========&quot;</span>);</span><br><span class="line">        System.out.println(jedis.setnx(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>));</span><br><span class="line">        System.out.println(jedis.setnx(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>));</span><br><span class="line">        System.out.println(jedis.setnx(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;value2&quot;</span>));</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==========新增键值对并设置过期时间===========&quot;</span>);</span><br><span class="line">        System.out.println(jedis.setex(<span class="string">&quot;k3&quot;</span>,<span class="number">5</span>,<span class="string">&quot;v3&quot;</span>));</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k3&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">6</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k3&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;==========获取原来值，设置为新值===========&quot;</span>);</span><br><span class="line">        System.out.println(jedis.getSet(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;getsetv2&quot;</span>));</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;获取指定范围的字符串：&quot;</span>+jedis.getrange(<span class="string">&quot;k2&quot;</span>,<span class="number">2</span>,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Redis List(列表)</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);<span class="comment">//连接本地redis服务</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//存储数据到列表中</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;site-list&quot;</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;site-list&quot;</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;site-list&quot;</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取存储的数据并输出</span></span><br><span class="line">        List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;site-list&quot;</span>, <span class="number">0</span> ,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;列表项为: &quot;</span>+list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Jedis 操作事务</p>
</blockquote>
<ol type="1">
<li>事务正常执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);<span class="comment">//连接本地redis服务</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        object.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;shenming&quot;</span>);</span><br><span class="line">        object.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();<span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> object.toJSONString(); <span class="comment">//将java对象转换为json格式</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>,string); <span class="comment">//命令入队</span></span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>,string);</span><br><span class="line">            multi.exec(); <span class="comment">//执行事务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            multi.discard();  <span class="comment">//如果有异常就放弃事务</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close(); <span class="comment">//断开连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>事务运行时异常</li>
</ol>
<p>在命令入队时加上 <code>int i = 10 / 0</code></p>
<p>因为存在运行时异常，事务执行失败。</p>
<h2 id="主从复制">主从复制</h2>
<h3 id="主从复制概述">主从复制概述</h3>
<p><strong>主从复制</strong>，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为<code>主节点</code>(master/leader)，后者称为<code>从节点</code>(slave/follower);数据的复制是单向的，只能由主节点到从节点。<strong>Master以写为主，Slave以读为主。</strong></p>
<p>默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<blockquote>
<p><strong>主从复制的作用</strong>主要包括:</p>
</blockquote>
<ol type="1">
<li><p><strong>数据冗余</strong>∶
主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p></li>
<li><p><strong>故障恢复</strong>∶
当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。</p></li>
<li><p><strong>负载均衡</strong>∶
在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p></li>
<li><p><strong>高可用基石</strong>︰
除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p></li>
</ol>
<blockquote>
<p>主从复制架构</p>
</blockquote>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下:</p>
<ol type="1">
<li><p>从结构上，单个Redis服务器会发生<strong>单点故障</strong>（如宕机），并且一台服务器需要处理所有的请求负载，压力较大;</p></li>
<li><p>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，<strong>单台Redis最大使用内存不应该超过20G</strong>。</p></li>
</ol>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是"多读少写"。</p>
<p>对于这种场景，我们可以使如下这种架构︰<strong>主从复制，读写分离</strong>。主机复制写，从机只能读。</p>
<h3 id="配置主从复制环境">配置主从复制环境</h3>
<p>我们<strong>只需要配置从节点</strong>，不用配置主节点。因为默认情况下，当前每台Redis服务器都是主节点。</p>
<p>启动redis服务，并查看该redis服务节点的信息：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hBXAII"><img
src="https://z3.ax1x.com/2021/09/01/hBXAII.png"
alt="hBXAII.png" /></a></p>
<ol type="1">
<li>首先复制三份配置文件，用于启动三个redis节点（一主二从）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hBXGiq"><img
src="https://z3.ax1x.com/2021/09/01/hBXGiq.png"
alt="hBXGiq.png" /></a></p>
<ol start="2" type="1">
<li>配置三个redis服务</li>
</ol>
<p>输入命令：<code>vim redis79.conf</code>，修改如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6379  #端口6379</span><br><span class="line">daemonize yes  #后台启动</span><br><span class="line">pidfile /var/run/redis_6379.pid  ##配置PID文件路径</span><br><span class="line">logfile &quot;6379.log&quot;  #日志文件名</span><br><span class="line">dbfilename dump6379.rdb  #rdb文件名</span><br></pre></td></tr></table></figure>
<p>输入命令：<code>vim redis80.conf</code>，修改如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6380  #端口6380</span><br><span class="line">daemonize yes  #后台启动</span><br><span class="line">pidfile /var/run/redis_6380.pid  ##配置PID文件路径</span><br><span class="line">logfile &quot;6380.log&quot;  #日志文件名</span><br><span class="line">dbfilename dump6380.rdb  #rdb文件名</span><br></pre></td></tr></table></figure>
<p>输入命令：<code>vim redis81.conf</code>，修改如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6381  #端口6381</span><br><span class="line">daemonize yes  #后台启动</span><br><span class="line">pidfile /var/run/redis_6381.pid  ##配置PID文件路径</span><br><span class="line">logfile &quot;6381.log&quot;  #日志文件名</span><br><span class="line">dbfilename dump6381.rdb  #rdb文件名</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>启动三个redis服务节点</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hBX5TA"><img
src="https://z3.ax1x.com/2021/09/01/hBX5TA.png"
alt="hBX5TA.png" /></a></p>
<p>启动成功，redis集群搭建完成！</p>
<blockquote>
<p>配置从节点</p>
</blockquote>
<p>我们只需要配置从节点，不用配置主节点。因为默认情况下，当前每台Redis服务器都是主节点。</p>
<p>上面的三台redis服务节点默认都是主节点。</p>
<p>现在把6380和6381配置为从节点，6379为主节点，不用配置</p>
<p><code>配置方式一</code>：调用 <strong>slaveof</strong> 命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379  </span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>查看主节点6379的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=742,lag=0</span><br><span class="line">master_replid:082b4fc582bc5ced7fde2b9566d13fbfe87ee8e5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:742</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:742</span><br></pre></td></tr></table></figure>
<p>这样就通过调用 <code>slaveof</code> 命令把 6380 服务节点配置成 6379
服务节点的从节点了</p>
<p><code>配置方式二</code>：在配置文件中配置。</p>
<p>打开 6381 服务的配置文件：在配置文件中增加以下的这一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>
<p>再查看主节点6379的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2  #从节点数量</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=1834,lag=1  #从节点配置信息</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=1834,lag=1</span><br><span class="line">master_replid:082b4fc582bc5ced7fde2b9566d13fbfe87ee8e5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1834</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:1834</span><br></pre></td></tr></table></figure>
<p>两个从节点就配置好了。</p>
<p><strong>真实的从机配置应该在配置文件中配置，这样是永久有效的。如果从机是用命令配置的，假设从机宕机了，从机重启后将不会再连接到主机上。</strong></p>
<h3 id="主从复制原理">主从复制原理</h3>
<p>Slave启动成功连接到 master 后会发送一个sync同步命令，</p>
<p>Master
接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p>
<p><strong>全量复制</strong>:slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p><strong>增量复制</strong>:Master继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是slave重新连接到master，一次完全同步（全量复制)将被自动执行。</p>
<h2 id="缓存穿透缓存击穿缓存雪崩">缓存穿透，缓存击穿，缓存雪崩</h2>
<h3 id="缓存穿透">缓存穿透</h3>
<blockquote>
<p>问题描述：</p>
</blockquote>
<p>key 对应的数据在数据源并不存在，每次针对此 key
的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户
id
获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hD9Uhj"><img
src="https://z3.ax1x.com/2021/09/01/hD9Uhj.png"
alt="hD9Uhj.png" /></a></p>
<p><strong>造成缓存穿透的可能原因：</strong> 1. redis查询不到服务器 2.
出现很多非正常的url访问</p>
<p><strong>缓存穿透带来的结果：</strong></p>
<ol type="1">
<li>应用服务器压力变大</li>
<li>redis命中率变低</li>
<li>web服务一直查询数据库</li>
</ol>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<ul>
<li>解决方案：</li>
</ul>
<ol type="1">
<li><p><strong>对空值缓存</strong>∶如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果(
null )进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p></li>
<li><p><strong>设置可访问的名单(白名单)</strong> ：使用 bitmaps
类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和
bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p></li>
<li><p><strong>采用布隆过滤器</strong>︰(布隆过滤器(Bloom Filter
)是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数)。<br />
<strong>布隆过滤器</strong>可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br />
将所有可能存在的数据哈希到一个足够大的 <code>bitmaps</code>
中，一个一定不存在的数据会被这个 <code>bitmaps</code>
拦截掉，从而避免了对底层存储系统的查询压力。</p></li>
<li><p><strong>进行实时监控</strong>：当发现 Redis
的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p></li>
</ol>
<h3 id="缓存击穿">缓存击穿</h3>
<blockquote>
<p>问题描述：</p>
</blockquote>
<p>某个 key 对应的数据存在，但在 redis
中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hD9jgI"><img
src="https://z3.ax1x.com/2021/09/01/hD9jgI.png"
alt="hD9jgI.png" /></a></p>
<p><strong>缓存击穿原因：</strong> -
redis某个key过期，正好有大量请求访问这个热点key。比如微博热搜。</p>
<p><strong>缓存击穿现象:</strong></p>
<ol type="1">
<li>数据库访问压力瞬时增加</li>
<li>redis 里面没有出现大量 key 过期</li>
<li>redis 正常运行</li>
</ol>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题:缓存被“陆穿”的问题。</p>
<ul>
<li><strong>解决问题：</strong></li>
</ul>
<ol type="1">
<li><strong>预先设置热门数据</strong>:在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</li>
<li><strong>实时调整</strong>﹔现场监控哪些数据热门，实时调整key的过期时长。</li>
<li><strong>使用互斥锁</strong>：效率低
<ul>
<li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load
db。</li>
<li>先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的
SETNX或者Memcache的ADD )去set一个mutex key</li>
<li>当操作返回成功时，在进行 load db 操作，并回设缓存，最后删除 mutex
key；</li>
<li>当操作返回失败，证明有线程在 load
db，当前线程睡眠一段时间再重试整个get缓存的方法。</li>
</ul></li>
</ol>
<h3 id="缓存雪崩">缓存雪崩</h3>
<blockquote>
<p>问题描述：</p>
</blockquote>
<p><strong>缓存雪崩</strong>是指缓存中key大批量到过期时间，而查询key的请求巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指大量并发查同一个key，缓存雪崩是不同key都过期了，很多key的值都查不到从而查数据库。</p>
<p><strong>造成缓存雪崩原因：</strong></p>
<ul>
<li>缓存中key大批量到过期时间，而查询key的请求巨大</li>
</ul>
<p><strong>缓存雪崩造成的现象：</strong></p>
<ul>
<li>数据库压力过大服务器崩溃</li>
</ul>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>缓存失效时的雪崩效应对底层系统的冲击非常可怕!</p>
<p><strong>解决方案：</strong> 1. <strong>构建多级缓存架构</strong>:
nginx缓存+redis缓存+其他缓存( ehcache等) 2.
<strong>使用锁或队列</strong>：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。
3.
<strong>设置过期标志更新缓存</strong>：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。
4.
<strong>将缓存失效时间分散开</strong>：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag"><i class="fa fa-tag"></i> 工具</a>
              <a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i> Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/nexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/" rel="prev" title="nexT主题美化">
      <i class="fa fa-chevron-left"></i> nexT主题美化
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" rel="next" title="Redis学习笔记（三）">
      Redis学习笔记（三） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E4%BA%8B%E5%8A%A1%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.</span> <span class="nav-text">Redis 事务命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8"><span class="nav-number">1.3.</span> <span class="nav-text">事务异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E8%A7%86%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.4.</span> <span class="nav-text">监视事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rdb-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.1.</span> <span class="nav-text">RDB 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91rdb%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">触发RDB持久化的三种机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdb%E5%BF%AB%E7%85%A7%E7%9A%84%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.3.</span> <span class="nav-text">RDB快照的运作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="nav-number">2.1.4.</span> <span class="nav-text">优势与劣势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">2.1.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aof-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">AOF 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aof%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.2.</span> <span class="nav-text">AOF配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aof%E5%90%AF%E5%8A%A8%E4%BF%AE%E5%A4%8D%E6%81%A2%E5%A4%8D"><span class="nav-number">2.2.3.</span> <span class="nav-text">AOF启动&#x2F;修复&#x2F;恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rewrite"><span class="nav-number">2.2.4.</span> <span class="nav-text">rewrite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF-1"><span class="nav-number">2.2.5.</span> <span class="nav-text">优势与劣势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">2.2.6.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">连接过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E9%93%BE"><span class="nav-number">3.2.</span> <span class="nav-text">主从链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5"><span class="nav-number">4.</span> <span class="nav-text">哨兵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">哨兵模式概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA-sentinel-%E9%9B%86%E7%BE%A4"><span class="nav-number">4.2.</span> <span class="nav-text">搭建 Sentinel 集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sentinel-%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95"><span class="nav-number">4.3.</span> <span class="nav-text">sentinel 集群测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%80%E6%9C%89%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.4.</span> <span class="nav-text">哨兵模式的所有配置详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%89%87"><span class="nav-number">5.</span> <span class="nav-text">分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jedis"><span class="nav-number">6.</span> <span class="nav-text">Jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jedis%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.</span> <span class="nav-text">Jedis概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8jedis"><span class="nav-number">6.2.</span> <span class="nav-text">使用Jedis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.</span> <span class="nav-text">主从复制概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%8E%AF%E5%A2%83"><span class="nav-number">7.2.</span> <span class="nav-text">配置主从复制环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.</span> <span class="nav-text">主从复制原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">8.</span> <span class="nav-text">缓存穿透，缓存击穿，缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">8.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">8.2.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">8.3.</span> <span class="nav-text">缓存雪崩</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

