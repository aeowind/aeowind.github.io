<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="是的我看见到处是阳光，快乐在城市上空飘荡">
<meta property="og:type" content="article">
<meta property="og:title" content="消息中间件">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="是的我看见到处是阳光，快乐在城市上空飘荡">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.477Z">
<meta property="article:modified_time" content="2022-03-28T07:23:08.615Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>消息中间件 | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          消息中间件
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-28 15:23:08" itemprop="dateModified" datetime="2022-03-28T15:23:08+08:00">2022-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">是的我看见到处是阳光，快乐在城市上空飘荡</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>MQ ——消息中间件</strong>
说白了就是存消息的队列。具有一系列的优点，进而成为
<strong>异步RPC</strong>（异步、远距离调用）的主要手段之一。</p>
<h1 id="消息队列的使用场景">消息队列的使用场景</h1>
<p>消息队列主要有三大使用场景，分别是<strong>异步、流量削锋和应用解耦</strong>。另外还包含<strong>日志和消息通讯</strong>。</p>
<ul>
<li><strong>异步处理</strong> -
相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li><strong>应用解耦</strong> -
系统间通过消息通信，不用关心其他系统的处理。</li>
<li><strong>流量削锋</strong> -
可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li><strong>日志处理</strong> - 解决大量日志传输。</li>
<li><strong>消息通讯</strong> -
消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
</ul>
<h2 id="异步处理">异步处理</h2>
<p><strong>场景说明</strong>：用户注册后，需要发注册邮件和注册短信。传统的做法有两种：</p>
<ol type="1">
<li><p><strong>串行方式</strong>：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7Ku4cd"><img
src="https://s4.ax1x.com/2022/01/12/7Ku4cd.png"
alt="7Ku4cd.png" /></a></p></li>
<li><p><strong>并行方式</strong>：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KuTBt"><img
src="https://s4.ax1x.com/2022/01/12/7KuTBt.png"
alt="7KuTBt.png" /></a></p></li>
</ol>
<p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p>
<p>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）。</p>
<p><strong>小结</strong>：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p>
<p><strong>引入消息队列，将不是必须的业务逻辑，异步处理</strong>。改造后的架构如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KuqN8"><img
src="https://s4.ax1x.com/2022/01/12/7KuqN8.png"
alt="7KuqN8.png" /></a></p>
<p>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20
QPS。比串行提高了3倍，比并行提高了两倍。</p>
<h2 id="应用解耦">应用解耦</h2>
<p><strong>场景说明</strong>：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KKTxJ"><img
src="https://s4.ax1x.com/2022/01/12/7KKTxJ.png"
alt="7KKTxJ.png" /></a></p>
<p><strong>传统模式的缺点：</strong></p>
<ol type="1">
<li>假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；</li>
<li>订单系统与库存系统耦合。</li>
</ol>
<p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KKjIK"><img
src="https://s4.ax1x.com/2022/01/12/7KKjIK.png"
alt="7KKjIK.png" /></a></li>
<li><strong>订单系统</strong>：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。</li>
<li><strong>库存系统</strong>：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。</li>
<li>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。</li>
</ul>
<h2 id="流量削锋">流量削锋</h2>
<p><strong>流量削锋</strong>也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p>
<p><strong>应用场景</strong>：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</p>
<ol type="1">
<li>可以控制活动的人数；</li>
<li>可以缓解短时间内高流量压垮应用。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KBxxA"><img
src="https://s4.ax1x.com/2022/01/12/7KBxxA.png"
alt="7KBxxA.png" /></a></p>
<p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面；</p>
<p>秒杀业务根据消息队列中的请求信息，再做后续处理。</p>
<h2 id="日志处理">日志处理</h2>
<p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KDV2j"><img
src="https://s4.ax1x.com/2022/01/12/7KDV2j.png"
alt="7KDV2j.png" /></a></p>
<ul>
<li>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列；</li>
<li>Kafka消息队列，负责日志数据的接收，存储和转发；</li>
<li>日志处理应用：订阅并消费kafka队列中的日志数据；</li>
</ul>
<p>以下是新浪kafka日志处理应用案例：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KD0IO"><img
src="https://s4.ax1x.com/2022/01/12/7KD0IO.md.png"
alt="7KD0IO.md.png" /></a></p>
<ol type="1">
<li><strong>Kafka</strong>：接收用户日志的消息队列。</li>
<li><strong>Logstash</strong>：做日志解析，统一成JSON输出给Elasticsearch。</li>
<li><strong>Elasticsearch</strong>：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。</li>
<li><strong>Kibana</strong>：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK
stack的重要原因。</li>
</ol>
<h2 id="消息通讯">消息通讯</h2>
<p><strong>消息通讯</strong>是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</p>
<p>点对点通讯：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KD5FS"><img
src="https://s4.ax1x.com/2022/01/12/7KD5FS.png"
alt="7KD5FS.png" /></a></p>
<p>客户端A和客户端B使用同一队列，进行消息通讯。</p>
<p>聊天室通讯：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KDjoT"><img
src="https://s4.ax1x.com/2022/01/12/7KDjoT.png"
alt="7KDjoT.png" /></a></p>
<p>客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</p>
<p>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。</p>
<h1 id="消息队列有什么优缺点">消息队列有什么优缺点</h1>
<p><strong>优点</strong>可以叙述第一题的作用，都是使用消息队列的好处。</p>
<p><strong>缺点</strong>有以下几个：</p>
<ul>
<li><strong>系统可用性降低</strong>：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。</li>
<li><strong>系统复杂性提高</strong>：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li>
<li><strong>一致性问题</strong>：A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。</li>
</ul>
<h2
id="kafkaactivemqrabbitmqrocketmq-有什么优缺点">Kafka、ActiveMQ、RabbitMQ、RocketMQ
有什么优缺点？</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 3%" />
<col style="width: 19%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">ActiveMQ</th>
<th style="text-align: center;">RabbitMQ</th>
<th style="text-align: center;">RocketMQ</th>
<th style="text-align: center;">Kafka</th>
<th style="text-align: center;">ZeroMQ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">单机吞吐量</td>
<td style="text-align: center;">比RabbitMQ低</td>
<td style="text-align: center;">2.6w/s（消息做持久化）</td>
<td style="text-align: center;">11.6w/s</td>
<td style="text-align: center;">17.3w/s</td>
<td style="text-align: center;">29w/s</td>
</tr>
<tr class="even">
<td style="text-align: center;">开发语言</td>
<td style="text-align: center;">java</td>
<td style="text-align: center;">Erlang</td>
<td style="text-align: center;">java</td>
<td style="text-align: center;">Scala/java</td>
<td style="text-align: center;">C</td>
</tr>
<tr class="odd">
<td style="text-align: center;">主要维护者</td>
<td style="text-align: center;">Apache</td>
<td style="text-align: center;">Mozilla/Spring</td>
<td style="text-align: center;">Alibaba</td>
<td style="text-align: center;">Apache</td>
<td style="text-align: center;">iMatix创始人已去世</td>
</tr>
<tr class="even">
<td style="text-align: center;">成熟度</td>
<td style="text-align: center;">成熟</td>
<td style="text-align: center;">成熟</td>
<td style="text-align: center;">开源版本不够成熟</td>
<td style="text-align: center;">比较成熟</td>
<td style="text-align: center;">只有C、PHP等版本成熟</td>
</tr>
<tr class="odd">
<td style="text-align: center;">订阅形式</td>
<td style="text-align: center;">点对点（p2p)、广播（发布订阅）</td>
<td
style="text-align: center;">提供了4种：direct、topic、Headers和fanout。fanout就是广播模式</td>
<td style="text-align: center;">基于toic/me
ssageTag以及按照消息类型进行正则匹配的发布订阅模式</td>
<td
style="text-align: center;">基于topic以及按照topic进行正则匹配的发布订阅模式</td>
<td style="text-align: center;">点对点(p2p)</td>
</tr>
<tr class="even">
<td style="text-align: center;">持久化</td>
<td style="text-align: center;">支持少量堆积</td>
<td style="text-align: center;">支持少量堆积</td>
<td style="text-align: center;">支持大量堆积</td>
<td style="text-align: center;">支持大量堆积</td>
<td style="text-align: center;">不支持</td>
</tr>
<tr class="odd">
<td style="text-align: center;">顺序消息</td>
<td style="text-align: center;">不支持</td>
<td style="text-align: center;">不支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">不支持</td>
</tr>
<tr class="even">
<td style="text-align: center;">性能稳定性</td>
<td style="text-align: center;">好</td>
<td style="text-align: center;">好</td>
<td style="text-align: center;">一般</td>
<td style="text-align: center;">较差</td>
<td style="text-align: center;">很好</td>
</tr>
<tr class="odd">
<td style="text-align: center;">集群方式</td>
<td
style="text-align: center;">支持简单集群模式，比如“主备”，对高级集群模式支持不好</td>
<td
style="text-align: center;">支持简单集群，“复制”模式，对高级集群模式支持不好</td>
<td style="text-align: center;">常用于对多“Mast
erSlave”模式，开源版本需手动切换Slave变成Master</td>
<td style="text-align: center;">天然的"Lead
erSlave"无状态集群，每台服务器既是Master也是Slave</td>
<td style="text-align: center;">不支持</td>
</tr>
<tr class="even">
<td style="text-align: center;">管理界面</td>
<td style="text-align: center;">一般</td>
<td style="text-align: center;">较好</td>
<td style="text-align: center;">一般</td>
<td style="text-align: center;">无</td>
<td style="text-align: center;">无</td>
</tr>
</tbody>
</table>
<h2 id="kafka与其他mq的对比">Kafka与其他MQ的对比</h2>
<ol type="1">
<li><strong>RabbitMQ</strong></li>
</ol>
<p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP,
SMTP,
STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p>
<ol start="2" type="1">
<li><strong>Redis</strong></li>
</ol>
<p>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p>
<ol start="3" type="1">
<li><strong>ZeroMQ</strong></li>
</ol>
<p>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm
0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。</p>
<ol start="4" type="1">
<li><strong>ActiveMQ</strong></li>
</ol>
<p>ActiveMQ是Apache下的一个子项目。
类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</p>
<ol start="5" type="1">
<li><strong>Kafka/Jafka</strong></li>
</ol>
<p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache
Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>
<h1 id="mq如何保证消息不被重复消费">MQ如何保证消息不被重复消费？</h1>
<blockquote>
<p>【或者说，如何保证消息消费的幂等性？ 】</p>
</blockquote>
<p>消息重复的原因有两个：</p>
<ol type="1">
<li><p>生产时消息重复;</p></li>
<li><p>消费时消息重复。</p></li>
</ol>
<p><strong>生产时消息重复</strong></p>
<p>由于生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，实际上MQ已经接收到了消息。这时候生产者就会重新发送一遍这条消息。</p>
<p>生产者中如果消息未被确认，或确认失败，我们可以使用<code>定时任务+（[redis]()/db）</code>来进行消息重试。</p>
<p><strong>消费时消息重复</strong></p>
<p>消费者消费成功后，再给MQ确认的时候出现了网络波动，MQ没有接收到确认，为了保证消息被消费，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。</p>
<p><strong>由于重复消息是由于网络原因造成的，因此不可避免重复消息。但是我们需要保证消息的幂等性</strong>。</p>
<p><strong>如何保证消息幂等性</strong></p>
<p>让每个消息携带一个全局的唯一ID，即可保证消息的幂等性，具体消费过程为：</p>
<ol type="1">
<li>消费者获取到消息后先根据id去查询<code>[redis]()/db</code>是否存在该消息。</li>
<li>如果不存在，则正常消费，消费完毕后写入<code>[redis]()/db</code>。</li>
<li>如果存在，则证明消息被消费过，直接丢弃。</li>
</ol>
<h1 id="mq如何保证消息的顺序性">MQ如何保证消息的顺序性？</h1>
<p><strong>RabbitMQ</strong></p>
<ul>
<li>拆分为多个queue，每个queue由一个consumer消费；</li>
<li>或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理。</li>
</ul>
<p><strong>Kafka</strong></p>
<ul>
<li>一个 topic，一个 partition，一个
consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个；</li>
<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于
N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li>
</ul>
<h1 id="如何实现流量削峰">如何实现流量削峰</h1>
<p>削峰从本质上来说是更多地延缓用户请求，以及层层过滤用户的访问需求，遵从“最后落地到数据库的请求数要尽量少”的原则。</p>
<h2 id="消息队列解决削峰">消息队列解决削峰</h2>
<p>要对流量进行削峰，最通用的解决方案就是用消息队列来缓冲瞬时流量，<strong>把同步的直接调用转换成异步的间接推送,中间通过一个队列在一端承接瞬时的流量洪峰</strong>，在另一端平滑地将消息推送出去，<strong>消息队列本质就是一个缓冲区，用于延缓数据请求</strong>。在这里，消息队列就像“水库”一样，拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HKt4H"><img
src="https://s4.ax1x.com/2022/01/25/7HKt4H.md.png"
alt="7HKt4H.md.png" /></a></p>
<p>消息队列中间件主要解决应用耦合，异步消息，
流量削锋等问题。常用消息队列系统：目前在并发生产环境，使用较多的消息队列有
ActiveMQ、RabbitMQ、
ZeroMQ、Kafka、MetaMQ、RocketMQ等。<strong>其中RabbitMQ几乎是各大并发系统的首选!</strong></p>
<h2 id="流量削峰漏斗层层削峰">流量削峰漏斗：层层削峰</h2>
<p>针对秒杀场景还有一种方法，就是<strong>对请求进行分层过滤，从而过滤掉一些无效的请求</strong>。分层过滤可以类比为“漏斗”式设计来处理请求的，如下图所示：
<a target="_blank" rel="noopener" href="https://imgtu.com/i/7HKO2R"><img
src="https://s4.ax1x.com/2022/01/25/7HKO2R.md.png"
alt="7HKO2R.md.png" /></a></p>
<p>这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。</p>
<ol type="1">
<li><strong>分层过滤的核心思想</strong>
通过在不同的层次尽可能地过滤掉无效请求。在不影响用户体验的情况下降低用户的请求频率。通过CDN过滤掉大量的图片，静态资源的请求。通过类似Redis这样的高性能内存数据库进行缓存处理，过滤请求等上在游拦截读请求，从而尽量减少数据库的命中率。</li>
<li><strong>分层过滤的基本原则</strong>
对写数据进行基于时间的合理分片，过滤掉过期的失效请求。对写请求做限流保护，将超出系统承载能力的请求过滤掉。涉及到的读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题。对写数据进行强一致性校验，只保留最后有效的数据。针对热点数据进行做好缓存处理并通过合理方式确保一致性。最终，让“漏斗”最末端(数据库)的才是有效请求。例如：当用户真实达到订单和支付的流程，这个是需要数据强一致性的。</li>
</ol>
<blockquote>
<p>总结</p>
</blockquote>
<ol type="1">
<li>对于秒杀这样的高并发场景业务，最基本的原则就是将请求拦截在系统上游，降低下游压力，减少对数据库的访问。</li>
<li>划分好动静资源，静态资源使用CDN进行服务分发。</li>
<li>充分利用缓存(redis等)：增加QPS，从而加大整个集群的吞吐量。</li>
<li>高峰值流量是压垮系统很重要的原因，所以在需要时可以利用Kafka等消息队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。</li>
<li>利用高可用的性能组件进行缓存热点数据，减少对数据库的访问。</li>
</ol>
<h1 id="kafka架构">Kafka架构</h1>
<p><strong>Kafka</strong>是最初由Linkedin公司开发，是一个<code>分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统）</code>，常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p>
<p>主要应用场景是：<strong>日志收集系统</strong>和<strong>消息系统</strong>。</p>
<blockquote>
<p><strong>Kafka主要设计目标如下</strong>：</p>
</blockquote>
<ul>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。</li>
<li>支持Kafka
Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。</li>
<li>同时支持离线数据处理和实时数据处理。</li>
<li>支持在线水平扩展</li>
</ul>
<h2 id="kafka的架构">Kafka的架构</h2>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HMTyt"><img
src="https://s4.ax1x.com/2022/01/25/7HMTyt.md.png"
alt="7HMTyt.md.png" /></a></p>
<p>如上图所示，一个典型的Kafka集群中包含若干<code>Producer</code>（可以是web前端产生的Page
View，或者是服务器日志，系统CPU、Memory等），若干<code>broker</code>（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干<code>Consumer Group</code>，以及一个<code>Zookeeper</code>集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer
Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<h3 id="分布式模型">分布式模型</h3>
<p><strong>Kafka</strong>每个主题的多个分区日志分布式地存储在Kafka集群上，同时为了故障容错，每个分区都会以副本的方式复制到多个消息代理节点上。其中一个节点会作为主副本（Leader），其他节点作为备份副本（Follower，也叫作从副本）。主副本会负责所有的客户端读写操作，备份副本仅仅从主副本同步数据。当主副本出现故障时，备份副本中的一个副本会被选择为新的主副本。因为每个分区的副本中只有主副本接受读写，所以每个服务器端都会作为某些分区的主副本，以及另外一些分区的备份副本，这样Kafka集群的所有服务端整体上对客户端是负载均衡的。</p>
<p>Kafka的生产者和消费者相对于服务器端而言都是客户端。</p>
<p>Kafka生产者客户端发布消息到服务端的指定主题，会指定消息所属的分区。生产者发布消息时根据消息是否有键，采用不同的分区策略。消息没有键时，通过轮询方式进行客户端负载均衡；消息有键时，根据分区语义（例如hash）确保相同键的消息总是发送到同一分区。</p>
<p>Kafka的消费者通过订阅主题来消费消息，并且每个消费者都会设置一个消费组名称。因为生产者发布到主题的每一条消息都只会发送给消费者组的一个消费者。所以，如果要实现传统消息系统的“队列”模型，可以让每个消费者都拥有相同的消费组名称，这样消息就会负责均衡到所有的消费者；如果要实现“发布-订阅”模型，则每个消费者的消费者组名称都不相同，这样每条消息就会广播给所有的消费者。</p>
<p>分区是消费者现场模型的最小并行单位。如下图（图1）所示，生产者发布消息到一台服务器的3个分区时，只有一个消费者消费所有的3个分区。在下图（图2）中，3个分区分布在3台服务器上，同时有3个消费者分别消费不同的分区。假设每个服务器的吞吐量时300MB，在下图（图1）中分摊到每个分区只有100MB，而在下图（图2）中，集群整体的吞吐量有900MB。可以看到，增加服务器节点会提升集群的性能，增加消费者数量会提升处理性能。</p>
<p>同一个消费组下多个消费者互相协调消费工作，Kafka会将所有的分区平均地分配给所有的消费者实例，这样每个消费者都可以分配到数量均等的分区。Kafka的消费组管理协议会动态地维护消费组的成员列表，当一个新消费者加入消费者组，或者有消费者离开消费组，都会触发再平衡操作。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HMzSs"><img
src="https://s4.ax1x.com/2022/01/25/7HMzSs.png"
alt="7HMzSs.png" /></a></p>
<p>Kafka的消费者消费消息时，只保证在一个分区内的消息的完全有序性，并不保证同一个主题汇中多个分区的消息顺序。而且，消费者读取一个分区消息的顺序和生产者写入到这个分区的顺序是一致的。比如，生产者写入“hello”和“Kafka”两条消息到分区P1，则消费者读取到的顺序也一定是“hello”和“Kafka”。如果业务上需要保证所有消息完全一致，只能通过设置一个分区完成，但这种做法的缺点是最多只能有一个消费者进行消费。一般来说，只需要保证每个分区的有序性，再对消息假设键来保证相同键的所有消息落入同一分区，就可以满足绝大多数的应用。</p>
<h1 id="怎么保证kafka消费不乱序">怎么保证Kafka消费不乱序</h1>
<ol type="1">
<li><p><strong>一个topic，只设置一个partition。</strong></p>
<p>众所周知，一个topic可设置多个partition，partition分布在多个server，每个partition有一个leader，多个follower。以此实现写入高并发。消息可能被写入任一个partition，所以不能保证多个partition之间消息的存入顺序；更不能保证消息的消费顺序。</p>
<blockquote>
<p>那么kakfa是怎么保证一个partition顺序的？</p>
</blockquote>
<p>producer发送消息到kafka，kafka给每个生产者一个生产者PID，kafka单个partition保存的消息顺序格式即&lt;&lt;PID,TOPIC&gt;,sequnceId&gt;
同一时间先后发送两条消息到kafka的同一partition，假如第一条message1发送失败，第二条message2发送成功并保存到kafka；紧接着第一条会重试并发送成功，如果这时partition保存，会造成消息顺序混乱。
实际partition不会，判断的机制是message1=squenceId1,如果message1发送失败，第二条消息message2=squenceId2过来，判断当前sequence和sequence2序号差大于1（因为sequence1未保存），会丢弃这条消息；
如果squence2保存了，sequence1又重发了一条，判断当前sequence1大于squence2，说明是重试的消息，也会丢弃。</p></li>
<li><p><strong>发送消息可指定(topic, partition, key)
3个参数</strong>，即保证同一类消息只发送到同一个partition，保证写入顺序，同时也保证了消费顺序。</p></li>
<li><p><strong>生产者客户端开启幂等性配置，broker会自动保证单分区消息不重复。</strong></p></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8F%E9%94%81/" rel="prev" title="深入理解Java中的锁">
      <i class="fa fa-chevron-left"></i> 深入理解Java中的锁
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E4%BA%BA%E7%94%9F%E6%84%BF%E6%9C%9B%E6%B8%85%E5%8D%95/" rel="next" title="人生愿望清单">
      人生愿望清单 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">消息队列的使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">异步处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="nav-number">1.2.</span> <span class="nav-text">应用解耦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A%E9%94%8B"><span class="nav-number">1.3.</span> <span class="nav-text">流量削锋</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">日志处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%80%9A%E8%AE%AF"><span class="nav-number">1.5.</span> <span class="nav-text">消息通讯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">消息队列有什么优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kafkaactivemqrabbitmqrocketmq-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">Kafka、ActiveMQ、RabbitMQ、RocketMQ
有什么优缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E4%B8%8E%E5%85%B6%E4%BB%96mq%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.2.</span> <span class="nav-text">Kafka与其他MQ的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mq%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="nav-number">3.</span> <span class="nav-text">MQ如何保证消息不被重复消费？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mq%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">MQ如何保证消息的顺序性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0"><span class="nav-number">5.</span> <span class="nav-text">如何实现流量削峰</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E5%89%8A%E5%B3%B0"><span class="nav-number">5.1.</span> <span class="nav-text">消息队列解决削峰</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0%E6%BC%8F%E6%96%97%E5%B1%82%E5%B1%82%E5%89%8A%E5%B3%B0"><span class="nav-number">5.2.</span> <span class="nav-text">流量削峰漏斗：层层削峰</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kafka%E6%9E%B6%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">Kafka架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">Kafka的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.1.</span> <span class="nav-text">分布式模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81kafka%E6%B6%88%E8%B4%B9%E4%B8%8D%E4%B9%B1%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">怎么保证Kafka消费不乱序</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

