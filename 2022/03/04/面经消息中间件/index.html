<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="是的我看见到处是阳光，快乐在城市上空飘荡">
<meta property="og:type" content="article">
<meta property="og:title" content="消息中间件">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="是的我看见到处是阳光，快乐在城市上空飘荡">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.477Z">
<meta property="article:modified_time" content="2022-04-14T03:20:34.029Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>消息中间件 | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          消息中间件
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 11:20:34" itemprop="dateModified" datetime="2022-04-14T11:20:34+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">是的我看见到处是阳光，快乐在城市上空飘荡</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>MQ ——消息中间件</strong>
说白了就是存消息的队列。具有一系列的优点，进而成为
<strong>异步RPC</strong>（异步、远距离调用）的主要手段之一。</p>
<h1 id="消息队列的使用场景">消息队列的使用场景</h1>
<p>消息队列主要有三大使用场景，分别是<strong>异步、流量削锋和应用解耦</strong>。另外还包含<strong>日志和消息通讯</strong>。</p>
<ul>
<li><strong>异步处理</strong> -
相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li><strong>应用解耦</strong> -
系统间通过消息通信，不用关心其他系统的处理。</li>
<li><strong>流量削锋</strong> -
可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li><strong>日志处理</strong> - 解决大量日志传输。</li>
<li><strong>消息通讯</strong> -
消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
</ul>
<h2 id="异步处理">异步处理</h2>
<p><strong>场景说明</strong>：用户注册后，需要发注册邮件和注册短信。传统的做法有两种：</p>
<ol type="1">
<li><p><strong>串行方式</strong>：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7Ku4cd"><img
src="https://s4.ax1x.com/2022/01/12/7Ku4cd.png"
alt="7Ku4cd.png" /></a></p></li>
<li><p><strong>并行方式</strong>：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KuTBt"><img
src="https://s4.ax1x.com/2022/01/12/7KuTBt.png"
alt="7KuTBt.png" /></a></p></li>
</ol>
<p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p>
<p>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）。</p>
<p><strong>小结</strong>：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p>
<p><strong>引入消息队列，将不是必须的业务逻辑，异步处理</strong>。改造后的架构如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KuqN8"><img
src="https://s4.ax1x.com/2022/01/12/7KuqN8.png"
alt="7KuqN8.png" /></a></p>
<p>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20
QPS。比串行提高了3倍，比并行提高了两倍。</p>
<h2 id="应用解耦">应用解耦</h2>
<p><strong>场景说明</strong>：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KKTxJ"><img
src="https://s4.ax1x.com/2022/01/12/7KKTxJ.png"
alt="7KKTxJ.png" /></a></p>
<p><strong>传统模式的缺点：</strong></p>
<ol type="1">
<li>假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；</li>
<li>订单系统与库存系统耦合。</li>
</ol>
<p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KKjIK"><img
src="https://s4.ax1x.com/2022/01/12/7KKjIK.png"
alt="7KKjIK.png" /></a></li>
<li><strong>订单系统</strong>：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。</li>
<li><strong>库存系统</strong>：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。</li>
<li>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。</li>
</ul>
<h2 id="流量削锋">流量削锋</h2>
<p><strong>流量削锋</strong>也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p>
<p><strong>应用场景</strong>：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</p>
<ol type="1">
<li>可以控制活动的人数；</li>
<li>可以缓解短时间内高流量压垮应用。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KBxxA"><img
src="https://s4.ax1x.com/2022/01/12/7KBxxA.png"
alt="7KBxxA.png" /></a></p>
<p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面；</p>
<p>秒杀业务根据消息队列中的请求信息，再做后续处理。</p>
<h2 id="日志处理">日志处理</h2>
<p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KDV2j"><img
src="https://s4.ax1x.com/2022/01/12/7KDV2j.png"
alt="7KDV2j.png" /></a></p>
<ul>
<li>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列；</li>
<li>Kafka消息队列，负责日志数据的接收，存储和转发；</li>
<li>日志处理应用：订阅并消费kafka队列中的日志数据；</li>
</ul>
<p>以下是新浪kafka日志处理应用案例：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KD0IO"><img
src="https://s4.ax1x.com/2022/01/12/7KD0IO.md.png"
alt="7KD0IO.md.png" /></a></p>
<ol type="1">
<li><strong>Kafka</strong>：接收用户日志的消息队列。</li>
<li><strong>Logstash</strong>：做日志解析，统一成JSON输出给Elasticsearch。</li>
<li><strong>Elasticsearch</strong>：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。</li>
<li><strong>Kibana</strong>：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK
stack的重要原因。</li>
</ol>
<h2 id="消息通讯">消息通讯</h2>
<p><strong>消息通讯</strong>是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</p>
<p>点对点通讯：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KD5FS"><img
src="https://s4.ax1x.com/2022/01/12/7KD5FS.png"
alt="7KD5FS.png" /></a></p>
<p>客户端A和客户端B使用同一队列，进行消息通讯。</p>
<p>聊天室通讯：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7KDjoT"><img
src="https://s4.ax1x.com/2022/01/12/7KDjoT.png"
alt="7KDjoT.png" /></a></p>
<p>客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</p>
<p>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。</p>
<h1 id="消息队列有什么优缺点">消息队列有什么优缺点</h1>
<p><strong>优点</strong>可以叙述第一题的作用，都是使用消息队列的好处。</p>
<p><strong>缺点</strong>有以下几个：</p>
<ul>
<li><strong>系统可用性降低</strong>：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。</li>
<li><strong>系统复杂性提高</strong>：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li>
<li><strong>一致性问题</strong>：A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。</li>
</ul>
<h2
id="kafkaactivemqrabbitmqrocketmq-有什么优缺点">Kafka、ActiveMQ、RabbitMQ、RocketMQ
有什么优缺点？</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 3%" />
<col style="width: 19%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">ActiveMQ</th>
<th style="text-align: center;">RabbitMQ</th>
<th style="text-align: center;">RocketMQ</th>
<th style="text-align: center;">Kafka</th>
<th style="text-align: center;">ZeroMQ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">单机吞吐量</td>
<td style="text-align: center;">比RabbitMQ低</td>
<td style="text-align: center;">2.6w/s（消息做持久化）</td>
<td style="text-align: center;">11.6w/s</td>
<td style="text-align: center;">17.3w/s</td>
<td style="text-align: center;">29w/s</td>
</tr>
<tr class="even">
<td style="text-align: center;">开发语言</td>
<td style="text-align: center;">java</td>
<td style="text-align: center;">Erlang</td>
<td style="text-align: center;">java</td>
<td style="text-align: center;">Scala/java</td>
<td style="text-align: center;">C</td>
</tr>
<tr class="odd">
<td style="text-align: center;">主要维护者</td>
<td style="text-align: center;">Apache</td>
<td style="text-align: center;">Mozilla/Spring</td>
<td style="text-align: center;">Alibaba</td>
<td style="text-align: center;">Apache</td>
<td style="text-align: center;">iMatix创始人已去世</td>
</tr>
<tr class="even">
<td style="text-align: center;">成熟度</td>
<td style="text-align: center;">成熟</td>
<td style="text-align: center;">成熟</td>
<td style="text-align: center;">开源版本不够成熟</td>
<td style="text-align: center;">比较成熟</td>
<td style="text-align: center;">只有C、PHP等版本成熟</td>
</tr>
<tr class="odd">
<td style="text-align: center;">订阅形式</td>
<td style="text-align: center;">点对点（p2p)、广播（发布订阅）</td>
<td
style="text-align: center;">提供了4种：direct、topic、Headers和fanout。fanout就是广播模式</td>
<td style="text-align: center;">基于toic/me
ssageTag以及按照消息类型进行正则匹配的发布订阅模式</td>
<td
style="text-align: center;">基于topic以及按照topic进行正则匹配的发布订阅模式</td>
<td style="text-align: center;">点对点(p2p)</td>
</tr>
<tr class="even">
<td style="text-align: center;">持久化</td>
<td style="text-align: center;">支持少量堆积</td>
<td style="text-align: center;">支持少量堆积</td>
<td style="text-align: center;">支持大量堆积</td>
<td style="text-align: center;">支持大量堆积</td>
<td style="text-align: center;">不支持</td>
</tr>
<tr class="odd">
<td style="text-align: center;">顺序消息</td>
<td style="text-align: center;">不支持</td>
<td style="text-align: center;">不支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">不支持</td>
</tr>
<tr class="even">
<td style="text-align: center;">性能稳定性</td>
<td style="text-align: center;">好</td>
<td style="text-align: center;">好</td>
<td style="text-align: center;">一般</td>
<td style="text-align: center;">较差</td>
<td style="text-align: center;">很好</td>
</tr>
<tr class="odd">
<td style="text-align: center;">集群方式</td>
<td
style="text-align: center;">支持简单集群模式，比如“主备”，对高级集群模式支持不好</td>
<td
style="text-align: center;">支持简单集群，“复制”模式，对高级集群模式支持不好</td>
<td style="text-align: center;">常用于对多“Mast
erSlave”模式，开源版本需手动切换Slave变成Master</td>
<td style="text-align: center;">天然的"Lead
erSlave"无状态集群，每台服务器既是Master也是Slave</td>
<td style="text-align: center;">不支持</td>
</tr>
<tr class="even">
<td style="text-align: center;">管理界面</td>
<td style="text-align: center;">一般</td>
<td style="text-align: center;">较好</td>
<td style="text-align: center;">一般</td>
<td style="text-align: center;">无</td>
<td style="text-align: center;">无</td>
</tr>
</tbody>
</table>
<h2 id="kafka与其他mq的对比">Kafka与其他MQ的对比</h2>
<ol type="1">
<li><strong>RabbitMQ</strong></li>
</ol>
<p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP,
SMTP,
STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p>
<ol start="2" type="1">
<li><strong>Redis</strong></li>
</ol>
<p>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p>
<ol start="3" type="1">
<li><strong>ZeroMQ</strong></li>
</ol>
<p>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm
0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。</p>
<ol start="4" type="1">
<li><strong>ActiveMQ</strong></li>
</ol>
<p>ActiveMQ是Apache下的一个子项目。
类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</p>
<ol start="5" type="1">
<li><strong>Kafka/Jafka</strong></li>
</ol>
<p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache
Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>
<h1 id="mq如何保证消息不被重复消费">MQ如何保证消息不被重复消费？</h1>
<blockquote>
<p>【或者说，如何保证消息消费的幂等性？ 】</p>
</blockquote>
<p>消息重复的原因有两个：</p>
<ol type="1">
<li><p>生产时消息重复;</p></li>
<li><p>消费时消息重复。</p></li>
</ol>
<p><strong>生产时消息重复</strong></p>
<p>由于生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，实际上MQ已经接收到了消息。这时候生产者就会重新发送一遍这条消息。</p>
<p>生产者中如果消息未被确认，或确认失败，我们可以使用<code>定时任务+（[redis]()/db）</code>来进行消息重试。</p>
<p><strong>消费时消息重复</strong></p>
<p>消费者消费成功后，再给MQ确认的时候出现了网络波动，MQ没有接收到确认，为了保证消息被消费，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。</p>
<p><strong>由于重复消息是由于网络原因造成的，因此不可避免重复消息。但是我们需要保证消息的幂等性</strong>。</p>
<p><strong>如何保证消息幂等性</strong></p>
<p>让每个消息携带一个全局的唯一ID，即可保证消息的幂等性，具体消费过程为：</p>
<ol type="1">
<li>消费者获取到消息后先根据id去查询<code>[redis]()/db</code>是否存在该消息。</li>
<li>如果不存在，则正常消费，消费完毕后写入<code>[redis]()/db</code>。</li>
<li>如果存在，则证明消息被消费过，直接丢弃。</li>
</ol>
<h1 id="mq如何保证消息的顺序性">MQ如何保证消息的顺序性？</h1>
<p><strong>RabbitMQ</strong></p>
<ul>
<li>拆分为多个queue，每个queue由一个consumer消费；</li>
<li>或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理。</li>
</ul>
<p><strong>Kafka</strong></p>
<ul>
<li>一个 topic，一个 partition，一个
consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个；</li>
<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于
N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li>
</ul>
<h1 id="如何实现流量削峰">如何实现流量削峰</h1>
<p>削峰从本质上来说是更多地延缓用户请求，以及层层过滤用户的访问需求，遵从“最后落地到数据库的请求数要尽量少”的原则。</p>
<h2 id="消息队列解决削峰">消息队列解决削峰</h2>
<p>要对流量进行削峰，最通用的解决方案就是用消息队列来缓冲瞬时流量，<strong>把同步的直接调用转换成异步的间接推送,中间通过一个队列在一端承接瞬时的流量洪峰</strong>，在另一端平滑地将消息推送出去，<strong>消息队列本质就是一个缓冲区，用于延缓数据请求</strong>。在这里，消息队列就像“水库”一样，拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HKt4H"><img
src="https://s4.ax1x.com/2022/01/25/7HKt4H.md.png"
alt="7HKt4H.md.png" /></a></p>
<p>消息队列中间件主要解决应用耦合，异步消息，
流量削锋等问题。常用消息队列系统：目前在并发生产环境，使用较多的消息队列有
ActiveMQ、RabbitMQ、
ZeroMQ、Kafka、MetaMQ、RocketMQ等。<strong>其中RabbitMQ几乎是各大并发系统的首选!</strong></p>
<h2 id="流量削峰漏斗层层削峰">流量削峰漏斗：层层削峰</h2>
<p>针对秒杀场景还有一种方法，就是<strong>对请求进行分层过滤，从而过滤掉一些无效的请求</strong>。分层过滤可以类比为“漏斗”式设计来处理请求的，如下图所示：
<a target="_blank" rel="noopener" href="https://imgtu.com/i/7HKO2R"><img
src="https://s4.ax1x.com/2022/01/25/7HKO2R.md.png"
alt="7HKO2R.md.png" /></a></p>
<p>这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。</p>
<ol type="1">
<li><strong>分层过滤的核心思想</strong>
通过在不同的层次尽可能地过滤掉无效请求。在不影响用户体验的情况下降低用户的请求频率。通过CDN过滤掉大量的图片，静态资源的请求。通过类似Redis这样的高性能内存数据库进行缓存处理，过滤请求等上在游拦截读请求，从而尽量减少数据库的命中率。</li>
<li><strong>分层过滤的基本原则</strong>
对写数据进行基于时间的合理分片，过滤掉过期的失效请求。对写请求做限流保护，将超出系统承载能力的请求过滤掉。涉及到的读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题。对写数据进行强一致性校验，只保留最后有效的数据。针对热点数据进行做好缓存处理并通过合理方式确保一致性。最终，让“漏斗”最末端(数据库)的才是有效请求。例如：当用户真实达到订单和支付的流程，这个是需要数据强一致性的。</li>
</ol>
<blockquote>
<p>总结</p>
</blockquote>
<ol type="1">
<li>对于秒杀这样的高并发场景业务，最基本的原则就是将请求拦截在系统上游，降低下游压力，减少对数据库的访问。</li>
<li>划分好动静资源，静态资源使用CDN进行服务分发。</li>
<li>充分利用缓存(redis等)：增加QPS，从而加大整个集群的吞吐量。</li>
<li>高峰值流量是压垮系统很重要的原因，所以在需要时可以利用Kafka等消息队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。</li>
<li>利用高可用的性能组件进行缓存热点数据，减少对数据库的访问。</li>
</ol>
<h1 id="kafka架构">Kafka架构</h1>
<p><strong>Kafka</strong>是最初由Linkedin公司开发，是一个<code>分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统）</code>，常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p>
<p>主要应用场景是：<strong>日志收集系统</strong>和<strong>消息系统</strong>。</p>
<blockquote>
<p><strong>Kafka主要设计目标如下</strong>：</p>
</blockquote>
<ul>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。</li>
<li>支持Kafka
Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。</li>
<li>同时支持离线数据处理和实时数据处理。</li>
<li>支持在线水平扩展</li>
</ul>
<h2 id="kafka的架构">Kafka的架构</h2>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HMTyt"><img
src="https://s4.ax1x.com/2022/01/25/7HMTyt.md.png"
alt="7HMTyt.md.png" /></a></p>
<p>如上图所示，一个典型的Kafka集群中包含若干<code>Producer</code>（可以是web前端产生的Page
View，或者是服务器日志，系统CPU、Memory等），若干<code>broker</code>（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干<code>Consumer Group</code>，以及一个<code>Zookeeper</code>集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer
Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<h3 id="分布式模型">分布式模型</h3>
<p><strong>Kafka</strong>每个主题的多个分区日志分布式地存储在Kafka集群上，同时为了故障容错，每个分区都会以副本的方式复制到多个消息代理节点上。其中一个节点会作为主副本（Leader），其他节点作为备份副本（Follower，也叫作从副本）。主副本会负责所有的客户端读写操作，备份副本仅仅从主副本同步数据。当主副本出现故障时，备份副本中的一个副本会被选择为新的主副本。因为每个分区的副本中只有主副本接受读写，所以每个服务器端都会作为某些分区的主副本，以及另外一些分区的备份副本，这样Kafka集群的所有服务端整体上对客户端是负载均衡的。</p>
<p>Kafka的生产者和消费者相对于服务器端而言都是客户端。</p>
<p>Kafka生产者客户端发布消息到服务端的指定主题，会指定消息所属的分区。生产者发布消息时根据消息是否有键，采用不同的分区策略。消息没有键时，通过轮询方式进行客户端负载均衡；消息有键时，根据分区语义（例如hash）确保相同键的消息总是发送到同一分区。</p>
<p>Kafka的消费者通过订阅主题来消费消息，并且每个消费者都会设置一个消费组名称。因为生产者发布到主题的每一条消息都只会发送给消费者组的一个消费者。所以，如果要实现传统消息系统的“队列”模型，可以让每个消费者都拥有相同的消费组名称，这样消息就会负责均衡到所有的消费者；如果要实现“发布-订阅”模型，则每个消费者的消费者组名称都不相同，这样每条消息就会广播给所有的消费者。</p>
<p>分区是消费者现场模型的最小并行单位。如下图（图1）所示，生产者发布消息到一台服务器的3个分区时，只有一个消费者消费所有的3个分区。在下图（图2）中，3个分区分布在3台服务器上，同时有3个消费者分别消费不同的分区。假设每个服务器的吞吐量时300MB，在下图（图1）中分摊到每个分区只有100MB，而在下图（图2）中，集群整体的吞吐量有900MB。可以看到，增加服务器节点会提升集群的性能，增加消费者数量会提升处理性能。</p>
<p>同一个消费组下多个消费者互相协调消费工作，Kafka会将所有的分区平均地分配给所有的消费者实例，这样每个消费者都可以分配到数量均等的分区。Kafka的消费组管理协议会动态地维护消费组的成员列表，当一个新消费者加入消费者组，或者有消费者离开消费组，都会触发再平衡操作。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HMzSs"><img
src="https://s4.ax1x.com/2022/01/25/7HMzSs.png"
alt="7HMzSs.png" /></a></p>
<p>Kafka的消费者消费消息时，只保证在一个分区内的消息的完全有序性，并不保证同一个主题汇中多个分区的消息顺序。而且，消费者读取一个分区消息的顺序和生产者写入到这个分区的顺序是一致的。比如，生产者写入“hello”和“Kafka”两条消息到分区P1，则消费者读取到的顺序也一定是“hello”和“Kafka”。如果业务上需要保证所有消息完全一致，只能通过设置一个分区完成，但这种做法的缺点是最多只能有一个消费者进行消费。一般来说，只需要保证每个分区的有序性，再对消息假设键来保证相同键的所有消息落入同一分区，就可以满足绝大多数的应用。</p>
<h1 id="怎么保证kafka消费不乱序">怎么保证Kafka消费不乱序</h1>
<ol type="1">
<li><p><strong>一个topic，只设置一个partition。</strong></p>
<p>众所周知，一个topic可设置多个partition，partition分布在多个server，每个partition有一个leader，多个follower。以此实现写入高并发。消息可能被写入任一个partition，所以不能保证多个partition之间消息的存入顺序；更不能保证消息的消费顺序。</p>
<blockquote>
<p>那么kakfa是怎么保证一个partition顺序的？</p>
</blockquote>
<p>producer发送消息到kafka，kafka给每个生产者一个生产者PID，kafka单个partition保存的消息顺序格式即&lt;&lt;PID,TOPIC&gt;,sequnceId&gt;
同一时间先后发送两条消息到kafka的同一partition，假如第一条message1发送失败，第二条message2发送成功并保存到kafka；紧接着第一条会重试并发送成功，如果这时partition保存，会造成消息顺序混乱。
实际partition不会，判断的机制是message1=squenceId1,如果message1发送失败，第二条消息message2=squenceId2过来，判断当前sequence和sequence2序号差大于1（因为sequence1未保存），会丢弃这条消息；
如果squence2保存了，sequence1又重发了一条，判断当前sequence1大于squence2，说明是重试的消息，也会丢弃。</p></li>
<li><p><strong>发送消息可指定(topic, partition, key)
3个参数</strong>，即保证同一类消息只发送到同一个partition，保证写入顺序，同时也保证了消费顺序。</p></li>
<li><p><strong>生产者客户端开启幂等性配置，broker会自动保证单分区消息不重复。</strong></p></li>
</ol>
<h1 id="kafka实现机制">Kafka实现机制</h1>
<p><strong>Kafk内部实现原理</strong></p>
<figure>
<img
src="https://img2018.cnblogs.com/blog/1388564/201907/1388564-20190711120411571-1930157992.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</p>
<p>点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被一个且只有一个接收者接收处理，即使有多个消息监听者也是如此。</p>
<p>（2）发布/订阅模式（一对多，数据生产后，推送给所有订阅者）</p>
<p>发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，即使当前订阅者不可用，处于离线状态。</p>
<h2 id="kafka的特性">Kafka的特性</h2>
<ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition,
consumer group 对partition进行consume操作。</li>
<li>可扩展性：kafka集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li>高并发：支持数千个客户端同时读写</li>
</ul>
<h2 id="kafka的使用场景">Kafka的使用场景</h2>
<ul>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等。</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>
<li>流式处理：比如spark streaming和storm</li>
<li>事件源</li>
</ul>
<p>一般来说，（1）一个Topic的Partition数量大于等于Broker的数量，可以提高吞吐率。（2）同一个Partition的Replica尽量分散到不同的机器，高可用。
当add a new
partition的时候，partition里面的message不会重新进行分配，原来的partition里面的message数据不会变，新加的这个partition刚开始是空的，随后进入这个topic的message就会重新参与所有partition的load
balance</p>
<p>（replica副本数目不能大于kafka
broker节点的数目，否则报错。这里的replica数其实就是partition的副本总数，其中包括一个leader，其他的就是copy副本）这样如果某个broker宕机，其实整个kafka内数据依然是完整的。但是，replica副本数越高，系统虽然越稳定，但是回来带资源和性能上的下降；replica副本少的话，也会造成系统丢数据的风险。</p>
<h2 id="消息投递可靠性">消息投递可靠性</h2>
<p>一个消息如何算投递成功，Kafka提供了三种模式：</p>
<ul>
<li><p>第一种是啥都不管，发送出去就当作成功，这种情况当然不能保证消息成功投递到broker；</p></li>
<li><p>第二种是Master-Slave模型，只有当Master和所有Slave都接收到消息时，才算投递成功，这种模型提供了最高的投递可靠性，但是损伤了性能；</p></li>
<li><p>第三种模型，即只要Master确认收到消息就算投递成功；实际使用时，根据应用特性选择，绝大多数情况下都会中和可靠性和性能选择第三种模型</p>
<p>消息在broker上的可靠性，因为消息会持久化到磁盘上，所以如果正常stop一个broker，其上的数据不会丢失；但是如果不正常stop，可能会使存在页面缓存来不及写入磁盘的消息丢失，这可以通过配置flush页面缓存的周期、阈值缓解，但是同样会频繁的写磁盘会影响性能，又是一个选择题，根据实际情况配置。</p>
<p>消息消费的可靠性，Kafka提供的是“At least
once”模型，因为消息的读取进度由offset提供，offset可以由消费者自己维护也可以维护在zookeeper里，但是当消息消费后consumer挂掉，offset没有即时写回，就有可能发生重复读的情况，这种情况同样可以通过调整commit
offset周期、阈值缓解，甚至消费者自己把消费和commit
offset做成一个事务解决，但是如果你的应用不在乎重复消费，那就干脆不要解决，以换取最大的性能。</p></li>
<li><p>Partition ack：当ack=1，表示producer写partition
leader成功后，broker就返回成功，无论其他的partition
follower是否写成功。当ack=2，表示producer写partition
leader和其他一个follower成功的时候，broker就返回成功，无论其他的partition
follower是否写成功。当ack=-1[parition的数量]的时候，表示只有producer全部写成功的时候，才算成功，kafka
broker才返回成功信息。这里需要注意的是，如果ack=1的时候，一旦有个broker宕机导致partition的follower和leader切换，会导致丢数据。</p></li>
</ul>
<h1 id="rabbitmq">RabbitMQ</h1>
<h2 id="基础概念">基础概念</h2>
<p>通过上一章的学习，我们已经知道了RabbitMQ的特点了，现在我们稍微的回忆一下：</p>
<ul>
<li>RabbitMQ本身安装部署（单实例/集群）均较为简单，<strong>上手门槛低，功能丰富</strong>，符合AMQP标准</li>
<li>RabbitMQ的集群<strong>易于扩缩</strong>，可以根据实际的业务访问量，通过增减集群中节点实例的方式，达到弹性扩容、缩小的效果</li>
<li>企业级消息队列中间件，经过业界各个公司生产环境大量实践案例的验证，<strong>具有较高的可靠性</strong></li>
<li>RabbitMQ
提供了一个<strong>易用的用户界面</strong>，使得用户可以监控和管理消息
Broker 的许多方面，如果消息异常，RabbitMQ
提供了<strong>消息跟踪机制</strong>，使用者可以找出发生了什么。</li>
<li><strong>支持消息持久化、支持消息确认机制、灵活的任务分发机制</strong>等，支持功能非常丰富</li>
<li>实现<strong>高可用性</strong>，可以在RabbitMQ集群中的机器上创建队列的镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
</ul>
<p>但是这仅仅是为何用它原因，想要真正让RabbitMQ为我们的系统服务，还需要了解更多的知识。</p>
<p><strong>1、Message消息</strong></p>
<p>消息是MQ的基础，它由消息头和消息体组成。消息体是生产者传递给消费者的信息，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p>
<p><strong>2、Publisher</strong></p>
<p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
<p><strong>3、Exchange</strong></p>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p>
<p><strong>4、 Routing Key</strong></p>
<p>路由键是供交换机查看并根据键来决定如何分发消息到列队的一个键，路由键可以说是消息的目的地址</p>
<p><strong>5、Binding</strong></p>
<p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>
<p>** 6、Queue **</p>
<p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<p><strong>7、Connection</strong></p>
<p>连接RabbitMQ和应用服务器的TCP连接</p>
<p><strong>8、Channel</strong></p>
<p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP
命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁
TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p>
<p><strong>9、Consumer</strong></p>
<p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p>
<p><strong>10、Virtual Host</strong></p>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个
vhost 本质上就是一个 mini 版的 RabbitMQ
服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP
概念的基础，必须在连接时指定。</p>
<h2 id="通信过程">通信过程</h2>
<p>了解了RabbitMQ的基础构成之后，我们再通过一张图片来解释一下RabbitMQ的通信过程：</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c5e5a0a97ac4abea7872c4ac7e5c408~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>是不是画的很好看，而且一下子就能把之前学到的给用上了~</p>
<h3 id="流程解析">流程解析：</h3>
<ul>
<li>1、消息生产者连接到RabbitMQ
Broker，创建connection，开启channel。</li>
<li>2、生产者声明交换机类型、名称、是否持久化等（其实这个说法不是很准确，其实大部分是在管理页面或者消费者端先声明的）。</li>
<li>3、生产者发送消息，并指定消息是否持久化等属性和routing key。</li>
<li>4、exchange收到消息之后，根据routing
key路由到跟当前交换机绑定的相匹配的队列里面。</li>
<li>5、消费者监听接收到消息之后开始业务处理，然后发送一个ack确认告知消息已经被消费（手动自动都有可能）。</li>
<li>6、RabbitMQ Broker收到ack之后将对应的消息从队列里面删除掉。</li>
</ul>
<h2 id="消息路由模式">消息路由模式</h2>
<blockquote>
<p>从大佬那边借来了图片</p>
</blockquote>
<h3 id="直接模式direct">1、直接模式（Direct）</h3>
<p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，
交换器就将消息发到对应的队列中。直接模式是一对一的、单播的模式。</p>
<p>这种模式下<strong>不需要将Exchange进行任何绑定(binding)操作</strong>，<strong>消息传递时需要一个“RoutingKey”</strong>，可以简单的理解为要发送到的队列名字。但是<strong>如果vhost中不存在RoutingKey中指定的队列名，则该消息会被抛弃</strong>
。</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f07b802a2df948a684efd68277c84dbe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="广播模式fanout">2、广播模式（Fanout）</h3>
<p>Fanout交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。所以Fanout
类型转发消息是最快的。</p>
<p>广播模式模式<strong>不需要RoutingKey，只需要提前将Exchange与Queue进行绑定</strong>，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。但是<strong>如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</strong></p>
<p>但是因为转发到全部绑定的队列上，所以广播模式存在<strong>重复消费</strong>的问题。</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/564c7984e2ce471b9d1431434ad1af82~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="主题模式topic">3、主题模式（Topic）</h3>
<p>任何发送到Topic
Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</p>
<p>每个队列都有其关心的主题，所有的消息都带有一个“标题”(RoutingKey路由键)，Exchange会将消息转发到所有关注主题能与RoutingKey模糊匹配的队列。<strong>主题模式需要RoutingKey，也需要提前绑定Exchange与Queue，在进行绑定时，要提供一个该队列关心的主题</strong>。Topic模式有两个关键词#和*。</p>
<ul>
<li>“#”表示0个或若干个关键字，如“#.nanju.#”表示该队列关心所有涉及nanju的消息(一个RoutingKey为”asd.MQ.nanju.error”的消息会被转发到该队列)，</li>
<li><code>*</code>表示一个关键字息，如“<code>*</code>.nanju.<code>*</code>”(一个RoutingKey为”asd.nanju.error”的消息会被转发到该队列，而”asd.MQ.nanju.error”则不会)</li>
</ul>
<p>同样，如果Exchange没有发现能够与RoutingKey匹配的Queue，则会抛弃此消息。</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f787738a73b405d97267dde6fa992e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="工作模式">工作模式</h2>
<h3
id="简单模式一个生产者一个消费者">1、简单模式：一个生产者，一个消费者</h3>
<p>流程：</p>
<ul>
<li>1、生产者将消息放入消息队列</li>
<li>2、消息的消费者监听消息队列,如果队列中有消息,就消费掉。消息被消费之后,自动从队列中删除(容易出现消息还没有被消费者正确处理,已经从队列中消失了,造成消息的丢失)</li>
</ul>
<p>适合场景：</p>
<ul>
<li>简单的聊天系统</li>
</ul>
<h3
id="work模式一个生产者多个消费者每个消费者获取到的消息唯一">2、work模式：一个生产者，多个消费者，每个消费者获取到的消息唯一</h3>
<p>流程：</p>
<ul>
<li>1、生产者将消息放入消息队列</li>
<li>多个消息的消费者同时监听消息队列内容,谁先拿到谁负责消费消息(高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关，保证一条消息只能被一个消费者使用)</li>
</ul>
<p>适合场景：</p>
<ul>
<li>抢红包</li>
<li>随机分派任务</li>
</ul>
<h3
id="订阅模式一个生产者发送的消息会被多个消费者获取">3、订阅模式：一个生产者发送的消息会被多个消费者获取</h3>
<p>流程：</p>
<ul>
<li>1、消息产生者将消息放入交换机</li>
<li>2、交换机发布订阅把消息发送到所有消息队列中,对应消息队列的消费者拿到消息进行消费</li>
</ul>
<p>适合场景：</p>
<ul>
<li>邮件下发</li>
<li>场景订阅</li>
<li>短信下发</li>
</ul>
<h3
id="路由模式发送消息到交换机并且要指定路由key-消费者将队列绑定到交换机时需要指定路由key">4、路由模式：发送消息到交换机并且要指定路由key
，消费者将队列绑定到交换机时需要指定路由key</h3>
<p>流程：</p>
<ul>
<li>1、消息生产者将消息发送给交换机</li>
<li>2、交换机根据Routing key,只能匹配上Routing
key对应的消息队列,对应的消费者才能消费消息;</li>
</ul>
<p>路由模式和订阅模式比较相似，只是路由模式模式要求队列在绑定交换机时要指定Routing
key，消息会转发到符合Routing key的队列。</p>
<p>适合场景:</p>
<ul>
<li>邮件下发</li>
<li>场景订阅</li>
<li>短信下发</li>
</ul>
<h3
id="主题模式将路由键和某模式进行匹配此时队列需要绑定在一个模式上匹配一个词或多个词只匹配一个词">5、主题模式：将路由键和某模式进行匹配，此时队列需要绑定在一个模式上，“#”匹配一个词或多个词，“*”只匹配一个词</h3>
<p>流程：</p>
<ul>
<li>1、消息产生者产生消息,把消息交给交换机</li>
<li>2、交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费，每个消费者监听自己的队列，并且设置带统配符的routingkey</li>
</ul>
<p>适合场景：</p>
<ul>
<li>用户通知的各种情况</li>
</ul>
<h2 id="rabbitmq的实战用法">RabbitMQ的实战用法</h2>
<h3 id="保证消息的投递成功">1、保证消息的投递成功</h3>
<p>如何保证消息的成功投递？就拿我这次要做的业务来说，涉及到了资金和记账问题，如果消息没有投递成功，一定会出现差错。差错过多，用户体验怎么样emmmmmm</p>
<p>一般的解决方式有这样几种：</p>
<ul>
<li>确认应答机制</li>
<li>消息自动补偿机制</li>
<li>消息落库，确认消息实际状态</li>
<li>消息的延迟投递，做二次检查，回调检查</li>
</ul>
<h3 id="确认应答机制">确认应答机制</h3>
<p>确认应答机制是rabbitmq自带的，可以设置为手动应答（自动应答很坑），当消费者收到消息在合适的时候来显示的进行确认。消费者说我已经接收到了该消息了，RabbitMQ可以从队列中删除该消息了，可以通过显示调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(envelope.getDeliveryTag(), false)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>来告诉消息服务器来删除消息</p>
<h3 id="消息自动补偿机制">消息自动补偿机制</h3>
<p>在Rabbit
MQ里，如果消费者在处理消息时，业务逻辑出现异常，默认会执行补偿机制（也就是消息重试机制）。如果业务逻辑出现异常，是不会消费消息的。</p>
<h3 id="消息落库机制">消息落库机制</h3>
<p>消息落库机制，就是将写入数据库进行持久化，同时不断对消息状态进行确认，以保证消息的消费成功。<strong>可以通过在数据库中确认消息的消费状态，同时有一个机器去定时获取数据库消息的消费状态，如果状态异常的话就进行消息重发</strong>。同时，也可以将重试次数过多的消息状态改为失败消息并登记下来，交给程序猿人工处理~</p>
<p>###消息的延迟投递机制</p>
<p>延时队列，最重要的特性就体现在它的延时属性上，跟普通的队列不一样的是，普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。</p>
<p>在RabbitMQ中要用到<strong>延时队</strong>列，可以通过<strong>死信队列</strong>来实现。当消息设置<strong>TTL（存活时间）*<em>之后，如果在存活时间内没有被消费，则会成为*</em>死信</strong>。成为<strong>死信</strong>的消息会被投递到<strong>死信队列</strong>里，消费者只需要监听对应的死信队列进行处理即可。</p>
<h3 id="保证消息的消费成功">2、保证消息的消费成功</h3>
<p>成功投递出去还只完成了一半，还需要成功的消费消息才能满足我们的需求。</p>
<p>RabbitMQ默认自动确认(ack)消息被正确消费,
即消息投递到消费者后就自动确认消息被处理完毕, 并且会将该消息删除,
即使消费者意外宕机, 或者抛出异常, 如果消费者接收到消息,
还没处理完成就down掉或者抛出异常, 那么, 这条消息就丢失了。</p>
<p><strong>消息确认模式有:</strong></p>
<ul>
<li>AcknowledgeMode.NONE：自动确认</li>
<li>AcknowledgeMode.AUTO：根据情况确认</li>
<li>AcknowledgeMode.MANUAL：手动确认</li>
</ul>
<p>默认情况下消息消费者是自动ack(确认)消息的, 如果要手动ack(确认),
则需要修改确认模式。同时，手动确认可以被批处理，用以一次性处理大量的内容。</p>
<h3 id="消息持久化">3、消息持久化</h3>
<p>消息被投递到RabbitMQ的内存中, 还没投递到消费者实例之前宕机了,
消息不就丢失了?</p>
<p>可以进行消息持久化, 将Exchange、queue和message都持久化到硬盘, 这样,
RabbitMQ重启时, 会把持久化的Exchange、queue和message从硬盘重新加载出来,
重新投递消息。</p>
<p>同时还是需要将消息持久化到数据库中。</p>
<h3 id="消费端限流">4、消费端限流</h3>
<p>如果RabbitMQ服务器有上万条未处理的消息，我们随便打开一个消费者客户端，会出现巨量的消息瞬间全部推送过来，但我们单个客户端无法同时处理这么多数据，服务器资源耗尽等情况。</p>
<p>RabbitMQ提供一种qos功能，即在非自动确认消息的前提下，如果一定数目的消息未被确认前，不进行消费新的消息。</p>
<h3 id="顺序消息">5、顺序消息</h3>
<p>发送顺序消息，必须保障消息投递到同一个队列，且这个消费者只能有一个（独占模式），同时需要统一提交（可能是合并成一个大消息，也可能是拆分为多个消息），并且所有消息的会话ID一致
添加消息属性：顺序标记的序号、和本次顺序消息的SIZE属性，进行落库操作。每次只消费一条信息，处理过后进行手工ACK，然后接收下一条消息。</p>
<h3 id="重复消费">6、重复消费</h3>
<p>重复消费是消息队列中一个非常危险的问题，特别是在多消费者的模式下，如果一条消息被重复消费，又是涉及资金等方面的话，往往容易出现资金风险。所以，解决消息重复消费的问题是必要的。</p>
<p><strong>保证消息不被重复消费的关键是保证消息队列的幂等性</strong></p>
<p><strong>解决方案如下</strong>：</p>
<p>1、唯一主键
你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突。
2、redis幂等
你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。
3、消费介质
准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p>
<h2 id="ribbitmq集群搭建">RibbitMQ集群搭建</h2>
<p>RabbitMQ
集群分为两种<strong>普通集群</strong>和<strong>镜像集群</strong>。</p>
<h3 id="普通集群">1、普通集群：</h3>
<p>以两个节点（rabbit01、rabbit02）为例来进行说明。rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构，但消息实体只存在于其中一个节点rabbit01（或者rabbit02）中。</p>
<p><strong>当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer</strong>。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。</p>
<p>当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费。如果没有持久化的话，就会产生消息丢失的现象。</p>
<h3 id="镜像集群">2、镜像集群：</h3>
<p>在普通集群的基础上，把需要的队列做成镜像队列，<strong>消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取，也就是说多少节点消息就会备份多少份</strong>。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。</p>
<p><strong>由于镜像队列之间消息自动同步，且内部有选举master机制，即使master节点宕机也不会影响整个集群的使用，达到去中心化的目的，从而有效的防止消息丢失及服务不可用等问题</strong></p>
<p>相比于普通模式，镜像模式的每个节点的存储空间会非常大，集群的消息积压能力会非常弱（无法通过集群节点的扩容提高消息积压能力）。同时，消息的发布者需要将消息复制到每一个集群节点，对于持久化消息，网络和磁盘同步复制的开销都会明显增加。</p>
<h2
id="系统架构引入消息中间件后会有哪些缺点">系统架构引入消息中间件后会有哪些缺点</h2>
<p>消息中间件虽好，但是可以不用还是尽量不要用，毕竟系统解耦了，就会产生一些其他的问题。</p>
<p><strong>系统可用性降低</strong>:
引入MQ，系统多了一个依赖。依赖如果出现问题，就会导致系统可用性降低。一旦引入中间件，就必须考虑这个中间件是如何部署的，如何保证高可用性</p>
<p><strong>系统稳定性降低</strong>: 引入MQ,
可能由于网络故障、中间件故障、消费者异常等原因导致各种各样乱七八糟的问题产生,
从而使系统稳定性下降</p>
<p><strong>分布式一致性问题</strong>: 多系统协同处理一个业务,
不能保证所有系统都正常处理, 有可能出现系统数据不一致的情况,
所以此时又需要使用可靠消息最终一致性的分布式事务方案来保障数据一致性</p>
<p>即使有这么多问题，考虑到分布式的架构才是现在的主流，高耦合的系统难以满足日益增长的用户，分布式环境下需要消息中间件来保障消息传递的高效和可靠，所以我们更要分清楚什么时候用什么样消息中间件。知己知彼，百战不殆。</p>
<h1 id="kafka和rabbitmq比较">kafka和rabbitMQ比较</h1>
<p>作者：四猿外
链接：https://www.zhihu.com/question/275090117/answer/2298925188
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>我可以说一下Kafka和RabbitMQ的区别，各自适合什么场景。</strong></p>
<p>经常有人问我</p>
<blockquote>
<p>有个 xx 需求，我应该用 Kafka 还是 RabbitMQ ？</p>
</blockquote>
<p>这个问题很常见，而且很多人对二者的选择也把握不好。</p>
<p>同时，这个问题在面试中也经常问到。</p>
<p>下面我会通过 6 个场景，来对比分析一下 Kafka 和 RabbitMQ 的优劣。</p>
<h2 id="一消息的顺序">一、消息的顺序</h2>
<p>有这样一个需求：当订单状态变化的时候，把订单状态变化的消息发送给所有关心订单变化的系统。</p>
<p>订单会有创建成功、待付款、已支付、已发货的状态，状态之间是单向流动的。</p>
<p><img
src="https://pic2.zhimg.com/v2-9ff9beb78cfea1f2d402abaeb83d19f6_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pic2.zhimg.com/80/v2-9ff9beb78cfea1f2d402abaeb83d19f6_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p>好，现在我们把订单状态变化消息要发送给所有关心订单状态的系统上去，实现方式就是用消息队列。</p>
<p><img
src="https://pic1.zhimg.com/v2-98d5385101e2922e302141b53186b904_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pic1.zhimg.com/80/v2-98d5385101e2922e302141b53186b904_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p>在这种业务下，我们最想要的是什么？</p>
<ol type="1">
<li>消息的顺序：对于同一笔订单来说，状态的变化都是有严格的先后顺序的。</li>
<li><a
target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=吞吐量&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2298925188%7D">吞吐量</a>：像订单的业务，我们自然希望订单越多越好。订单越多，吞吐量就越大。</li>
</ol>
<p>在这种情况下，我们先看看 RabbitMQ 是怎么做的。</p>
<p>首先，对于发消息，并广播给多个消费者这种情况，RabbitMQ
会为每个消费者建立一个对应的队列。也就是说，如果有 10 个消费者，RabbitMQ
会建立 10 个对应的队列。然后，当一条消息被发出后，RabbitMQ
会把这条消息复制 10 份放到这 10 个队列里。</p>
<p><img
src="https://pic1.zhimg.com/v2-6abd470247cd617f59a7099d513aa602_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pic1.zhimg.com/80/v2-6abd470247cd617f59a7099d513aa602_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p>当 RabbitMQ
把消息放入到对应的队列后，我们紧接着面临的问题就是，我们应该在系统内部启动多少线程去从消息队列中获取消息。</p>
<p>如果只是单线程去获取消息，那自然没有什么好说的。但是多线程情况，可能就会有问题了……</p>
<p>RabbitMQ
有这么个特性，它在官方文档就声明了自己是不保证多线程消费同一个队列的消息，一定保证顺序的。而不保证的原因，是因为多线程时，当一个线程消费消息报错的时候，RabbitMQ
会把消费失败的消息再入队，此时就可能出现乱序的情况。</p>
<p><img
src="https://pica.zhimg.com/v2-f6e27271afcd729fc494e8fc7debd89e_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pica.zhimg.com/80/v2-f6e27271afcd729fc494e8fc7debd89e_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p>T0 时刻，队列中有四条消息 A1、B1、B2、A2。其中 A1、A2 表示订单 A
的两个状态：待付款、已付款。B1、B2 也同理，是订单 B
的待付款、已付款。</p>
<p>到了 T1 时刻，消息 A1 被线程 1 收到，消息 B1 被线程 2
收到。此时，一切都还正常。</p>
<p>到了 T3 时刻，B1 消费出错了，同时呢，由于线程 1
处理速度快，又从消息队列中获取到了 B2。此时，问题开始出现。</p>
<p>到了 T4 时刻，由于 RabbitMQ
线程消费出错，可以把消息重新入队的特性，此时 B1
会被重新放到队列头部。所以，如果不凑巧，线程 1 获取到了
B1，就出现了乱序情况，B2 状态明明是 B1 的后续状态，却被提前处理了。</p>
<p>所以，可以看到了，这个场景用 RabbitMQ，出现了三个问题：</p>
<ol type="1">
<li>为了实现发布订阅功能，从而使用的消息复制，会降低性能并耗费更多资源</li>
<li>多个消费者无法严格保证消息顺序</li>
<li>大量的订单集中在一个队列，吞吐量受到了限制</li>
</ol>
<p>那么 Kafka 怎么样呢？Kafka 正好在这三个问题上，表现的要比 RabbitMQ
要好得多。</p>
<p>首先，Kafka 的发布订阅并不会复制消息，因为 Kafka
的发布订阅就是消费者直接去获取被 Kafka
保存在日志文件中的消息就好。无论是多少消费者，他们只需要主动去找到消息在文件中的位置即可。</p>
<p>其次，Kafka 不会出现消费者出错后，把消息重新入队的现象。</p>
<p>最后，Kafka
可以对订单进行分区，把不同订单分到多个分区中保存，这样，吞吐量能更好。</p>
<p>所以，对于这个需求 Kafka 更合适。</p>
<h2 id="二消息的匹配">二、消息的匹配</h2>
<p>我曾经做过一套营销系统。这套系统中有个非常显著的特点，就是非常复杂非常灵活地匹配规则。</p>
<p>比如，要根据推广内容去匹配不同的方式做宣传。又比如，要根据不同的活动去匹配不同的渠道去做分发。</p>
<p>总之，数不清的匹配规则是这套系统中非常重要的一个特点。</p>
<p><img
src="https://pica.zhimg.com/v2-d467d9e2759cc49fcb1d09cab3ad6fe3_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pica.zhimg.com/80/v2-d467d9e2759cc49fcb1d09cab3ad6fe3_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p>首先，先看看 RabbitMQ 的，你会发现 RabbitMQ 是允许在消息中添加
routing_key 或者自定义消息头，然后通过一些特殊的
Exchange，很简单的就实现了消息匹配分发。开发几乎不用成本。</p>
<p>而 Kafka 呢？如果你要实现消息匹配，开发成本高多了。</p>
<p>首先，通过简单的配置去自动匹配和分发到合适的消费者端这件事是不可能的。</p>
<p>其次，消费者端必须先把所有消息不管需要不需要，都取出来。然后，再根据业务需求，自己去实现各种精准和模糊匹配。可能因为过度的复杂性，还要引入规则引擎。</p>
<p>这个场景下 RabbitMQ 扳回一分。</p>
<h2 id="三消息的超时">三、消息的超时</h2>
<p>在电商业务里，有个需求：下单之后，如果用户在 15
分钟内未支付，则自动取消订单。</p>
<p>你可能奇怪，这种怎么也会用到消息队列的？</p>
<p>我来先简单解释一下，在单一服务的系统，可以起个定时任务就搞定了。</p>
<p>但是，在 SOA
或者微服务架构下，这样做就不行了。因为很多个服务都关心是否支付这件事，如果每种服务，都自己实现一套定时任务的逻辑，既重复，又难以维护。</p>
<p>在这种情况下，我们往往会做一层抽象：把要执行的任务封装成消息。当时间到了，直接扔到消息队列里，消息的订阅者们获取到消息后，直接执行即可。</p>
<p>希望把消息延迟一定时间再处理的，被称为延迟队列。</p>
<p>对于订单取消的这种业务，我们就会在创建订单的时候，同时扔一个包含了执行任务信息的消息到延迟队列，指定15分钟后，让订阅这个队列的各个消费者，可以收到这个消息。随后，各个消费者所在的系统就可以去执行相关的扫描订单的任务了。</p>
<p><img
src="https://pic2.zhimg.com/v2-4737535155eb366b7f91f8d8ef85183c_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pic2.zhimg.com/80/v2-4737535155eb366b7f91f8d8ef85183c_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p>RabbitMQ 和 Kafka 消息队列如何选？</p>
<p>先看下 RabbitMQ 的。</p>
<p>RabbitMQ 的消息自带手表，消息中有个 TTL 字段，可以设置消息在 RabbitMQ
中的存放的时间，超时了会被移送到一个叫死信队列的地方。</p>
<p>所以，延迟队列 RabbitMQ 最简单的实现方式就是设置
TTL，然后一个消费者去监听死信队列。当消息超时了，监听死信队列的消费者就收到消息了。</p>
<p>不过，这样做有个大问题：假设，我们先往队列放入一条过期时间是 10 秒的
A 消息，再放入一条过期时间是 5 秒的 B 消息。 那么问题来了，B 消息会先于
A 消息进入死信队列吗？</p>
<p>答案是否定的。B 消息会优先遵守队列的先进先出规则，在 A
消息过期后，和其一起进入死信队列被消费者消费。</p>
<p>在 RabbitMQ 的 3.5.8 版本以后，官方推荐的 rabbitmq delayed message
exchange 插件可以解决这个问题。</p>
<ul>
<li>用了这个插件，我们在发送消息的时候，把消息发往一个特殊的
Exchange。</li>
<li>同时，在消息头里指定要延迟的时间。</li>
<li>收到消息的 Exchange
并不会立即把消息放到队列里，而是在消息延迟时间到达后，才会把消息放入。</li>
</ul>
<p><img
src="https://pic3.zhimg.com/v2-3386e85e7dddbeeaf4ad80452fc55d25_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pic3.zhimg.com/80/v2-3386e85e7dddbeeaf4ad80452fc55d25_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p>再看下 Kafka 的：</p>
<p><img
src="https://pic1.zhimg.com/v2-f819bd6b5ae62abd95d42ac2fc584c91_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pic1.zhimg.com/80/v2-f819bd6b5ae62abd95d42ac2fc584c91_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p>Kafka 要实现延迟队列就很麻烦了。</p>
<ul>
<li>你先需要把消息先放入一个临时的 topic。</li>
<li>然后得自己开发一个做中转的消费者。让这个中间的消费者先去把消息从这个临时的
topic 取出来。</li>
<li>取出来，这消息还不能马上处理啊，因为没到时间呢。也没法保存在自己的内存里，怕崩溃了，消息没了。所以，就得把没有到时间的消息存入到数据库里。</li>
<li>存入数据库中的消息需要在时间到了之后再放入到 Kafka
里，以便真正的消费者去执行真正的业务逻辑。</li>
<li>……</li>
</ul>
<p>想想就已经头大了，这都快搞成调度平台了。再高级点，还要用时间轮算法才能更好更准确。</p>
<p>这次，RabbitMQ 上那一条条戴手表的消息，才是最好的选择。</p>
<h2 id="四消息的保持">四、消息的保持</h2>
<p>在微服务里，事件溯源模式是经常用到的。如果想用消息队列实现，一般是把事件当成消息，依次发送到消息队列中。</p>
<p>事件溯源有个最经典的场景，就是事件的重放。简单来讲就是把系统中某段时间发生的事件依次取出来再处理。而且，根据业务场景不同，这些事件重放很可能不是一次，更可能是重复
N 次。</p>
<p>假设，我们现在需要一批在线事件重放，去排查一些问题。</p>
<p>RabbitMQ
此时就真的不行了，因为消息被人取出来就被删除了。想再次被重复消费？对不起。</p>
<p>而 Kafka
呢，消息会被持久化一个专门的日志文件里。不会因为被消费了就被删除。</p>
<p>所以，对消息不离不弃的 Kafka 相对用过就抛的 RabbitMQ，请选择
Kafka。</p>
<h2 id="五消息的错误处理">五、消息的错误处理</h2>
<p>很多时候，在做记录数据相关业务的时候，Kafka
一般是不二选择。不过，有时候在记录数据吞吐量不大时，我自己倒是更喜欢用
RabbitMQ。</p>
<p>原因就是 Kafka 有一个我很不喜欢的设计原则：</p>
<p>当单个分区中的消息一旦出现消费失败，就只能停止而不是跳过这条失败的消息继续消费后面的消息。即不允许消息空洞。</p>
<p>只要消息出现失败，不管是 Kafka
自身消息格式的损坏，还是消费者处理出现异常，是不允许跳过消费失败的消息继续往后消费的。</p>
<p>所以，在<strong>数据统计不要求十分精确</strong>的场景下选了
Kafka，一旦出现了消息消费问题，就会发生项目不可用的情况。这真是徒增烦恼。</p>
<p>而 RabbitMQ
呢，它由于会在消息出问题或者消费错误的时候，可以重新入队或者移动消息到死信队列，继续消费后面的，会省心很多。</p>
<p>坏消息就像群众中的坏蛋那样，Kafka
处理这种坏蛋太过残暴，非得把坏蛋揪出来不行。相对来说，RabbitMQ
就温柔多了，群众是群众，坏蛋是坏蛋，分开处理嘛。</p>
<h2 id="六消息的吞吐量">六、消息的吞吐量</h2>
<p>Kafka 是每秒几十万条消息吞吐，而 RabbitMQ
的吞吐量是每秒几万条消息。</p>
<p>其实，在一家公司内部，有必须用到 Kafka
那么大吞吐量的项目真的很少。大部分项目，像 RabbitMQ
那样每秒几万的消息吞吐，已经非常够了。</p>
<p>在一些没那么大吞吐量的项目中引入 Kafka，我觉得就不如引入
RabbitMQ。</p>
<p>为什么呢？</p>
<p>因为 Kafka
为了更好的吞吐量，很大程度上增加了自己的复杂度。而这些复杂度对项目来说，就是麻烦，主要体现在两个方面：</p>
<p>1、配置复杂、维护复杂</p>
<p>Kafka 的参数配置相对 RabbitMQ
是很复杂的。比如：磁盘管理相关参数，集群管理相关参数，ZooKeeper
交互相关参数，Topic 级别相关参数等，都需要一些思考和调优。</p>
<p>另外，Kafka 本身集群和参与管理集群的
ZooKeeper，这就带来了更多的维护成本。Kafka 要用好，你要考虑
JVM，消息持久化，集群本身交互，以及 ZooKeeper 本身和它与 Kafka
之间的可靠和效率。</p>
<p>2、用好，用对存在门槛</p>
<p>Kafka 的 Producer 和 Consumer 本身要用好用对也存在很高的门槛。</p>
<p>比如，Producer 消息可靠性保障、幂等性、事务消息等，都需要对
KafkaProducer 有深入的了解。</p>
<p>而 Consumer
更不用说了，光是一个日志偏移管理就让一大堆人掉了不少头发。</p>
<p>相对来说，RabbitMQ
就简单得多。你可能都不用配置什么，直接启动起来就能很稳定可靠地使用了。就算配置，也是寥寥几个参数设置即可。</p>
<p>所以，大家在项目中引入消息队列的时候，真的要好好考虑下，不要因为大家都鼓吹
Kafka 好，就无脑引入。</p>
<h2 id="总结">总结</h2>
<p>可以看到，如果我们要做消息队列选型，有两件事是必须要做好的：</p>
<ol type="1">
<li>列出业务最重要的几个特点</li>
<li>深入到消息队列的细节中去比较</li>
</ol>
<p>等我们对这些<a
target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=中间件&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2298925188%7D">中间件</a>的特点非常熟悉之后，甚至可以把业务分解成不同的子业务，再根据不同的子业务的特征，引入不同的消息队列，即消息队列混用。这样，我们就可能会最大化我们的获益，最小化我们的成本。</p>
<p>说了这么多，其实还有很多 Kafka 和 RabbitMQ
的比较没有说，比如二者集群的区别，占用资源多少的比较等。以后有机会可以再提提。</p>
<p>总之，期待大家看完这篇文章后，能对 Kafka 和 RabbitMQ
的区别有了更细节性的了解。</p>
<p>最后，分享一个网上的比较全的对比图：</p>
<p><img
src="https://pica.zhimg.com/v2-ff0db65df91aeb9d8f5d01ed198c4225_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pica.zhimg.com/80/v2-ff0db65df91aeb9d8f5d01ed198c4225_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p><img
src="https://pic3.zhimg.com/v2-e8c765f4e879115e8a05803a6a997b20_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pic3.zhimg.com/80/v2-e8c765f4e879115e8a05803a6a997b20_1440w.jpg?source=3af55fa1"
alt="img" /></p>
<p><img
src="https://pic3.zhimg.com/v2-c6f7d0d9c9d3e4acbbddc152384d34fd_720w.jpg?source=3af55fa1"
alt="img" /><img
src="https://pic3.zhimg.com/80/v2-c6f7d0d9c9d3e4acbbddc152384d34fd_1440w.jpg?source=3af55fa1"
alt="img" /></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8F%E9%94%81/" rel="prev" title="深入理解Java中的锁">
      <i class="fa fa-chevron-left"></i> 深入理解Java中的锁
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E4%BA%BA%E7%94%9F%E6%84%BF%E6%9C%9B%E6%B8%85%E5%8D%95/" rel="next" title="人生愿望清单">
      人生愿望清单 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">消息队列的使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">异步处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="nav-number">1.2.</span> <span class="nav-text">应用解耦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A%E9%94%8B"><span class="nav-number">1.3.</span> <span class="nav-text">流量削锋</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">日志处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%80%9A%E8%AE%AF"><span class="nav-number">1.5.</span> <span class="nav-text">消息通讯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">消息队列有什么优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kafkaactivemqrabbitmqrocketmq-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">Kafka、ActiveMQ、RabbitMQ、RocketMQ
有什么优缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E4%B8%8E%E5%85%B6%E4%BB%96mq%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.2.</span> <span class="nav-text">Kafka与其他MQ的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mq%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="nav-number">3.</span> <span class="nav-text">MQ如何保证消息不被重复消费？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mq%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">MQ如何保证消息的顺序性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0"><span class="nav-number">5.</span> <span class="nav-text">如何实现流量削峰</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E5%89%8A%E5%B3%B0"><span class="nav-number">5.1.</span> <span class="nav-text">消息队列解决削峰</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0%E6%BC%8F%E6%96%97%E5%B1%82%E5%B1%82%E5%89%8A%E5%B3%B0"><span class="nav-number">5.2.</span> <span class="nav-text">流量削峰漏斗：层层削峰</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kafka%E6%9E%B6%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">Kafka架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">Kafka的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.1.</span> <span class="nav-text">分布式模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81kafka%E6%B6%88%E8%B4%B9%E4%B8%8D%E4%B9%B1%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">怎么保证Kafka消费不乱序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kafka%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">8.</span> <span class="nav-text">Kafka实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">8.1.</span> <span class="nav-text">Kafka的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">8.2.</span> <span class="nav-text">Kafka的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">8.3.</span> <span class="nav-text">消息投递可靠性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rabbitmq"><span class="nav-number">9.</span> <span class="nav-text">RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">9.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">通信过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="nav-number">9.2.1.</span> <span class="nav-text">流程解析：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.3.</span> <span class="nav-text">消息路由模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%A8%A1%E5%BC%8Fdirect"><span class="nav-number">9.3.1.</span> <span class="nav-text">1、直接模式（Direct）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8Ffanout"><span class="nav-number">9.3.2.</span> <span class="nav-text">2、广播模式（Fanout）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8Ftopic"><span class="nav-number">9.3.3.</span> <span class="nav-text">3、主题模式（Topic）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.4.</span> <span class="nav-text">工作模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E4%B8%80%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%80%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">9.4.1.</span> <span class="nav-text">1、简单模式：一个生产者，一个消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#work%E6%A8%A1%E5%BC%8F%E4%B8%80%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E6%AF%8F%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%B6%88%E6%81%AF%E5%94%AF%E4%B8%80"><span class="nav-number">9.4.2.</span> <span class="nav-text">2、work模式：一个生产者，多个消费者，每个消费者获取到的消息唯一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%9A%E8%A2%AB%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E8%8E%B7%E5%8F%96"><span class="nav-number">9.4.3.</span> <span class="nav-text">3、订阅模式：一个生产者发送的消息会被多个消费者获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B9%B6%E4%B8%94%E8%A6%81%E6%8C%87%E5%AE%9A%E8%B7%AF%E7%94%B1key-%E6%B6%88%E8%B4%B9%E8%80%85%E5%B0%86%E9%98%9F%E5%88%97%E7%BB%91%E5%AE%9A%E5%88%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%97%B6%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9A%E8%B7%AF%E7%94%B1key"><span class="nav-number">9.4.4.</span> <span class="nav-text">4、路由模式：发送消息到交换机并且要指定路由key
，消费者将队列绑定到交换机时需要指定路由key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%E5%B0%86%E8%B7%AF%E7%94%B1%E9%94%AE%E5%92%8C%E6%9F%90%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D%E6%AD%A4%E6%97%B6%E9%98%9F%E5%88%97%E9%9C%80%E8%A6%81%E7%BB%91%E5%AE%9A%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B8%8A%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E8%AF%8D%E6%88%96%E5%A4%9A%E4%B8%AA%E8%AF%8D%E5%8F%AA%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E8%AF%8D"><span class="nav-number">9.4.5.</span> <span class="nav-text">5、主题模式：将路由键和某模式进行匹配，此时队列需要绑定在一个模式上，“#”匹配一个词或多个词，“*”只匹配一个词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rabbitmq%E7%9A%84%E5%AE%9E%E6%88%98%E7%94%A8%E6%B3%95"><span class="nav-number">9.5.</span> <span class="nav-text">RabbitMQ的实战用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%8A%95%E9%80%92%E6%88%90%E5%8A%9F"><span class="nav-number">9.5.1.</span> <span class="nav-text">1、保证消息的投递成功</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6"><span class="nav-number">9.5.2.</span> <span class="nav-text">确认应答机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6"><span class="nav-number">9.5.3.</span> <span class="nav-text">消息自动补偿机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%90%BD%E5%BA%93%E6%9C%BA%E5%88%B6"><span class="nav-number">9.5.4.</span> <span class="nav-text">消息落库机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E6%88%90%E5%8A%9F"><span class="nav-number">9.5.5.</span> <span class="nav-text">2、保证消息的消费成功</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">9.5.6.</span> <span class="nav-text">3、消息持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81"><span class="nav-number">9.5.7.</span> <span class="nav-text">4、消费端限流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="nav-number">9.5.8.</span> <span class="nav-text">5、顺序消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="nav-number">9.5.9.</span> <span class="nav-text">6、重复消费</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ribbitmq%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="nav-number">9.6.</span> <span class="nav-text">RibbitMQ集群搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="nav-number">9.6.1.</span> <span class="nav-text">1、普通集群：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="nav-number">9.6.2.</span> <span class="nav-text">2、镜像集群：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%90%8E%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%BA%E7%82%B9"><span class="nav-number">9.7.</span> <span class="nav-text">系统架构引入消息中间件后会有哪些缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kafka%E5%92%8Crabbitmq%E6%AF%94%E8%BE%83"><span class="nav-number">10.</span> <span class="nav-text">kafka和rabbitMQ比较</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">10.1.</span> <span class="nav-text">一、消息的顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E6%B6%88%E6%81%AF%E7%9A%84%E5%8C%B9%E9%85%8D"><span class="nav-number">10.2.</span> <span class="nav-text">二、消息的匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%B6%88%E6%81%AF%E7%9A%84%E8%B6%85%E6%97%B6"><span class="nav-number">10.3.</span> <span class="nav-text">三、消息的超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%B6%88%E6%81%AF%E7%9A%84%E4%BF%9D%E6%8C%81"><span class="nav-number">10.4.</span> <span class="nav-text">四、消息的保持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E6%B6%88%E6%81%AF%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">10.5.</span> <span class="nav-text">五、消息的错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">10.6.</span> <span class="nav-text">六、消息的吞吐量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">10.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

