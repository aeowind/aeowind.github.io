<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="谈情很好不过也要你拥抱，身体需要觉得未被忘掉过">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJVM/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="谈情很好不过也要你拥抱，身体需要觉得未被忘掉过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000021820580">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000021820582">
<meta property="article:published_time" content="2022-03-04T12:46:25.462Z">
<meta property="article:modified_time" content="2022-04-10T07:03:26.981Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://segmentfault.com/img/remote/1460000021820580">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-10 15:03:26" itemprop="dateModified" datetime="2022-04-10T15:03:26+08:00">2022-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">谈情很好不过也要你拥抱，身体需要觉得未被忘掉过</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1
id="介绍一下java运行时数据区域并说一下每个部分都存哪些内容jvm内存模型">介绍一下Java运行时数据区域，并说一下每个部分都存哪些内容？（JVM内存模型）</h1>
<p><strong>java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域</strong>。
这些区域每一个都有自己的用途。java虚拟机所管理的内存包括以下几个<strong>运行时数据区域</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ov3drd"><img
src="https://s4.ax1x.com/2021/12/14/ov3drd.md.png"
alt="ov3drd.md.png" /></a></p>
<h2 id="程序计数器">程序计数器</h2>
<p>程序计数器是一块较小的内存空间，它可以看作是<code>当前线程所执行的字节码的行号指示器</code>。在虚拟机的概念模型例，<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要来这个计数器完成。</strong></p>
<p><strong>每个线程都有一个独立的程序计数器</strong>，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>唯一没有<code>OutOfMemoryError</code>情况的内存区域。</p>
<p>它的⽣命周期随着线程的创建⽽创建，随着线程的结束⽽死亡。</p>
<p>由于<code>java虚拟机的多线程</code>是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每一条线程都要有一个独立的程序计数器。</p>
<h2 id="java虚拟机栈">java虚拟机栈</h2>
<p>和程序计数器一样，java虚拟机栈也是线程私有的，他的生命周期和线程相同。<strong>虚拟机栈描述的是java方法执行的内存模型，每一个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</strong>
每一个方法从调用直到执行完成的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p><strong>局部变量表</strong>主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引⽤（reference类型，它不同于对象本身，可能是⼀个指向对象起始地址的引⽤指针，也可能是指向⼀个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>这些数据类型在局部变量表中的存储空间是以<strong>局部变量槽</strong>来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。</p>
<p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出<code>stackOverllowError异常</code>；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，那么就会抛出<code>OutOfMemoryError异常</code>。</p>
<h2 id="本地方法栈">本地方法栈</h2>
<p>本地方法栈于虚拟机栈所发挥的作用非常相似，他们之间的区别是一个执行Java方法，一个执行本地方法
—— 一个Native Method就是一个java调用非java代码的接口。</p>
<h2 id="java堆">java堆</h2>
<p>java堆是虚拟机所管理内存最大的一块。<strong>java堆内存是被所有的线程共享的。java堆里面存放的就是对象的实例，几乎所有的对象实例都在这里分配内存。</strong>
在java虚拟机规范中描述，所有的对象实例以及数组都是要在堆上分配内存的。但是随着一些JIT编译器的发展与逃狱分析技术的逐渐成熟，所有对象都在堆上分配内存并不是那么绝对了。</p>
<p>java堆是垃圾收集器的主要管理区域，因此也被称作GC堆（Garbage Collected
Heap）。从内存回收的的角度来看，现在收集器基本都是采用分代收集算法，java堆还可以分为：新生代和老生代。</p>
<p>根据java虚拟机的规范，java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可，就像我们的磁盘空间一样，在实现的时候，既可以实现固定大小的，也可以实现可扩展的的，如果在分配内存的时候，已满，并且不可扩展，那么将会抛出OutOfMemoryError异常。</p>
<h2 id="方法区">方法区</h2>
<p>和java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息，常量、静态变量，即时编译器编译后的代码等数据</strong>，方法区也有一个别名叫做Non-Heap（非堆），用于与Java堆区分。对于HotSpot虚拟机来说，方法区又习惯称为“永久代”（Permancent
Generation），但这只是对于HotSpot虚拟机来说的，其他虚拟机的实现上并没有这个概念。相对而言，垃圾收集行为在这个区域比较少出现，但也并非不会来收集，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载上。根据Java
虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError
异常。</p>
<blockquote>
<p><strong>运行时常量池</strong></p>
</blockquote>
<p>运行时常量池是方法区的一部分。
Class文件中除了有类的版本、字段、方法、接口等描述信息外，<strong>还有一项信息是常量表，用于存放编译期生成的各种字面常量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放（JDK1.7开始，常量池已经被移到了堆内存中了）。</strong>
也就是说，这部分内容，在编译时只是放入到了常量池信息中，到了加载时，才会放到运行时常量池中去。运行时常量池县归于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用的比较多的是String类的intern()方法。</p>
<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常，常量池属于方法区，同样可能抛出OutOfMemoryError异常。</p>
<h2 id="追问1程序计数器可以为空吗">追问1：程序计数器可以为空吗？</h2>
<p><strong>回答</strong>：可以为空，当执行的是本地方法时。</p>
<h2 id="追问2堆中又怎么细分的">追问2：堆中又怎么细分的？</h2>
<p><strong>回答</strong>：堆中可以细分为新生代和老年代，其中新生代又分为Eden区，From
Survivor和To Survivor区，比例是8:1:1。</p>
<h2 id="追问3哪些区域会造成oom">追问3：哪些区域会造成OOM</h2>
<p><strong>回答</strong>：除了程序计数器不会产生OOM，其余的均可以产生OOM。</p>
<h1 id="jdk1.7和1.8-内存模型的区别">JDK1.7和1.8 内存模型的区别</h1>
<blockquote>
<p><strong>JDK1.7JVM内存模型：</strong></p>
</blockquote>
<p><strong>线程私有</strong>：Java虚拟机栈、本地方法栈、程序计数器</p>
<p><strong>线程共享</strong>：方法区、堆</p>
<blockquote>
<p><strong>JDK1.8JVM内存模型：</strong></p>
</blockquote>
<p>JDK1.8与1.7<strong>最大的区别</strong>是1.8将永久代（方法区）取消，取而代之的是<strong>元空间</strong>。</p>
<p>JDK1.7方法区是由永久代实现的，JDK1.8方法区是由元空间实现的，元空间属于本地内存，所以元空间的大小受本地内存的限制。</p>
<h1 id="java内存模型jmm">Java内存模型（JMM）</h1>
<p><strong>Java内存模型</strong>规定所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了<code>被该线程使用到的变量的主内存副本的拷贝</code>，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>
<ul>
<li><p><strong>主内存</strong>：主要对应Java堆中的对象实例数据部分。</p></li>
<li><p><strong>工作内存</strong>：对应于虚拟机栈中的部分区域。</p></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7aeYef"><img
src="https://s4.ax1x.com/2022/01/17/7aeYef.md.png"
alt="7aeYef.md.png" /></a></p>
<h1
id="java中对象的创建过程是什么样的">Java中对象的创建过程是什么样的？</h1>
<ol type="1">
<li><strong>检查类是否已经被加载（类加载检查）</strong></li>
</ol>
<p>当JVM遇到一条字节码 new
指令时，首先检查该引用指向的类是否能够在常量池中被找到（也就是检查方法区中有没有该类的信息），如果没有，先加载这个类；有的话就执行下一步，为对象分配内存。</p>
<ol start="2" type="1">
<li><strong>为对象分配内存空间</strong></li>
</ol>
<p>类加载检查通过后，接下来虚拟机会为新生对象分配内存。对象需要多大的内存在类加载完成后便可完全确定，为对象分配内存就是把一块确定大小的内存块从堆上划分出来。</p>
<p>分配方式有两种：</p>
<ul>
<li><p>java堆内存是绝对规整的</p>
<ul>
<li>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”
。</li>
</ul></li>
<li><p>java堆内存是不规整的</p>
<ul>
<li>若堆内存不规整，已被使用的内存和空闲的内存相互交错在一起，
那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，
在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，
这种分配方式称为“<strong>空闲列表</strong>”（Free List）。</li>
</ul></li>
</ul>
<p>选用那种方式来分配内存，取决堆内存分配是否规整。而堆内存是否规整又取决于垃圾收集器。（核心主要是看采用的是那种垃圾回收算法，是否能进行空间压缩整理）</p>
<ol start="3" type="1">
<li><strong>为对象字段设置零值</strong></li>
</ol>
<p>分配完内存后，需要对对象的字段进行零值初始化（也就是对象的实例数据部分，对象的内存布局被分为三个部分，分别是对象头、实例数据、对齐填充），对象头除外，零值初始化意思就是对对象的字段赋0值，或者null值，这也就解释了为什么这些字段在不需要进程初始化时候就能直接使用。</p>
<ol start="4" type="1">
<li><strong>设置对象头</strong></li>
</ol>
<p>虚拟机需要对这个将要创建出来的对象，进行信息标记，包括是否为新生代/老年代，对象的哈希码，元数据信息，这些标记存放在对象头信息中。</p>
<ol start="5" type="1">
<li><strong>执行构造方法</strong></li>
</ol>
<p>执行对象的构造方法，初始化对象，这样一个对象才算被成功创建。</p>
<h2 id="追问1内存分配的策略有哪些">追问1：内存分配的策略有哪些？</h2>
<p>Java中的内存分配策略主要有两种，分别是<strong>指针碰撞</strong>和<strong>空闲列表</strong>
。</p>
<ul>
<li><p><strong>指针碰撞</strong>：假设Java堆中的内存都是规整的，所有被使用过的放在一边，未使用过的放在一边，中间有一个指针作为分界，分配内存仅仅需要把这个指针向空闲空间方向移动一段即可。</p></li>
<li><p><strong>空闲列表</strong>：如果Java堆中的内存不是规整的，已使用过的和空闲的交错，虚拟机就需要维护一个列表，记录哪些内存是可用的，在分配的时候找到足够大的一块内存进行分配。</p></li>
</ul>
<h2 id="追问2对象头包含哪些">追问2：对象头包含哪些？</h2>
<p>虚拟机中对象头包含两类信息，第一类是用于存储对象自身运动时数据、如哈希码、GC分代年龄、线程持有的锁、偏向线程ID、偏向时间戳。对象的另外一部分是类型指针，即对象指向它的类型元数据的指针。</p>
<h2
id="追问3对象的访问定位方法有几种各有什么优缺点">追问3：对象的访问定位方法有几种，各有什么优缺点？</h2>
<p>Java虚拟机中对象的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</p>
<ul>
<li><strong>句柄</strong>：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference
中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
<li><strong>直接指针</strong>：如果使用直接指针访问，那么 Java
堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference
中存储的直接就是对象的地址。</li>
</ul>
<p><strong>总结</strong>：使用句柄最大的好处就是reference中存储的是稳定句柄地址，在对象移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
<h1 id="堆内存中对象分配的基本策略">堆内存中对象分配的基本策略</h1>
<ol type="1">
<li><strong>对象优先在Eden分配</strong></li>
</ol>
<p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次<code>Minor GC</code>
。</p>
<ol start="2" type="1">
<li><strong>大对象直接进入老年代</strong></li>
</ol>
<p>所谓的大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。可通过配置设置令操作设置值的对象直接在老年代分配。</p>
<p>这样做的目的避免在<code>Eden区</code>以及两个<code>Sur[vivo]()r区</code>之间发生大量的内存复制（新生代采用复制<a
href="">算法</a>收集内存）。</p>
<ol start="3" type="1">
<li><strong>长期存活的对象将进入老年代</strong></li>
</ol>
<p>虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor
GC后仍然存活，并且能被Sur<a href="">vivo</a>r容纳的华，将被移动到Sur<a
href="">vivo</a>r空间中，并且对象的年龄设置为 1.对象在Sur<a
href="">vivo</a>r区中每熬过一次Minor
GC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）就将会被晋升到老年代中。年龄阈值可通过配置调整-XX:MaxTenuringThreshold参数。</p>
<ol start="4" type="1">
<li><strong>动态年龄判定</strong></li>
</ol>
<p>虚拟机并不是永远要求对象的年龄必须达到
<code>MaxTenuringThreshold</code>参数才能晋升到老年代。</p>
<p>如果在Sur<a href="">vivo</a>r空间中相同年龄所有对象大小总和大于Sur<a
href="">vivo</a>r空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到配置参数中要求的年龄。</p>
<ol start="5" type="1">
<li><strong>空间分配担保</strong></li>
</ol>
<p>在发生Minor
GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor
GC可以确保是安全的。</p>
<p>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor
GC,尽管这次Minor
GC是有风险的。如果小于或者设置不允许冒险，这时要改为进行一次Full
GC。</p>
<h1 id="如何判断对象已死">如何判断对象已死？</h1>
<p>Java中判断对象死亡的方法有<strong>引用计数法</strong>和<strong>可达性分析</strong>
。</p>
<ul>
<li><p><strong>引用计数法</strong>：对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p></li>
<li><p><strong>可达性分析</strong>：通过一系列的GC
Roots的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象到GC
Roots间没有任何引用链相连。</p></li>
</ul>
<h2 id="追问1gcroot可以是哪些">追问1：GCroot可以是哪些？</h2>
<p>在Java中可以作为<code>GC Roots</code>的比较多，分别有</p>
<ol type="1">
<li><p>在虚拟机栈中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p></li>
<li><p>在方法区中类静态属性引用的对象，比如Java类的引用类型静态变量。</p></li>
<li><p>在方法区中常量引用的对象，比如字符串常量池里的引用。</p></li>
<li><p>在本地方法栈中JNI引用的对象。</p></li>
<li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象。</p></li>
<li><p>所有被同步锁持有的对象。</p></li>
</ol>
<h2
id="追问2被标志为gc的对象一定会被gc掉吗">追问2：被标志为GC的对象一定会被GC掉吗？</h2>
<p>不一定，还有逃脱的可能。真正宣告一个对象死亡至少经历两次标记的过程。</p>
<p>如果对象进行可达性分析后没有与GC
Roots相连，那么这是第一次标记，之后会在进行一次筛选，筛选的条件是是否有必要执行finalize()方法。</p>
<h1 id="双亲委派模型">双亲委派模型</h1>
<p><strong>双亲委派机制</strong>是当类加载器需要加载某一个<code>.class字节码文件</code>时，则首先会把这个任务委托给他的上级类加载器，<strong>递归</strong>这个操作，如果上级没有加载该.class文件，自己才会去加载这个.class。</p>
<h1 id="双亲委派的作用">双亲委派的作用</h1>
<ol type="1">
<li><strong>防止加载同一个.class。</strong>通过委托去询问上级是否已经加载过该.class，如果加载过了，则不需要重新加载。保证了数据安全。</li>
<li><strong>保证核心.class不被篡改。</strong>通过委托的方式，保证核心.class不被篡改，即使被篡改也不会被加载，即使被加载也不会是同一个class对象，因为不同的加载器加载同一个.class也不是同一个Class对象。这样则保证了Class的执行安全。</li>
</ol>
<h1 id="jvm垃圾回收算法">JVM垃圾回收算法</h1>
<h2 id="标记清除算法mark-sweep">标记—清除算法（Mark-Sweep）</h2>
<p><strong>标记—清除算法是最基础的收集算法</strong>，它分为“<strong>标记</strong>”和“<strong>清除</strong>”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的可达性分析算法中判定垃圾对象的标记过程。标记—清除算法的执行情况如下图所示：</p>
<ul>
<li>回收前状态</li>
</ul>
<figure>
<img
src="https://upload-images.jianshu.io/upload_images/3251891-25c29a521cfe2a4b.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>回收后状态</li>
</ul>
<figure>
<img
src="https://upload-images.jianshu.io/upload_images/3251891-0bbce21010980518.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>该算法有如下缺点：</p>
<ul>
<li>标记和清除过程的<strong>效率都不高</strong></li>
<li>标记清除后会产生大量不连续的<strong>内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作</li>
</ul>
<h2 id="复制算法copy">复制算法（Copy）</h2>
<p>复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它将可用内存按容量分为大小相等的两块，每次只使用其中的一块，<strong>当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉</strong>。复制算法有如下优点：</p>
<ul>
<li>每次只对一块内存进行回收，运行高效</li>
<li>只需移动栈顶指针，按顺序分配内存即可，实现简单</li>
<li>内存回收时不用考虑内存碎片的出现</li>
</ul>
<p>它的缺点是：可一次性分配的<strong>最大内存缩小了一半</strong></p>
<p>复制算法的执行情况如下图所示：</p>
<ul>
<li>回收前状态</li>
</ul>
<figure>
<img
src="https://upload-images.jianshu.io/upload_images/3251891-977ed6107c0476b7.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>回收后状态</li>
</ul>
<figure>
<img
src="https://upload-images.jianshu.io/upload_images/3251891-af88a9c36b9338d4.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为<strong>一块比较大的Eden空间和两块较小的Survivor空间</strong>，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是<strong>8:1</strong>，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</p>
<p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于<strong>老年代</strong>进行<strong>分配担保</strong>，所以大对象直接进入老年代。</p>
<h2 id="标记整理算法mark-compact">标记—整理算法（Mark-Compact）</h2>
<p>复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，<strong>而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存</strong>。标记—整理算法的回收情况如下所示：</p>
<ul>
<li>回收前状态：</li>
</ul>
<figure>
<img
src="https://upload-images.jianshu.io/upload_images/3251891-7383aa69926fa5c3.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>回收后状态：</li>
</ul>
<figure>
<img
src="https://upload-images.jianshu.io/upload_images/3251891-b1070ff58ce46e24.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="分代收集">分代收集</h2>
<p>当前商业虚拟机的垃圾收集都采用分代收集，它<strong>根据对象的存活周期的不同将内存划分为几块</strong>，一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>。</p>
<ul>
<li>在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用<strong>复制算法</strong>来完成收集</li>
<li>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记—清除算法</strong>或<strong>标记—整理算法</strong>来进行回收</li>
</ul>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 20%" />
<col style="width: 26%" />
<col style="width: 17%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">GC算法</th>
<th style="text-align: center;">优点</th>
<th style="text-align: center;">缺点</th>
<th style="text-align: center;">存活对象移动</th>
<th style="text-align: center;">内存碎片</th>
<th style="text-align: center;">适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">引用计数</td>
<td style="text-align: center;">实现简单</td>
<td style="text-align: center;">不能处理循环引用</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">标记清除</td>
<td style="text-align: center;">不需要额外空间</td>
<td style="text-align: center;">两次扫描，耗时严重</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">老年代</td>
</tr>
<tr class="odd">
<td style="text-align: center;">复制</td>
<td style="text-align: center;">没有标记和清除</td>
<td style="text-align: center;">需要额外空间</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">新生代</td>
</tr>
<tr class="even">
<td style="text-align: center;">标记整理</td>
<td style="text-align: center;">没有内存碎片</td>
<td style="text-align: center;">需要移动对象的成本</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">老年代</td>
</tr>
</tbody>
</table>
<h1 id="类加载机制">类加载机制</h1>
<p>每个 Java 文件都存储着需要执行的程序逻辑，这些 java 文件经过 Java
编译器编译成 class 文件，class 文件中保存着 JVM
虚拟机指令，当需要某个类时，虚拟机将会加载它的 class 文件，并创建对应的
class 对象，将 class
文件加载到虚拟机的内存，这个过程称为<strong>类加载</strong>。</p>
<h2 id="类文件到虚拟机类加载机制">类文件到虚拟机(类加载机制):</h2>
<p>JVM
将类的加载过程分为三个大的步骤：<strong>加载(loading)，链接(link)，初始化(initialize)</strong>。其中链接又分为三个步骤：<strong>验证，准备，解析</strong>。</p>
<figure>
<img
src="https://img2020.cnblogs.com/i-beta/1383365/202003/1383365-20200310142826292-418936908.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="加载loading"><strong>加载(loading)：</strong></h3>
<p>加载是类加载过程中的第一个阶段，加载过程虚拟机需要完成以下三件事情：</p>
<ol type="1">
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li>
</ol>
<p>这个过程主要就是<strong>类加载器</strong>完成。</p>
<h3 id="链接link"><strong>链接(link)：</strong></h3>
<p><strong>链接</strong>分为3个小部分，验证、准备、解析。</p>
<p><strong>验证</strong>：验证的目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证；</p>
<p><strong>准备</strong>：给静态方法和静态变量赋予初值，比如static int
a；给其中的a赋予初值为0，但是这里不会给final修饰的静态变量赋予初值，因为被final修饰的静态变量在编译期间就已经被赋予初值了；<strong>内存分配的对象。</strong>Java
中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static
修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM
只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。例如下面的代码在准备阶段之后，num
的值将是 7，而不是 0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int num = 7;</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：主要将常量池中的符号引用替换为直接引用的过程。</p>
<h3 id="初始化initialize"><strong>初始化(initialize)：</strong></h3>
<p>到了初始化阶段，用户定义的 Java
程序代码才真正开始执行。在这个阶段，JVM
会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5
种情况的时候会触发初始化：</p>
<ol type="1">
<li>遇到 new、getstatic、putstatic、invokestatic
这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect
包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK1.7 动态语言支持时，如果一个
java.lang.invoke.MethodHandle实例最后的解析结果
REF_getstatic,REF_putstatic,REF_invokeStatic
的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li>
</ol>
<h1 id="jvm垃圾回收器">Jvm垃圾回收器</h1>
<p>上文提到过现代的商用虚拟机的都是采用分代收集的，不同的区域用不同的收集器。常用的7种收集器，其适用的范围如图所示</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b974272614~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><strong>Serial、ParNew、Parallel Scavenge</strong>用于新生代；</li>
<li><strong>CMS、Serial Old、Paralled Old</strong>用于老年代。
并且他们相互之间以相对固定的组合使用（具体组合关系如上图）。</li>
<li><strong>G1</strong>是一个独立的收集器不依赖其他6种收集器。</li>
<li><strong>ZGC</strong>是目前JDK 11的实验收集器。</li>
</ul>
<h2 id="serial收集器">Serial收集器</h2>
<p><strong>Serial</strong>，是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。</p>
<p>因为新生代的特点是对象存活率低，所以收集算法用的是复制算法，把新生代存活对象复制到老年代，复制的内容不多，性能较好。</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b50a287549~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>单线程的好处就是减少上下文切换，减少系统资源的开销。但这种方式的缺点也很明显，在GC的过程中，会暂停程序的执行。若GC不是频繁发生，这或许是一个不错的选择，否则将会影响程序的执行性能。
对于新生代来说，区域比较小，停顿时间短，所以比较使用。</p>
<h2 id="parnew收集器">ParNew收集器</h2>
<p><strong>ParNew</strong>同样用于新生代，是Serial的多线程版本，并且在参数、算法（同样是复制算法）上也完全和Serial相同。</p>
<p>Par是Parallel的缩写，但它的并行仅仅指的是收集多线程并行，并不是收集和原程序可以并行进行。ParNew也是需要暂停程序一切的工作，然后多线程执行垃圾回收。</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b50bf68a9f~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>因为是多线程执行，所以在多CPU下，ParNew效果通常会比Serial好。但如果是单CPU则会因为线程的切换，性能反而更差。</p>
<h2 id="parallel-scavenge收集器">Parallel Scavenge收集器</h2>
<p>新生代的收集器，同样用的是复制算法，也是并行多线程收集。与ParNew最大的不同，<strong>它关注的是垃圾回收的吞吐量</strong>。</p>
<p>这里的吞吐量指的是总时间与垃圾回收时间的比例。这个比例越高，证明垃圾回收占整个程序运行的比例越小。</p>
<p>Parallel Scavenge收集器提供两个参数控制垃圾回收的执行：</p>
<ul>
<li><strong>-XX:MaxGCPauseMillis</strong>，最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。
所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。</li>
<li><strong>-XX:GCTimeRatio</strong>，垃圾回收时间与总时间占比。这个是吞吐量的倒数，原理和MaxGCPauseMillis相同。</li>
</ul>
<p>因为Parallel
Scavenge收集器关注的是吞吐量，所以当设置好以上参数的时候，同时不想设置各个区域大小（新生代，老年代等）。可以开启<strong>-XX:UseAdaptiveSizePolicy</strong>参数，让JVM监控收集的性能，动态调整这些区域大小参数。</p>
<h2 id="serial-old收集器">Serial Old收集器</h2>
<p>老年代的收集器，与Serial一样是单线程，不同的是算法用的是标记-整理（Mark-Compact）。</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b5010433de~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>因为老年代里面对象的存活率高，如果依旧是用复制算法，需要复制的内容较多，性能较差。并且在极端情况下，当存活为100%时，没有办法用复制算法。所以需要用Mark-Compact，以有效地避免这些问题。</p>
<h2 id="parallel-old收集器">Parallel Old收集器</h2>
<p>老年代的收集器，是Parallel
Scavenge老年代的版本。其中的算法替换成<strong>Mark-Compact</strong>。</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b504043412~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="cms收集器">CMS收集器</h2>
<p>CMS，Concurrent Mark
Sweep，同样是老年代的收集器。<strong>它关注的是垃圾回收最短的停顿时间（低停顿）</strong>，在老年代并不频繁GC的场景下，是比较适用的。</p>
<p>命名中用的是concurrent，而不是parallel，说明这个收集器是有与工作执行并发的能力的。MS则说明算法用的是<strong>Mark
Sweep</strong>算法。</p>
<p>来看看具体的工作原理。CMS整个过程比之前的收集器要复杂，整个过程分为四步：</p>
<ul>
<li>初始标记（initial mark），单线程执行，需要“Stop The
World”，但仅仅把GC
Roots的直接关联可达的对象给标记一下，由于直接关联对象比较小，所以这里的速度非常快。</li>
<li>并发标记（concurrent
mark），对于初始标记过程所标记的初始标记对象，进行并发追踪标记，此时其他线程仍可以继续工作。此处时间较长，但不停顿。</li>
<li>重新标记（remark），在并发标记的过程中，由于可能还会产生新的垃圾，所以此时需要重新标记新产生的垃圾。此处执行并行标记，与用户线程不并发，所以依然是“Stop
The World”，时间比初始时间要长一点。</li>
<li>并发清除（concurrent
sweep），并发清除之前所标记的垃圾。其他用户线程仍可以工作，不需要停顿。</li>
</ul>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b957aa61ad~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>由于CMS以上特性，缺点也是比较明显的，</p>
<ul>
<li>Mark Sweep算法会导致内存碎片比较多</li>
<li>CMS的并发能力依赖于CPU资源，所以在CPU数少和CPU资源紧张的情况下，性能较差</li>
<li>并发清除阶段，用户线程依然在运行，所以依然会产生新的垃圾，此阶段的垃圾并不会再本次GC中回收，而放到下次。所以GC不能等待内存耗尽的时候才进行GC，这样的话会导致并发清除的时候，用户线程可以了利用的空间不足。所以这里会浪费一些内存空间给用户线程预留。</li>
</ul>
<p><strong>有人会觉得既然Mark
Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？</strong></p>
<p><strong>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark
Compact更适合“Stop the World”这种场景下使用。</strong></p>
<h2 id="g1收集器">G1收集器</h2>
<p>G1，Garbage First，在JDK
1.7版本正式启用，是当时最前沿的垃圾收集器。G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间的问题。虽然流程与CMS比较相似，但底层的原理已是完全不同。</p>
<p><strong>高效益优先</strong>。G1会预测垃圾回收的<strong>停顿</strong>时间，原理是计算老年代对象的效益率，优先回收最大效益的对象。</p>
<p><strong>堆内存结构的不同</strong>。以前的收集器分代是划分新生代、老年代、持久代等。</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b76cd8ac05~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>G1则是把内存分为多个大小相同的区域Region，每个Region拥有各自的分代属性，但这些分代不需要连续。</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b76dfc400b~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这样的分区可以有效避免内存碎片化问题。</p>
<p>但是这样同样会引申一个新的问题，就是分代的内存不连续，导致在GC搜索垃圾对象的时候需要全盘扫描找出引用内存所在。</p>
<p>为了解决这个问题，G1对于每个Region都维护一个Remembered
Set，用于记录对象引用的情况。当GC发生的时候根据Remembered
Set的引用情况去搜索。</p>
<p><strong>两种GC模式</strong>：</p>
<ul>
<li>Young
GC，关注于所有年轻代的Region，通过控制收集年轻代的Region个数，从而控制GC的回收时间。</li>
<li>Mixed
GC，关注于所有年轻代的Region，并且加上通过预测计算最大收益的若干个老年代Region。</li>
</ul>
<p>整体的执行流程：</p>
<ul>
<li>初始标记（initial mark），标记了从GC
Root开始直接关联可达的对象。STW（Stop the World）执行。</li>
<li>并发标记（concurrent
marking），并发标记初始标记的对象，此时用户线程依然可以执行。</li>
<li>最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。</li>
<li>筛选回收（Live Data Counting And
Evacuation），评估标记垃圾，根据GC模式回收垃圾。STW执行。</li>
</ul>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661f3b79ca85a8c~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在Region层面上，整体的算法偏向于Mark-Compact。因为是Compact，会影响用户线程执行，所以回收阶段需要STW执行。</p>
<h2 id="令人惊叹的zgc">令人惊叹的ZGC</h2>
<p>在JDK
11当中，加入了实验性质的ZGC。它的回收耗时平均不到2毫秒。它是一款低停顿高并发的收集器。</p>
<p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际是非常少的。那么其他阶段是怎么做到可以并发执行的呢？</p>
<p>ZGC主要新增了两项技术，一个是<strong>着色指针Colored
Pointer</strong>，另一个是<strong>读屏障Load Barrier</strong>。</p>
<p><strong>着色指针Colored Pointer</strong>
ZGC利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0（ZGC仅支持64位平台），以标记该指向内存的存储状态。相当于在对象的指针上标注了对象的信息。注意，这里的指针相当于Java术语当中的引用。</p>
<p>在这个被指向的内存发生变化的时候（内存在Compact被移动时），颜色就会发生变化。</p>
<p>在G1的时候就说到过，Compact阶段是需要STW，否则会影响用户线程执行。那么怎么解决这个问题呢？</p>
<p><strong>读屏障Load Barrier</strong>
由于着色指针的存在，在程序运行时访问对象的时候，可以轻易知道对象在内存的存储状态（通过指针访问对象），若请求读的内存在被着色了。那么则会触发读屏障。读屏障会更新指针再返回结果，此过程有一定的耗费，从而达到与用户线程并发的效果。</p>
<p>把这两项技术联合下理解，引用R大（RednaxelaFX）的话</p>
<blockquote>
<p>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load
Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop
The World。</p>
</blockquote>
<p>ZGC虽然目前还在JDK
11还在实验阶段，但由于算法与思想是一个非常大的提升，相信在未来不久会成为主流的GC收集器使用。</p>
<h1 id="什么情况下发生gc">什么情况下发生GC</h1>
<h1 id="整体介绍垃圾回收">整体介绍垃圾回收</h1>
<h2 id="gc的主要任务">GC的主要任务</h2>
<ol type="1">
<li><p>分配内存；</p></li>
<li><p>确保被引用对象的内存不被错误的回收；</p></li>
<li><p>回收不再被引用的对象的内存空间。</p></li>
</ol>
<h2 id="垃圾回收机制的主要解决问题">垃圾回收机制的主要解决问题</h2>
<ol type="1">
<li><p>哪些内存需要回收？</p></li>
<li><p>什么时候回收？</p></li>
<li><p>如何回收？</p></li>
</ol>
<p><strong>针对问题一</strong>，垃圾收集器会对堆进行回收前，确定对象中哪些是“存活”，哪些是”死亡“（不可能再被任何途径使用的对象）</p>
<blockquote>
<p>判断方法</p>
</blockquote>
<ol type="1">
<li>引用计数法</li>
</ol>
<ul>
<li>每当一个地方引用它时，计数器+1；引用失效时，计数器-1；计数值=0——不可能再被引用。</li>
</ul>
<ol start="2" type="1">
<li>可达性分析法：</li>
</ol>
<ul>
<li>向图，树图，把一系列“GC
Roots”作为起始点，从节点向下搜索，路径称为引用链，当一个对象到GC
Roots没有任何引用链相连，即不可达时，则证明此对象时不可用的。</li>
</ul>
<p><strong>针对问题2——什么时候回收？</strong></p>
<p>即使是被判断不可达的对象，也要再进行筛选，当对象没有覆盖finalize()方法，或者finalize方法已经被虚拟机调用过，则没有必要执行；</p>
<p>如果有必要执行——放置在F-Queue的队列中——Finalizer线程执行。</p>
<p>注意：对象可以在被GC时可以自我拯救(this)，机会只有一次，因为任何一个对象的finalize（）方法都只会被系统自动调用一次。并不建议使用，应该避免。使用try_finaly或者其他方式。</p>
<p><strong>问题3——如何回收,这就牵扯到垃圾收集算法和垃圾收集器</strong></p>
<p><strong>垃圾收集算法：</strong></p>
<ol type="1">
<li><p>标记—清除算法</p></li>
<li><p>复制算法</p></li>
<li><p>标记—整理算法</p></li>
</ol>
<p><strong>垃圾收集器</strong></p>
<h2 id="最后来讲一下流程">最后来讲一下流程</h2>
<p>新建的对象在新生代中，如果新生代内存不够，就进行Minor
GC释放掉不活跃对象；如果还是不够，就把部分活跃对象复制到老年代中，如果还是不够，就进行MajorGC释放老年代，如果还是不够，JVM会抛出内存不足，发生oom，内存泄漏。</p>
<h1 id="可达性分析">可达性分析</h1>
<p><strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p>
<ul>
<li><p><strong>引用计数法</strong>：在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>但是这样的算法有个问题，就是不能解决循环依赖的问题。Object 1和Object
2其实都可以被回收，但是它们之间还有相互引用，所以它们各自的计数器为1，则还是不会被回收。</p>
<p>所以，Java虚拟机没有采用引用计数法。它采用的是可达性分析算法。</p></li>
</ul>
<figure>
<img src="https://segmentfault.com/img/remote/1460000021820580"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><p><strong>可达性分析算法：</strong>就是通过一系列的“GC
Roots”，也就是根对象作为起始节点集合，从根节点开始，根据<strong>引用关系</strong>向下搜索，搜索过程所走过的路径称为<strong>引用链</strong>，如果某个对象到GC
Roots间没有任何引用链相连。</p>
<p>用图论的话来说就是从GC
Roots到这个对象不可达时，则证明此对象是不可能再被使用的。所以此对象就是可以被回收的对象。</p></li>
</ul>
<figure>
<img src="https://segmentfault.com/img/remote/1460000021820582"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="gc-root有哪几种">GC Root有哪几种</h1>
<ol type="1">
<li><p><strong>虚拟机栈中引用的对象</strong>
比如：各个线程被调用的方法中使用到的参数、局部变量等。</p></li>
<li><p><strong>本地方法栈内JNI（通常说的本地方法）引用的对象</strong></p></li>
<li><p><strong>方法区中类静态属性引用的对象</strong>
比如：Java类的引用类型静态变量</p></li>
<li><p><strong>方法区中常量引用的对象</strong>
比如：字符串常量池（string Table） 里的引用</p></li>
<li><p><strong>所有被同步锁synchronized持有的对象</strong></p></li>
<li><p><strong>Java虚拟机内部的引用</strong>
基本数据类型对应的Class对象，一些常驻的异常对象（如：
NullPointerException、OutOfMemoryError） ，系统类加载器。</p></li>
<li><p><strong>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong></p></li>
<li><p><strong>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC
Roots集合。比如：分代收集和局部回收（Partial GC）。</strong>
如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC
Roots集合中去考虑，才能保证可达性分析的准确性。</p></li>
</ol>
<h1
id="遇到的oom问题如何定位排查与解决">遇到的OOM问题，如何定位、排查与解决</h1>
<h2 id="section"></h2>
<ol type="1">
<li><p><strong>先查看应用进程号pid</strong>：
<code>ps  -ef | grep  应用名</code></p></li>
<li><p><strong>查看pid垃圾回收情况</strong>：
<code>jstat  -gc  pid  5000（时间间隔）</code></p></li>
</ol>
<p>即会每5秒一次显示进程号为68842的java进成的GC情况，显示内容如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bJYCTA"><img
src="https://s4.ax1x.com/2022/03/03/bJYCTA.md.png"
alt="bJYCTA.md.png" /></a></p>
<ol start="3" type="1">
<li><strong>开启OOM快照</strong>：</li>
</ol>
<p><code>-XX：+HeapDumpOnOutOfMemoryError</code>（开启堆快照）</p>
<p><code>-XX：HeapDumpPath=C:/m.hprof</code>（保存文件到哪个目录）</p>
<ol start="4" type="1">
<li><strong>dump 查看方法栈信息：</strong></li>
</ol>
<p><code>jstack -l  pid  &gt;  /home/test/jstack.txt</code></p>
<ol start="5" type="1">
<li><strong>dump 查看JVM内存分配以及使用情况</strong></li>
</ol>
<p><code>jmap  -heap  pid  &gt;  /home/test/jmapHeap.txt</code></p>
<ol start="6" type="1">
<li><strong>dump jvm二进制的内存详细使用情况</strong>
（效果同在Tomcat的catalina.sh中添加 set JAVA_OPTS=%JAVA_OPTS% -server
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/test//oom.hprof
此文件需要借用内存分析工具如：Memory Analyzer (MAT)来分析）</li>
</ol>
<p><code>jmap -dump:format=b,file=/home/test/oom.hprof  pid</code></p>
<h2 id="oom一般有以下两种情况">OOM一般有以下两种情况：</h2>
<ol type="1">
<li><strong>老年代堆空间被占满</strong></li>
</ol>
<p>异常：java.lang.OutOfMemoryError：java heap space</p>
<p>说明：这是最典型的内存泄漏方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机再也无法分配新空间</p>
<p><strong>解决方案</strong>：这种方式解决起来比较简单，一般就是根据垃圾回收前后的情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。</p>
<ol start="2" type="1">
<li><strong>持久代被占满</strong></li>
</ol>
<p>异常：java.lang.OutOfMemoryError：PermGen space</p>
<p>说明：Perm 空间被占满，无法为新的 class
分配存储空间而引发的异常。这个异常以前是没有的，但是在 java
大量使用反射的今天这个异常就比较常见了。主要原因是大量动态反射生成的类不断被加载，最终导致
Perm 区被占满。更可怕的是，不同的 classLoader
即便使用相同的类，但是都会对其进行加载，相当于同一个东西，如果有 N
个classLoader 那么它将会被加载 N
次。因此，在某些情况下，这个问题基本视为无解，当然，存在大量 classLoader
和大量反射类的情况并不多</p>
<p><strong>解决方案</strong>：增加持久代内存
，例如：-XX：MaxPermSize=16M</p>
<h1 id="jvm调优参数与实例">Jvm调优参数与实例</h1>
<p>要认识到JVM调优不是常规手段，性能问题一般第一选择是优化程序，最后的选择才是进行JVM调优。</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8629351472b4e9888271e45f86144da~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="调优层级" />
<figcaption aria-hidden="true">调优层级</figcaption>
</figure>
<p>JVM的自动内存管理本来就是为了将开发人员从内存管理的泥潭里拉出来。即使不得不进行JVM调优，也绝对不能拍脑门就去调整参数，一定要全面监控，详细分析性能数据。</p>
<h2 id="jvm调优的时机">JVM调优的时机</h2>
<p>不得不考虑进行JVM调优的是那些情况呢？</p>
<ul>
<li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li>
<li>Full GC 次数频繁；</li>
<li>GC 停顿时间过长（超过1秒）；</li>
<li>应用出现OutOfMemory 等内存异常；</li>
<li>应用中有使用本地缓存且占用大量内存空间；</li>
<li>系统吞吐量与响应性能不高或下降。</li>
</ul>
<h2 id="jvm调优的目标">JVM调优的目标</h2>
<p>吞吐量、延迟、内存占用三者类似CAP，构成了一个不可能三角，只能选择其中两个进行调优，不可三者兼得。</p>
<ul>
<li>延迟：GC低停顿和GC低频率；</li>
<li>低内存占用；</li>
<li>高吞吐量;</li>
</ul>
<p>选择了其中两个，必然会会以牺牲另一个为代价。</p>
<p>下面展示了一些JVM调优的量化目标参考实例：</p>
<ul>
<li>Heap 内存使用率 &lt;= 70%;</li>
<li>Old generation内存使用率&lt;= 70%;</li>
<li>avgpause &lt;= 1秒;</li>
<li>Full gc 次数0 或 avg pause interval &gt;= 24小时 ;</li>
</ul>
<p>注意：不同应用的JVM调优量化目标是不一样的。</p>
<h2 id="jvm调优的步骤">JVM调优的步骤</h2>
<p>一般情况下，JVM调优可通过以下步骤进行：</p>
<ul>
<li>分析系统系统运行情况：分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li>
<li>确定JVM调优量化目标；</li>
<li>确定JVM调优参数（根据历史JVM参数来调整）；</li>
<li>依次确定调优内存、延迟、吞吐量等指标；</li>
<li>对比观察调优前后的差异；</li>
<li>不断的分析和调整，直到找到合适的JVM参数配置；</li>
<li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li>
</ul>
<p>以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行。</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac22afe6c0ef45cc9f16b042f9751665~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="JVM调优步骤" />
<figcaption aria-hidden="true">JVM调优步骤</figcaption>
</figure>
<h2 id="jvm参数">JVM参数</h2>
<p>下面来看一下JDK的JVM参数。</p>
<h3 id="基本参数">基本参数</h3>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 32%" />
<col style="width: 5%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>参数名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>默认值</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-Xms</td>
<td>初始堆大小</td>
<td>内存的1/64</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr class="even">
<td>-Xmx</td>
<td>最大堆大小</td>
<td>内存的1/4</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到
-Xms的最小限制</td>
</tr>
<tr class="odd">
<td>-Xmn</td>
<td>年轻代大小</td>
<td></td>
<td><strong>注意</strong>：此处的大小是（eden+ 2 survivor space).与jmap
-heap中显示的New gen是不同的。 整个堆大小=年轻代大小 + 年老代大小 +
持久代大小.
增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr class="even">
<td>-XX:NewSize</td>
<td>设置年轻代大小</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:MaxNewSize</td>
<td>年轻代最大值</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-XX:PermSize</td>
<td>设置持久代(perm gen)初始值</td>
<td>内存的1/64</td>
<td>JDK1.8以前</td>
</tr>
<tr class="odd">
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>内存的1/4</td>
<td>JDK1.8以前</td>
</tr>
<tr class="even">
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td></td>
<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行
调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右
一般小的应用， 如果栈不是很深， 应该是128k够用的
大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）
和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:"”
-Xss is translated in a VM flag named ThreadStackSize”
一般设置这个值就可以了。</td>
</tr>
<tr class="odd">
<td>-<em>XX:ThreadStackSize</em></td>
<td>Thread Stack Size</td>
<td></td>
<td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was
256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024
(was 0 in 5.0 and earlier); all others 0.]</td>
</tr>
<tr class="even">
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td></td>
<td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5
Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
</tr>
<tr class="odd">
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr class="even">
<td>-XX:LargePageSizeInBytes</td>
<td>内存页的大小不可设置过大， 会影响Perm的大小</td>
<td></td>
<td>=128m</td>
</tr>
<tr class="odd">
<td>-XX:+UseFastAccessorMethods</td>
<td>原始类型的快速优化</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-XX:+DisableExplicitGC</td>
<td>关闭System.gc()</td>
<td></td>
<td>这个参数需要严格的测试</td>
</tr>
<tr class="odd">
<td>-XX:+ExplicitGCInvokesConcurrent</td>
<td>关闭System.gc()</td>
<td>disabled</td>
<td>Enables invoking of concurrent GC by using the System.gc() request.
This option is disabled by default and can be enabled only together with
the -XX:+UseConcMarkSweepGC option.</td>
</tr>
<tr class="even">
<td>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</td>
<td>关闭System.gc()</td>
<td>disabled</td>
<td>Enables invoking of concurrent GC by using the System.gc() request
and unloading of classes during the concurrent GC cycle. This option is
disabled by default and can be enabled only together with the
-XX:+UseConcMarkSweepGC option.</td>
</tr>
<tr class="odd">
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄</td>
<td></td>
<td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.
对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活
时间,增加在年轻代即被回收的概率 该参数只有在串行GC时才有效.</td>
</tr>
<tr class="even">
<td>-XX:+AggressiveOpts</td>
<td>加快编译</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:+UseBiasedLocking</td>
<td>锁机制的性能改善</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-Xnoclassgc</td>
<td>禁用垃圾回收</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:SoftRefLRUPolicyMSPerMB</td>
<td>每兆堆空闲空间中SoftReference的存活时间</td>
<td>1s</td>
<td>softly reachable objects will remain alive for some amount of time
after the last time they were referenced. The default value is one
second of lifetime per free megabyte in the heap</td>
</tr>
<tr class="even">
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在旧生代分配</td>
<td>0</td>
<td>单位字节 新生代采用Parallel Scavenge GC时无效
另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
</tr>
<tr class="odd">
<td>-XX:TLABWasteTargetPercent</td>
<td>TLAB占eden区的百分比</td>
<td>1%</td>
<td></td>
</tr>
<tr class="even">
<td>-XX:+<em>CollectGen0First</em></td>
<td>FullGC时是否先YGC</td>
<td>false</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Jdk7版本的主要参数</strong></p>
<table>
<thead>
<tr class="header">
<th><strong>参数名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>默认值</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-XX:PermSize</td>
<td>设置持久代</td>
<td></td>
<td>Jdk7版本及以前版本</td>
</tr>
<tr class="even">
<td>-XX:MaxPermSize</td>
<td>设置最大持久代</td>
<td></td>
<td>Jdk7版本及以前版本</td>
</tr>
</tbody>
</table>
<p><strong>Jdk8版本的重要特有参数</strong></p>
<table>
<thead>
<tr class="header">
<th><strong>参数名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>默认值</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-XX:MetaspaceSize</td>
<td>元空间大小</td>
<td></td>
<td>Jdk8版本</td>
</tr>
<tr class="even">
<td>-XX:MaxMetaspaceSize</td>
<td>最大元空间</td>
<td></td>
<td>Jdk8版本</td>
</tr>
</tbody>
</table>
<h3 id="并行收集器相关参数">并行收集器相关参数</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 18%" />
<col style="width: 33%" />
<col style="width: 6%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>参数名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>默认值</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-XX:+UseParallelGC</td>
<td>Full GC采用parallel MSC (此项待验证)</td>
<td></td>
<td>选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td>
</tr>
<tr class="even">
<td>-XX:+UseParNewGC</td>
<td>设置年轻代为并行收集</td>
<td></td>
<td>可与CMS收集同时使用
JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td>
</tr>
<tr class="odd">
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
<td></td>
<td>此值最好配置与处理器数目相等 同样适用于CMS</td>
</tr>
<tr class="even">
<td>-XX:+UseParallelOldGC</td>
<td>年老代垃圾收集方式为并行收集(Parallel Compacting)</td>
<td></td>
<td>这个是JAVA 6出现的参数选项</td>
</tr>
<tr class="odd">
<td>-XX:MaxGCPauseMillis</td>
<td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
<td></td>
<td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td>
</tr>
<tr class="even">
<td>-XX:+UseAdaptiveSizePolicy</td>
<td>自动选择年轻代区大小和相应的Survivor区比例</td>
<td></td>
<td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td>
</tr>
<tr class="odd">
<td>-XX:GCTimeRatio</td>
<td>设置垃圾回收时间占程序运行时间的百分比</td>
<td></td>
<td>公式为1/(1+n)</td>
</tr>
<tr class="even">
<td>-XX:+<em>ScavengeBeforeFullGC</em></td>
<td>Full GC前调用YGC</td>
<td>true</td>
<td>Do young generation GC prior to a full GC. (Introduced in
1.4.1.)</td>
</tr>
</tbody>
</table>
<h3 id="cms相关参数">CMS相关参数</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 27%" />
<col style="width: 6%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>参数名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>默认值</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-XX:+UseConcMarkSweepGC</td>
<td>使用CMS内存收集</td>
<td></td>
<td>测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</td>
</tr>
<tr class="even">
<td>-XX:+AggressiveHeap</td>
<td></td>
<td></td>
<td>试图是使用大量的物理内存
长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）
至少需要256MB内存 大量的CPU／内存，
（在1.4.1在4CPU的机器上已经显示有提升）</td>
</tr>
<tr class="odd">
<td>-XX:CMSFullGCsBeforeCompaction</td>
<td>多少次后进行内存压缩</td>
<td></td>
<td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生"碎片",使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td>
</tr>
<tr class="even">
<td>-XX:+CMSParallelRemarkEnabled</td>
<td>降低标记停顿</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>-XX+UseCMSCompactAtFullCollection</td>
<td>在FULL GC的时候， 对年老代的压缩</td>
<td></td>
<td>CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用，
因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。
可能会影响性能,但是可以消除碎片</td>
</tr>
<tr class="even">
<td>-XX:+UseCMSInitiatingOccupancyOnly</td>
<td>使用手动定义初始化定义开始CMS收集</td>
<td></td>
<td>禁止hostspot自行触发CMS GC</td>
</tr>
<tr class="odd">
<td>-XX:CMSInitiatingOccupancyFraction=70</td>
<td>使用cms作为垃圾回收 使用70％后开始CMS收集</td>
<td>92</td>
<td>为了保证不出现promotion
failed(见下面介绍)错误,该值的设置需要满足以下公式<strong>CMSInitiatingOccupancyFraction计算公式</strong></td>
</tr>
<tr class="even">
<td>-XX:CMSInitiatingPermOccupancyFraction</td>
<td>设置Perm Gen使用到达多少比率时触发</td>
<td>92</td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:+CMSIncrementalMode</td>
<td>设置为增量模式</td>
<td></td>
<td>用于单CPU情况</td>
</tr>
<tr class="even">
<td>-XX:+CMSClassUnloadingEnabled</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="辅助信息">辅助信息</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 34%" />
<col style="width: 6%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>参数名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>默认值</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-XX:+PrintGC</td>
<td></td>
<td></td>
<td>输出形式: [GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC
121376K-&gt;10414K(130112K), 0.0650971 secs]</td>
</tr>
<tr class="even">
<td>-XX:+PrintGCDetails</td>
<td></td>
<td></td>
<td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs]
118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew:
8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured:
112761K-&gt;10414K(121024K), 0.0433488 secs]
121376K-&gt;10414K(130112K), 0.0436268 secs]</td>
</tr>
<tr class="odd">
<td>-XX:+PrintGCTimeStamps</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-XX:+PrintGC:PrintGCTimeStamps</td>
<td></td>
<td></td>
<td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用 输出形式:11.851: [GC
98328K-&gt;93620K(130112K), 0.0082960 secs]</td>
</tr>
<tr class="odd">
<td>-XX:+PrintGCApplicationStoppedTime</td>
<td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td>
<td></td>
<td>输出形式:Total time for which application threads were stopped:
0.0468229 seconds</td>
</tr>
<tr class="even">
<td>-XX:+PrintGCApplicationConcurrentTime</td>
<td>打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td>
<td></td>
<td>输出形式:Application time: 0.5291524 seconds</td>
</tr>
<tr class="odd">
<td>-XX:+PrintHeapAtGC</td>
<td>打印GC前后的详细堆栈信息</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-Xloggc:filename</td>
<td>把相关日志信息记录到文件以便分析. 与上面几个配合使用</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:+PrintClassHistogram</td>
<td>garbage collects before printing the histogram.</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-XX:+PrintTLAB</td>
<td>查看TLAB空间的使用情况</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>XX:+PrintTenuringDistribution</td>
<td>查看每次minor GC后新的存活周期的阈值</td>
<td></td>
<td>Desired survivor size 1048576 bytes, new threshold 7 (max 15) new
threshold 7即标识新的存活周期的阈值为7。</td>
</tr>
</tbody>
</table>
<h2 id="主要工具">主要工具</h2>
<h3 id="jdk工具">JDK工具</h3>
<p>JDK自带了很多性能监控工具，我们可以用这些工具来监测系统和排查内存性能问题。</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9a66a5acaf49ac9f65309a778f898c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="JDK自带工具" />
<figcaption aria-hidden="true">JDK自带工具</figcaption>
</figure>
<h3 id="linux-命令行工具">Linux 命令行工具</h3>
<p>进行性能监控和问题排查的时候，常常是结合操作系统本身的命令行工具来进行。</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>top</td>
<td>实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息</td>
</tr>
<tr class="even">
<td>vmstat</td>
<td>对操作系统的虚拟内存、进程、CPU活动进行监控</td>
</tr>
<tr class="odd">
<td>pidstat</td>
<td>监控指定进程的上下文切换</td>
</tr>
<tr class="even">
<td>iostat</td>
<td>监控磁盘IO</td>
</tr>
</tbody>
</table>
<p>其它还有一些第三方的监控工具，同样是性能分析和故障排查的利器，如<strong>MAT</strong>、<strong>GChisto</strong>、<strong>JProfiler</strong>、<strong>arthas</strong>。</p>
<h2 id="常用调优策略">常用调优策略</h2>
<p>这里还是要提一下，及时确定要进行JVM调优，也不要陷入“知见障”，进行分析之后，发现可以通过优化程序提升性能，仍然首选优化程序。</p>
<h3 id="选择合适的垃圾回收器">选择合适的垃圾回收器</h3>
<p>CPU单核，那么毫无疑问Serial 垃圾收集器是你唯一的选择。</p>
<p>CPU多核，关注吞吐量 ，那么选择PS+PO组合。</p>
<p>CPU多核，关注用户停顿时间，JDK版本1.6或者1.7，那么选择CMS。</p>
<p>CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上，那么选择G1。</p>
<p>参数配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Serial垃圾收集器（新生代）</span></span><br><span class="line">开启：-XX:+UseSerialGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line">开启 -XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMS垃圾收集器（老年代）</span></span><br><span class="line">开启 -XX:+UseConcMarkSweepGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置G1垃圾收集器</span></span><br><span class="line">开启 -XX:+UseG1GC</span><br></pre></td></tr></table></figure>
<h3 id="调整内存大小">调整内存大小</h3>
<p>现象：垃圾收集频率非常频繁。</p>
<p>原因：如果内存太小，就会导致频繁的需要进行垃圾收集才能释放出足够的空间来创建新的对象，所以增加堆内存大小的效果是非常显而易见的。</p>
<p>注意：如果垃圾收集次数非常频繁，但是每次能回收的对象非常少，那么这个时候并非内存太小，而可能是内存泄露导致对象无法回收，从而造成频繁GC。</p>
<p>参数配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置堆初始值</span></span><br><span class="line">指令<span class="number">1</span>：-Xms2g</span><br><span class="line">指令<span class="number">2</span>：-XX:InitialHeapSize=2048m</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置堆区最大值</span></span><br><span class="line">指令<span class="number">1</span>：`-Xmx2g` </span><br><span class="line">指令<span class="number">2</span>： -XX:MaxHeapSize=2048m</span><br><span class="line"></span><br><span class="line"><span class="comment">//新生代内存配置</span></span><br><span class="line">指令<span class="number">1</span>：-Xmn512m</span><br><span class="line">指令<span class="number">2</span>：-XX:MaxNewSize=512m</span><br></pre></td></tr></table></figure>
<h3 id="设置符合预期的停顿时间">设置符合预期的停顿时间</h3>
<p>现象：程序间接性的卡顿</p>
<p>原因：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，那么垃圾收集时间就会不稳定。</p>
<p>注意：不要设置不切实际的停顿时间，单次时间越短也意味着需要更多的GC次数才能回收完原有数量的垃圾.</p>
<p>参数配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间</span></span><br><span class="line">-XX:MaxGCPauseMillis </span><br></pre></td></tr></table></figure>
<h3 id="调整内存区域大小比率">调整内存区域大小比率</h3>
<p>现象：某一个区域的GC频繁，其他都正常。</p>
<p>原因：如果对应区域空间不足，导致需要频繁GC来释放空间，在JVM堆内存无法增加的情况下，可以调整对应区域的大小比率。</p>
<p>注意：也许并非空间不足，而是因为内存泄造成内存无法回收。从而导致GC频繁。</p>
<p>参数配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//survivor区和Eden区大小比率</span></span><br><span class="line">指令：-XX:SurvivorRatio=<span class="number">6</span>  <span class="comment">//S区和Eden区占新生代比率为1:6,两个S区2:6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新生代和老年代的占比</span></span><br><span class="line">-XX:NewRatio=<span class="number">4</span>  <span class="comment">//表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2</span></span><br></pre></td></tr></table></figure>
<h3 id="调整对象升老年代的年龄">调整对象升老年代的年龄</h3>
<p>现象：老年代频繁GC，每次回收的对象很多。</p>
<p>原因：如果升代年龄小，新生代的对象很快就进入老年代了，导致老年代对象变多，而这些对象其实在随后的很短时间内就可以回收，这时候可以调整对象的升级代年龄，让对象不那么容易进入老年代解决老年代空间不足频繁GC问题。</p>
<p>注意：增加了年龄之后，这些对象在新生代的时间会变长可能导致新生代的GC频率增加，并且频繁复制这些对象新生的GC时间也可能变长。</p>
<p>配置参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入老年代最小的GC年龄,年轻代对象转换为老年代对象最小年龄值，默认值7</span></span><br><span class="line"> -XX:InitialTenuringThreshol=<span class="number">7</span> </span><br></pre></td></tr></table></figure>
<h3 id="调整大对象的标准">调整大对象的标准</h3>
<p>现象：老年代频繁GC，每次回收的对象很多,而且单个对象的体积都比较大。</p>
<p>原因：如果大量的大对象直接分配到老年代，导致老年代容易被填满而造成频繁GC，可设置对象直接进入老年代的标准。</p>
<p>注意：这些大对象进入新生代后可能会使新生代的GC频率和时间增加。</p>
<p>配置参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。</span></span><br><span class="line"> -XX:PretenureSizeThreshold=<span class="number">1000000</span> </span><br></pre></td></tr></table></figure>
<h3 id="调整gc的触发时机">调整GC的触发时机</h3>
<p>现象：CMS，G1 经常 Full GC，程序卡顿严重。</p>
<p>原因：G1和CMS
部分GC阶段是并发进行的，业务线程和垃圾收集线程一起工作，也就说明垃圾收集的过程中业务线程会生成新的对象，所以在GC的时候需要预留一部分内存空间来容纳新产生的对象，如果这个时候内存空间不足以容纳新产生的对象，那么JVM就会停止并发收集暂停所有业务线程（STW）来保证垃圾收集的正常运行。这个时候可以调整GC触发的时机（比如在老年代占用60%就触发GC），这样就可以预留足够的空间来让业务线程创建的对象有足够的空间分配。</p>
<p>注意：提早触发GC会增加老年代GC的频率。</p>
<p>配置参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用多少比例的老年代后开始CMS收集，默认是68%，如果频繁发生SerialOld卡顿，应该调小</span></span><br><span class="line">-XX:CMSInitiatingOccupancyFraction</span><br><span class="line"></span><br><span class="line"><span class="comment">//G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%</span></span><br><span class="line">-XX:G1MixedGCLiveThresholdPercent=<span class="number">65</span> </span><br></pre></td></tr></table></figure>
<h3 id="调整-jvm本地内存大小">调整 JVM本地内存大小</h3>
<p>现象：GC的次数、时间和回收的对象都正常，堆内存空间充足，但是报OOM</p>
<p>原因：
JVM除了堆内存之外还有一块堆外内存，这片内存也叫本地内存，可是这块内存区域不足了并不会主动触发GC，只有在堆内存区域触发的时候顺带会把本地内存回收了，而一旦本地内存分配不足就会直接报OOM异常。</p>
<p>注意：
本地内存异常的时候除了上面的现象之外，异常信息可能是OutOfMemoryError：Direct
buffer memory。
解决方式除了调整本地内存大小之外，也可以在出现此异常时进行捕获，手动触发GC（System.gc()）。</p>
<p>配置参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XX:MaxDirectMemorySize</span><br></pre></td></tr></table></figure>
<h2 id="jvm调优实例">JVM调优实例</h2>
<p>以下是整理自网络的一些JVM调优实例：</p>
<h3
id="网站流量浏览量暴增后网站反应页面响很慢">网站流量浏览量暴增后，网站反应页面响很慢</h3>
<p>1、问题推测：在测试环境测速度比较快，但是一到生产就变慢，所以推测可能是因为垃圾收集导致的业务线程停顿。</p>
<p>2、定位：为了确认推测的正确性，在线上通过jstat -gc 指令 看到JVM进行GC
次数频率非常高，GC所占用的时间非常长，所以基本推断就是因为GC频率非常高，所以导致业务线程经常停顿，从而造成网页反应很慢。</p>
<p>3、解决方案：因为网页访问量很高，所以对象创建速度非常快，导致堆内存容易填满从而频繁GC，所以这里问题在于新生代内存太小，所以这里可以增加JVM内存就行了，所以初步从原来的2G内存增加到16G内存。</p>
<p>4、第二个问题：增加内存后的确平常的请求比较快了，但是又出现了另外一个问题，就是不定期的会间断性的卡顿，而且单次卡顿的时间要比之前要长很多。</p>
<p>5、问题推测：练习到是之前的优化加大了内存，所以推测可能是因为内存加大了，从而导致单次GC的时间变长从而导致间接性的卡顿。</p>
<p>6、定位：还是通过jstat -gc 指令 查看到
的确FGC次数并不是很高，但是花费在FGC上的时间是非常高的,根据GC日志
查看到单次FGC的时间有达到几十秒的。</p>
<p>7、解决方案：
因为JVM默认使用的是PS+PO的组合，PS+PO垃圾标记和收集阶段都是STW，所以内存加大了之后，需要进行垃圾回收的时间就变长了，所以这里要想避免单次GC时间过长，所以需要更换并发类的收集器，因为当前的JDK版本为1.7，所以最后选择CMS垃圾收集器，根据之前垃圾收集情况设置了一个预期的停顿的时间，上线后网站再也没有了卡顿问题。</p>
<h3 id="后台导出数据引发的oom">后台导出数据引发的OOM</h3>
<p><strong>问题描述：</strong>公司的后台系统，偶发性的引发OOM异常，堆内存溢出。</p>
<p>1、因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，所以单方面的加大了堆内存从4G调整到8G。</p>
<p>2、但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数
获得堆内存的dump文件。</p>
<p>3、VisualVM 对
堆dump文件进行分析，通过VisualVM查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p>
<p>4、通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，发现有个引起我注意的方法，导出订单信息。</p>
<p>5、因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。</p>
<p>6、为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现到处订单的按钮前端居然没有做点击后按钮置灰交互事件，结果按钮可以一直点，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，结果就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p>
<p>7、知道了问题就容易解决了，最终没有调整任何JVM参数，只是在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击，然后减少了查询订单信息的非必要字段来减少生成对象的体积，然后问题就解决了。</p>
<h3
id="单个缓存数据过大导致的系统cpu飚高">单个缓存数据过大导致的系统CPU飚高</h3>
<p>1、系统发布后发现CPU一直飚高到600%，发现这个问题后首先要做的是定位到是哪个应用占用CPU高，通过top
找到了对应的一个java应用占用CPU资源600%。</p>
<p>2、如果是应用的CPU飚高，那么基本上可以定位可能是锁资源竞争，或者是频繁GC造成的。</p>
<p>3、所以准备首先从GC的情况排查，如果GC正常的话再从线程的角度排查，首先使用jstat
-gc PID 指令打印出GC的信息，结果得到得到的GC
统计信息有明显的异常，应用在运行了才几分钟的情况下GC的时间就占用了482秒，那么问这很明显就是频繁GC导致的CPU飚高。</p>
<p>4、定位到了是GC的问题，那么下一步就是找到频繁GC的原因了，所以可以从两方面定位了，可能是哪个地方频繁创建对象，或者就是有内存泄露导致内存回收不掉。</p>
<p>5、根据这个思路决定把堆内存信息dump下来看一下，使用jmap -dump
指令把堆内存信息dump下来（堆内存空间大的慎用这个指令否则容易导致会影响应用，因为我们的堆内存空间才2G所以也就没考虑这个问题了）。</p>
<p>6、把堆内存信息dump下来后，就使用visualVM进行离线分析了，首先从占用内存最多的对象中查找，结果排名第三看到一个业务VO占用堆内存约10%的空间，很明显这个对象是有问题的。</p>
<p>7、通过业务对象找到了对应的业务代码，通过代码的分析找到了一个可疑之处，这个业务对象是查看新闻资讯信息生成的对象，由于想提升查询的效率，所以把新闻资讯保存到了redis缓存里面，每次调用资讯接口都是从缓存里面获取。</p>
<p>8、把新闻保存到redis缓存里面这个方式是没有问题的，有问题的是新闻的50000多条数据都是保存在一个key里面，这样就导致每次调用查询新闻接口都会从redis里面把50000多条数据都拿出来，再做筛选分页拿出10条返回给前端。50000多条数据也就意味着会产生50000多个对象，每个对象280个字节左右，50000个对象就有13.3M，这就意味着只要查看一次新闻信息就会产生至少13.3M的对象，那么并发请求量只要到10，那么每秒钟都会产生133M的对象，而这种大对象会被直接分配到老年代，这样的话一个2G大小的老年代内存，只需要几秒就会塞满，从而触发GC。</p>
<p>9、知道了问题所在后那么就容易解决了，问题是因为单个缓存过大造成的，那么只需要把缓存减小就行了，这里只需要把缓存以页的粒度进行缓存就行了，每个key缓存10条作为返回给前端1页的数据，这样的话每次查询新闻信息只会从缓存拿出10条数据，就避免了此问题的
产生。</p>
<h3 id="cpu经常100-问题定位">CPU经常100% 问题定位</h3>
<p>问题分析：CPU高一定是某个程序长期占用了CPU资源。</p>
<p>1、所以先需要找出那个进行占用CPU高。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top  列出系统各个进程的资源占用情况。</span><br></pre></td></tr></table></figure>
<p>2、然后根据找到对应进行里哪个线程占用CPU高。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp 进程ID   列出对应进程里面的线程占用资源情况</span><br></pre></td></tr></table></figure>
<p>3、找到对应线程ID后，再打印出对应线程的堆栈信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot;  PID    把线程ID转换为16进制。</span><br><span class="line"> jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。</span><br></pre></td></tr></table></figure>
<p>4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看是否有线程长时间的watting 或blocked</span><br><span class="line"> 如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。</span><br></pre></td></tr></table></figure>
<h3 id="内存飚高问题定位">内存飚高问题定位</h3>
<p>分析：
内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。</p>
<p>1、先观察垃圾回收的情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。</span><br><span class="line">  </span><br><span class="line"> jmap -histo PID | head -20   查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。</span><br></pre></td></tr></table></figure>
<p>如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p>
<p>2、导出堆内存文件快照</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=/home/myheapdump.hprof PID  dump堆内存信息到文件。</span><br></pre></td></tr></table></figure>
<p>3、使用visualVM对dump文件进行离线分析,找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p>
<h3 id="数据分析平台系统频繁-full-gc">数据分析平台系统频繁 Full GC</h3>
<p>平台主要对用户在 App 中行为进行定时分析统计，并支持报表导出，使用 CMS
GC 算法。</p>
<p>数据分析师在使用中发现系统页面打开经常卡顿，通过 jstat
命令发现系统每次 Young GC 后大约有 10% 的存活对象进入老年代。</p>
<p>原来是因为 Survivor 区空间设置过小，每次 Young GC 后存活对象在
Survivor 区域放不下，提前进入老年代。</p>
<p>通过调大 Survivor 区，使得 Survivor 区可以容纳 Young GC
后存活对象，对象在 Survivor 区经历多次 Young GC
达到年龄阈值才进入老年代。</p>
<p>调整之后每次 Young GC 后进入老年代的存活对象稳定运行时仅几百 Kb，Full
GC 频率大大降低。</p>
<h3 id="业务对接网关-oom">业务对接网关 OOM</h3>
<p>网关主要消费 Kafka 数据，进行数据处理计算然后转发到另外的 Kafka
队列，系统运行几个小时候出现 OOM，重启系统几个小时之后又 OOM。</p>
<p>通过 jmap 导出堆内存，在 eclipse MAT
工具分析才找出原因：代码中将某个业务 Kafka 的 topic
数据进行日志异步打印，该业务数据量较大，大量对象堆积在内存中等待被打印，导致
OOM。</p>
<h3 id="鉴权系统频繁长时间-full-gc">鉴权系统频繁长时间 Full GC</h3>
<p>系统对外提供各种账号鉴权服务，使用时发现系统经常服务不可用，通过
Zabbix 的监控平台监控发现系统频繁发生长时间 Full
GC，且触发时老年代的堆内存通常并没有占满，发现原来是业务代码中调用了
System.gc()。</p>
<h1 id="cms与g1垃圾回收器的区别">CMS与G1垃圾回收器的区别</h1>
<p>在开始介绍CMS和G1前，我们可以剧透几点：</p>
<ul>
<li>根据不同分代的特点，收集器可能不同。有些收集器可以同时用于新生代和老年代，而有些时候，则需要分别为新生代或老年代选用合适的收集器。一般来说，新生代收集器的收集频率较高，应选用性能高效的收集器；而老年代收集器收集次数相对较少，对空间较为敏感，应当避免选择基于复制算法的收集器。</li>
<li><strong>在垃圾收集执行的时刻，应用程序需要暂停运行</strong>。</li>
<li>可以串行收集，也可以并行收集。</li>
<li>如果能做到并发收集（应用程序不必暂停），那绝对是很妙的事情。</li>
<li>如果收集行为可控，那也是很妙的事情。</li>
</ul>
<p>CMS和G1作为垃圾收集器里的大杀器，是需要好好弄明白的，而且面试中也经常被问到。</p>
<p><strong>希望大家带着下面的问题进行阅读，有目标的阅读，收获更多:</strong></p>
<ol type="1">
<li>为什么没有一种牛逼的收集器像银弹一样适配所有场景？</li>
<li>CMS的优点、缺点、适用场景？</li>
<li>为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？</li>
<li>G1的优点、缺点、适用场景？</li>
</ol>
<h2 id="cms收集器-1">CMS收集器</h2>
<p><strong>CMS（Concurrent Mark
Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器</strong>。这是因为CMS收集器工作时，GC工作线程与用户线程可以<code>并发</code>执行，以此来达到降低收集停顿时间的目的。</p>
<p>CMS收集器仅作用于<strong>老年代</strong>的收集，是基于<code>标记-清除算法</code>的，它的运作过程分为4个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中，<code>初始标记</code>、<code>重新标记</code>这两个步骤仍然需要Stop-the-world。<strong>初始标记仅仅只是标记一下GC
Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots
Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。</strong></p>
<blockquote>
<p>CMS以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。只将那些必需STW才能执行的操作单元单独拎出来，控制这些单元在恰当的时机运行，并能保证仅需短暂的时间就可以完成。这样，在整个收集周期内，只有<strong>两次短暂的暂停（初始标记和重新标记）</strong>，<strong>达到了近似并发的目的</strong>。</p>
</blockquote>
<p>CMS收集器<strong>优点</strong>：并发收集、低停顿。</p>
<p>CMS收集器<strong>缺点</strong>：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感。</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage）。</li>
<li>CMS收集器是基于标记-清除算法，该算法的缺点都有。</li>
</ul>
<p>CMS收集器之所以能够做到并发，根本原因在于<strong>采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解</strong>。前面篇章介绍过标记-清除算法将产生大量的内存碎片这对新生代来说是难以接受的，因此新生代的收集器并未提供CMS版本。</p>
<p>另外要补充一点，JVM在暂停的时候，需要选准一个时机。由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了安全点的概念。</p>
<h3 id="安全点safepoint">安全点(Safepoint)</h3>
<p><strong>安全点，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</strong>。Safepoint的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。</p>
<p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p>
<p>程序运行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的。“<strong>长时间执行</strong>”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<p>对于安全点，另一个需要考虑的问题就是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。</p>
<p>两种解决方案：</p>
<ul>
<li><p>抢先式中断（Preemptive Suspension）</p>
<p>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p></li>
<li><p>主动式中断（Voluntary Suspension）</p>
<p>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p></li>
</ul>
<h3 id="安全区域">安全区域</h3>
<p>指在一段代码片段中，引用关系不会发生变化。在这个区域中任意地方开始GC都是安全的。也可以把Safe
Region看作是被扩展了的Safepoint。</p>
<h2 id="g1收集器-1">G1收集器</h2>
<p>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p>
<p>G1与CMS的特征对比如下：</p>
<table>
<thead>
<tr class="header">
<th>特征</th>
<th>G1</th>
<th>CMS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>并发和分代</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>最大化释放堆内存</td>
<td>是</td>
<td>否</td>
</tr>
<tr class="odd">
<td>低延时</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>吞吐量</td>
<td>高</td>
<td>低</td>
</tr>
<tr class="odd">
<td>压实</td>
<td>是</td>
<td>否</td>
</tr>
<tr class="even">
<td>可预测性</td>
<td>强</td>
<td>弱</td>
</tr>
<tr class="odd">
<td>新生代和老年代的物理隔离</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>G1具备如下特点：</strong></p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过<strong>并发</strong>的方式让Java程序继续运行。</li>
<li>分代收集</li>
<li>空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于<strong>标记-整理算法</strong>实现的收集器，从局部（两个Region之间）上来看是基于“<strong>复制</strong>”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。<strong>这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。</li>
<li>可预测的停顿：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。</li>
</ul>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16ded186e15f5871~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="G1堆的Region布局.png" />
<figcaption aria-hidden="true">G1堆的Region布局.png</figcaption>
</figure>
<p>G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。Region的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的Region，这一点可以参看如下<a
href="https://link.juejin.cn?target=http%3A%2F%2Fhg.openjdk.java.net%2Fjdk%2Fjdk%2Ffile%2Ffa2f93f99dbc%2Fsrc%2Fhotspot%2Fshare%2Fgc%2Fg1%2FheapRegionBounds.hpp">源码</a>。其实这个数字既可以手动调整，G1也会根据堆大小自动进行调整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SHARE_VM_GC_G1_HEAPREGIONBOUNDS_HPP</span><br><span class="line">#define SHARE_VM_GC_G1_HEAPREGIONBOUNDS_HPP</span><br><span class="line"></span><br><span class="line">#include &quot;memory/allocation.hpp&quot;</span><br><span class="line"></span><br><span class="line">class HeapRegionBounds : public AllStatic &#123;</span><br><span class="line">private:</span><br><span class="line">  // Minimum region size; we won&#x27;t go lower than that.</span><br><span class="line">  // We might want to decrease this in the future, to deal with small</span><br><span class="line">  // heaps a bit more efficiently.</span><br><span class="line">  static const size_t MIN_REGION_SIZE = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">  // Maximum region size; we don&#x27;t go higher than that. There&#x27;s a good</span><br><span class="line">  // reason for having an upper bound. We don&#x27;t want regions to get too</span><br><span class="line">  // large, otherwise cleanup&#x27;s effectiveness would decrease as there</span><br><span class="line">  // will be fewer opportunities to find totally empty regions after</span><br><span class="line">  // marking.</span><br><span class="line">  static const size_t MAX_REGION_SIZE = 32 * 1024 * 1024;</span><br><span class="line"></span><br><span class="line">  // The automatic region size calculation will try to have around this</span><br><span class="line">  // many regions in the heap (based on the min heap size).</span><br><span class="line">  static const size_t TARGET_REGION_NUMBER = 2048;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  static inline size_t min_size();</span><br><span class="line">  static inline size_t max_size();</span><br><span class="line">  static inline size_t target_number();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // SHARE_VM_GC_G1_HEAPREGIONBOUNDS_HPP</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</p>
<p>对于打算从CMS或者ParallelOld收集器迁移过来的应用，按照<a
href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Ftech%2Fg1-intro-jsp-135488.html">官方</a>
的建议，如果发现符合如下特征，可以考虑更换成G1收集器以追求更佳性能：</p>
<ul>
<li>实时数据占用了超过半数的堆空间；</li>
<li>对象分配率或“晋升”的速度变化明显；</li>
<li>期望消除耗时较长的GC或停顿（超过0.5——1秒）。</li>
</ul>
<blockquote>
<p>原文如下： Applications running today with either the CMS or the
ParallelOld garbage collector would benefit switching to G1 if the
application has one or more of the following traits.</p>
<ul>
<li>More than 50% of the Java heap is occupied with live data.</li>
<li>The rate of object allocation rate or promotion varies
significantly.</li>
<li>Undesired long garbage collection or compaction pauses (longer than
0.5 to 1 second)</li>
</ul>
</blockquote>
<p><strong>G1收集的运作过程大致如下：</strong></p>
<ul>
<li><strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下GC
Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark
Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，<strong>这阶段需要<code>停顿线程</code>，但耗时很短</strong>。</li>
<li><strong>并发标记（Concurrent Marking）</strong>：是从GC
Roots开始堆中对象进行可达性分析，找出存活的对象，<strong>这阶段耗时较长</strong>，但可与用户程序并发执行。</li>
<li><strong>最终标记（Final
Marking）</strong>：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered
Set Logs里面，最终标记阶段需要把Remembered Set
Logs的数据合并到Remembered
Set中，<strong>这阶段需要<code>停顿线程</code>，但是可并行执行</strong>。</li>
<li><strong>筛选回收（Live Data Counting and
Evacuation）</strong>：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ul>
<p>全局变量和栈中引用的对象是可以列入根集合的，这样在寻找垃圾时，就可以从根集合出发扫描堆空间。在G1中，引入了一种新的能加入根集合的类型，就是<code>记忆集</code>（Remembered
Set）。Remembered
Sets（也叫RSets）用来跟踪对象引用。G1的很多开源都是源自Remembered
Set，例如，它通常约占Heap大小的20%或更高。并且，我们进行对象复制的时候，因为需要扫描和更改Card
Table的信息，这个速度影响了复制的速度，进而影响暂停时间。</p>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16ded186e1757662~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="卡表card-table">卡表（Card Table）</h3>
<p>有个场景，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为GC
Roots。那不是得又做全堆扫描？成本太高了吧。</p>
<p>HotSpot给出的解决方案是一项叫做<code>卡表</code>（Card
Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。</p>
<p>在进行Minor
GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor
GC的GC
Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。</p>
<p>想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。</p>
<p><strong>卡表能用于减少老年代的全堆空间扫描，这能很大的提升GC效率</strong>。</p>
<p>我们可以看下官方文档对G1的展望（这段英文描述比较简单，我就不翻译了）：</p>
<blockquote>
<p>Future: G1 is planned as the long term replacement for the Concurrent
Mark-Sweep Collector (CMS). Comparing G1 with CMS, there are differences
that make G1 a better solution. One difference is that G1 is a
compacting collector. G1 compacts sufficiently to completely avoid the
use of fine-grained free lists for allocation, and instead relies on
regions. This considerably simplifies parts of the collector, and mostly
eliminates potential fragmentation issues. Also, G1 offers more
predictable garbage collection pauses than the CMS collector, and allows
users to specify desired pause targets.</p>
</blockquote>
<h2 id="区别">区别</h2>
<ul>
<li><p>使用范围不一样</p>
<p>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用</p>
<p>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</p></li>
<li><p>STW的时间</p>
<p>CMS收集器是以获取最短回收停顿时间为目标的收集器。</p>
<p>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）</p></li>
<li><p>垃圾碎片</p>
<p>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</p>
<p>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</p></li>
<li><p>垃圾回收的过程不一样</p></li>
</ul>
<h1 id="堆和栈的区别">堆和栈的区别</h1>
<p>在Java中，内存分为两种，一种是栈内存，另一种就是堆内存。</p>
<h2 id="堆内存">堆内存</h2>
<blockquote>
<p><strong>1.什么是堆内存？</strong></p>
</blockquote>
<p>堆内存是是Java内存中的一种，它的作用是用于存储Java中的对象和数组，当我们new一个对象或者创建一个数组的时候，就会在堆内存中开辟一段空间给它，用于存放。</p>
<blockquote>
<p><strong>2.堆内存的特点是什么？</strong></p>
</blockquote>
<p>第一点：堆其实可以类似的看做是管道，或者说是平时去排队买票的的情况差不多，所以堆内存的特点就是：先进先出，后进后出，也就是你先排队，好，你先买票。</p>
<p>第二点：堆可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p>
<blockquote>
<p><strong>3.new对象在堆中如何分配？</strong></p>
</blockquote>
<p>由Java虚拟机的自动垃圾回收器来管理</p>
<h2 id="栈内存">栈内存</h2>
<blockquote>
<p><strong>1.什么是栈内存</strong></p>
</blockquote>
<p>栈内存是Java的另一种内存，主要是用来执行程序用的，比如：基本类型的变量和对象的引用变量</p>
<blockquote>
<p><strong>2.栈内存的特点</strong></p>
</blockquote>
<p>第一点：栈内存就好像一个矿泉水瓶，像里面放入东西，那么先放入的沉入底部，所以它的特点是：先进后出，后进先出</p>
<p>第二点：存取速度比堆要快，仅次于寄存器，栈数据可以共享，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性</p>
<blockquote>
<p><strong>3.栈内存分配机制</strong></p>
</blockquote>
<p>栈内存可以称为一级缓存，由垃圾回收器自动回收</p>
<blockquote>
<p><strong>4.数据共享</strong></p>
</blockquote>
<p>例子：</p>
<p>int a = 3;</p>
<p>int b = 3;</p>
<p>第一步处理：</p>
<ol type="1">
<li><p>编译器先处理int a = 3;</p></li>
<li><p>创建变量a的引用</p></li>
<li><p>在栈中查找是否有3这个值</p></li>
<li><p>没有找到，将3存放，a指向3</p></li>
</ol>
<p>第二步处理：</p>
<ol type="1">
<li><p>处理b=3</p></li>
<li><p>创建变量b的引用</p></li>
<li><p>找到，直接赋值</p></li>
</ol>
<p>第三步改变：</p>
<p>接下来</p>
<p>a = 4；</p>
<p>同上方法</p>
<p>a的值改变，a指向4，b的值是不会发生改变的</p>
<p>PS：如果是两个对象的话，那就不一样了，对象指向的是同一个引用，一个发生改变，另一个也会发生改变</p>
<h2 id="栈和堆的区别">栈和堆的区别</h2>
<p>JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p>
<p>差异</p>
<ol type="1">
<li><p>堆内存用来存放由new创建的对象和数组。</p></li>
<li><p>栈内存用来存放方法或者局部变量等</p></li>
<li><p>堆是先进先出，后进后出</p></li>
<li><p>栈是后进先出，先进后出</p></li>
</ol>
<p>相同</p>
<ol type="1">
<li><p>都是属于Java内存的一种</p></li>
<li><p>系统都会自动去回收它，但是对于堆内存一般开发人员会自动回收它</p></li>
</ol>
<h2 id="新生代和老年代的区别">新生代和老年代的区别</h2>
<p>JVM中的堆一般分为三部分，新生代、老年代和永久代。</p>
<ul>
<li>1 新生代
主要是用来存放新生的对象。一般占据堆空间的1/3，由于频繁创建对象，所以新生代会频繁触发<strong>MinorGC</strong>进行垃圾回收。
新生代分为Eden区、ServivorFrom、ServivorTo三个区。
<ul>
<li>Eden区：Java新对象的出生地(如果新创建的对象占用内存很大则直接分配给老年代)。<strong>当Eden区内存不够的时候就会触发一次MinorGc</strong>，对新生代区进行一次垃圾回收。</li>
<li>ServivorTo：保留了一次MinorGc过程中的幸存者。</li>
<li>ServivorFrom: 上一次GC的幸存者，作为这一次GC的被扫描者。
当JVM无法为新建对象分配内存空间的时候(Eden区满的时候)，JVM触发MinorGc。因此新生代空间占用越低，MinorGc越频繁。
MinorGC采用复制算法。</li>
</ul></li>
<li>2 老年代 老年代的对象比较稳定，所以MajorGC不会频繁执行。</li>
</ul>
<blockquote>
<p>触发MinorGC的条件： 1
在进行MajorGC之前，一般都先进行了一次MinorGC，使得有新生代的对象进入老年代，当老年代空间不足时就会触发MajorGC。
2
当无法找到足够大的连续空间分配给新创建的较大对象时，也会触发MajorGC进行垃圾回收腾出空间。</p>
</blockquote>
<p>MajorGC采用标记—清除算法(或者标记—整理算法)
MajorGC的耗时比较长，因为要先整体扫描再回收，MajorGC会产生内存碎片。为了减少内存损耗，一般需要合并或者标记出来方便下次直接分配。</p>
<p>*<strong>当老年代也满了装不下的时候，就会抛出OOM。*</strong></p>
<ul>
<li>永久代 指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。
Class在被加载的时候元数据信息会放入永久区域，但是GC不会在主程序运行的时候清除永久代的信息。*<strong>所以这也导致永久代的信息会随着类加载的增多而膨胀，最终导致OOM。*</strong></li>
</ul>
<blockquote>
<p>注意:
在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</p>
</blockquote>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：*<strong>元空间并不在虚拟机中，而是使用本地内存。*</strong>因此默认情况下元空间的大小仅仅受本地内存的大小限制。类的元数据放入
native memory, 字符串池和类的静态变量放入java堆中。
这样可以加载多少类的元数据就不再由MaxPermSize控制,
而由系统的实际可用空间来控制。</p>
<ul>
<li>MajorGC和FullGC的区别(*<strong>这里参考1建议不要纠结这两个概念的区别，而是应该专注于解决问题*</strong>)
<ul>
<li>Full GC 是清理整个堆空间—包括年轻代和老年代。</li>
<li>Major GC 是清理老年代。</li>
</ul></li>
<li>MinorGC 触发机制</li>
</ul>
<blockquote>
<p>1 Eden区满的时候，JVM会触发MinorGC。</p>
</blockquote>
<ul>
<li>MajorGC 触发机制</li>
</ul>
<blockquote>
<p>1
在进行MajorGC之前，一般都先进行了一次MinorGC，使得有新生代的对象进入老年代，当老年代空间不足时就会触发MajorGC。
2
当无法找到足够大的连续空间分配给新创建的较大对象时(如大数组)，也会触发MajorGC进行垃圾回收腾出空间。</p>
</blockquote>
<ul>
<li>Full GC触发机制：</li>
</ul>
<blockquote>
<p>1 调用System.gc时，系统建议执行Full GC，但是不必然执行 2
老年代空间不足 3 方法区空间不足 4 通过Minor
GC后进入老年代的平均大小大于老年代的可用内存 5 由Eden区、survivor
space1（From Space）区向survivor space2（To Space）区复制时， 4
当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载。</p>
</blockquote>
<p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden
出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor
容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在
Survivor 区中每熬过一次 Minor GC，年龄就增加 1
岁，　　当它的年龄增加到一定程度（默认为 15
岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数
-XX:MaxTenuringThreshold (阈值)来设置。</p>
<h1 id="简述栈溢出情况">简述栈溢出情况</h1>
<ol type="1">
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。</li>
<li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li>
<li>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</li>
</ol>
<h1 id="对象的生命周期">对象的生命周期</h1>
<p>在Java中，对象的生命周期包括以下几个阶段：</p>
<ol type="1">
<li>创建阶段(Created)</li>
<li>应用阶段(In Use)</li>
<li>不可见阶段(Invisible)</li>
<li>不可达阶段(Unreachable)</li>
<li>收集阶段(Collected)</li>
<li>终结阶段(Finalized)</li>
<li>对象空间重分配阶段(De-allocated)</li>
</ol>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/5408072-cc9009a1e41f3e13?imageMogr2/auto-orient/strip%7CimageView2/2/w/558/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="创建阶段created">创建阶段(Created)</h2>
<p>在创建阶段系统通过下面的几个步骤来完成对象的创建过程</p>
<ul>
<li>为对象分配存储空间</li>
<li>开始构造对象</li>
<li>从超类到子类对static成员进行初始化</li>
<li>超类成员变量按顺序初始化，递归调用超类的构造方法</li>
<li>子类成员变量按顺序初始化，子类构造方法调用</li>
</ul>
<p>一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段</p>
<h2 id="应用阶段in-use">应用阶段(In Use)</h2>
<p>对象至少被一个强引用持有着。</p>
<h2 id="不可见阶段invisible">不可见阶段(Invisible)</h2>
<p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。
简单说就是程序的执行已经超出了该对象的作用域了。
举例如下图：本地变量count在25行时已经超出了其作用域，则在此时称之为count处于不可视阶段。当然这种情况编译器在编译的过程中会直接报错了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boolean has <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (has) &#123;</span><br><span class="line">    int count <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    count <span class="operator">++</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="type">System</span>.out.println(count);</span><br></pre></td></tr></table></figure>
<h2 id="不可达阶段unreachable">不可达阶段(Unreachable)</h2>
<p>对象处于不可达阶段是指该对象不再被任何强引用所持有。
与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC
root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</p>
<h2 id="收集阶段collected">收集阶段(Collected)</h2>
<p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。
这里要特别说明一下：不要重载finazlie()方法！原因有两点：</p>
<h3
id="会影响jvm的对象分配与回收速度">会影响JVM的对象分配与回收速度</h3>
<p>在分配该对象时，JVM需要在垃圾回收器上注册该对象，以便在回收时能够执行该重载方法；在该方法的执行时需要消耗CPU时间且在执行完该方法后才会重新执行回收操作，即至少需要垃圾回收器对该对象执行两次GC。</p>
<h3 id="可能造成该对象的再次复活">可能造成该对象的再次“复活”</h3>
<p>在finalize()方法中，如果有其它的强引用再次持有该对象，则会导致对象的状态由“收集阶段”又重新变为“应用阶段”。这个已经破坏了Java对象的生命周期进程，且“复活”的对象不利用后续的代码管理。</p>
<h2 id="终结阶段">终结阶段</h2>
<p>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
<h2 id="对象空间重新分配阶段">对象空间重新分配阶段</h2>
<p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8FJava%E5%AE%B9%E5%99%A8/" rel="prev" title="Java容器">
      <i class="fa fa-chevron-left"></i> Java容器
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8FLinux/" rel="next" title="Linux">
      Linux <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bjava%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%B9%B6%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%AF%8F%E4%B8%AA%E9%83%A8%E5%88%86%E9%83%BD%E5%AD%98%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">介绍一下Java运行时数据区域，并说一下每个部分都存哪些内容？（JVM内存模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.2.</span> <span class="nav-text">java虚拟机栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E5%A0%86"><span class="nav-number">1.4.</span> <span class="nav-text">java堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE1%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%B8%BA%E7%A9%BA%E5%90%97"><span class="nav-number">1.6.</span> <span class="nav-text">追问1：程序计数器可以为空吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE2%E5%A0%86%E4%B8%AD%E5%8F%88%E6%80%8E%E4%B9%88%E7%BB%86%E5%88%86%E7%9A%84"><span class="nav-number">1.7.</span> <span class="nav-text">追问2：堆中又怎么细分的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE3%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E4%BC%9A%E9%80%A0%E6%88%90oom"><span class="nav-number">1.8.</span> <span class="nav-text">追问3：哪些区域会造成OOM</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jdk1.7%E5%92%8C1.8-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">JDK1.7和1.8 内存模型的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm"><span class="nav-number">3.</span> <span class="nav-text">Java内存模型（JMM）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">4.</span> <span class="nav-text">Java中对象的创建过程是什么样的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">4.1.</span> <span class="nav-text">追问1：内存分配的策略有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE2%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B"><span class="nav-number">4.2.</span> <span class="nav-text">追问2：对象头包含哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE3%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%E6%9C%89%E5%87%A0%E7%A7%8D%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">追问3：对象的访问定位方法有几种，各有什么优缺点？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5"><span class="nav-number">5.</span> <span class="nav-text">堆内存中对象分配的基本策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB"><span class="nav-number">6.</span> <span class="nav-text">如何判断对象已死？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE1gcroot%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%93%AA%E4%BA%9B"><span class="nav-number">6.1.</span> <span class="nav-text">追问1：GCroot可以是哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE2%E8%A2%AB%E6%A0%87%E5%BF%97%E4%B8%BAgc%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%ABgc%E6%8E%89%E5%90%97"><span class="nav-number">6.2.</span> <span class="nav-text">追问2：被标志为GC的对象一定会被GC掉吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">双亲委派的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">JVM垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95mark-sweep"><span class="nav-number">9.1.</span> <span class="nav-text">标记—清除算法（Mark-Sweep）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95copy"><span class="nav-number">9.2.</span> <span class="nav-text">复制算法（Copy）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95mark-compact"><span class="nav-number">9.3.</span> <span class="nav-text">标记—整理算法（Mark-Compact）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="nav-number">9.4.</span> <span class="nav-text">分代收集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">10.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">10.1.</span> <span class="nav-text">类文件到虚拟机(类加载机制):</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BDloading"><span class="nav-number">10.1.1.</span> <span class="nav-text">加载(loading)：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5link"><span class="nav-number">10.1.2.</span> <span class="nav-text">链接(link)：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96initialize"><span class="nav-number">10.1.3.</span> <span class="nav-text">初始化(initialize)：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">11.</span> <span class="nav-text">Jvm垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parnew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parallel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.3.</span> <span class="nav-text">Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serial-old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.4.</span> <span class="nav-text">Serial Old收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parallel-old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.5.</span> <span class="nav-text">Parallel Old收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cms%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.6.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#g1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.7.</span> <span class="nav-text">G1收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84zgc"><span class="nav-number">11.8.</span> <span class="nav-text">令人惊叹的ZGC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%91%E7%94%9Fgc"><span class="nav-number">12.</span> <span class="nav-text">什么情况下发生GC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">13.</span> <span class="nav-text">整体介绍垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#gc%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="nav-number">13.1.</span> <span class="nav-text">GC的主要任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-number">13.2.</span> <span class="nav-text">垃圾回收机制的主要解决问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E6%9D%A5%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%B5%81%E7%A8%8B"><span class="nav-number">13.3.</span> <span class="nav-text">最后来讲一下流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-number">14.</span> <span class="nav-text">可达性分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gc-root%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">15.</span> <span class="nav-text">GC Root有哪几种</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84oom%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="nav-number">16.</span> <span class="nav-text">遇到的OOM问题，如何定位、排查与解决</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#section"><span class="nav-number">16.1.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#oom%E4%B8%80%E8%88%AC%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">16.2.</span> <span class="nav-text">OOM一般有以下两种情况：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%AE%9E%E4%BE%8B"><span class="nav-number">17.</span> <span class="nav-text">Jvm调优参数与实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E8%B0%83%E4%BC%98%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">17.1.</span> <span class="nav-text">JVM调优的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E8%B0%83%E4%BC%98%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">17.2.</span> <span class="nav-text">JVM调优的目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E8%B0%83%E4%BC%98%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">17.3.</span> <span class="nav-text">JVM调优的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E5%8F%82%E6%95%B0"><span class="nav-number">17.4.</span> <span class="nav-text">JVM参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0"><span class="nav-number">17.4.1.</span> <span class="nav-text">基本参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="nav-number">17.4.2.</span> <span class="nav-text">并行收集器相关参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cms%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="nav-number">17.4.3.</span> <span class="nav-text">CMS相关参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E4%BF%A1%E6%81%AF"><span class="nav-number">17.4.4.</span> <span class="nav-text">辅助信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%B7%A5%E5%85%B7"><span class="nav-number">17.5.</span> <span class="nav-text">主要工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk%E5%B7%A5%E5%85%B7"><span class="nav-number">17.5.1.</span> <span class="nav-text">JDK工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="nav-number">17.5.2.</span> <span class="nav-text">Linux 命令行工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="nav-number">17.6.</span> <span class="nav-text">常用调优策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">17.6.1.</span> <span class="nav-text">选择合适的垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">17.6.2.</span> <span class="nav-text">调整内存大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%AC%A6%E5%90%88%E9%A2%84%E6%9C%9F%E7%9A%84%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4"><span class="nav-number">17.6.3.</span> <span class="nav-text">设置符合预期的停顿时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%A4%A7%E5%B0%8F%E6%AF%94%E7%8E%87"><span class="nav-number">17.6.4.</span> <span class="nav-text">调整内存区域大小比率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%AF%B9%E8%B1%A1%E5%8D%87%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%B9%B4%E9%BE%84"><span class="nav-number">17.6.5.</span> <span class="nav-text">调整对象升老年代的年龄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%87%E5%87%86"><span class="nav-number">17.6.6.</span> <span class="nav-text">调整大对象的标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4gc%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">17.6.7.</span> <span class="nav-text">调整GC的触发时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4-jvm%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">17.6.8.</span> <span class="nav-text">调整 JVM本地内存大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E4%BE%8B"><span class="nav-number">17.7.</span> <span class="nav-text">JVM调优实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E6%B5%8F%E8%A7%88%E9%87%8F%E6%9A%B4%E5%A2%9E%E5%90%8E%E7%BD%91%E7%AB%99%E5%8F%8D%E5%BA%94%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BE%88%E6%85%A2"><span class="nav-number">17.7.1.</span> <span class="nav-text">网站流量浏览量暴增后，网站反应页面响很慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BC%95%E5%8F%91%E7%9A%84oom"><span class="nav-number">17.7.2.</span> <span class="nav-text">后台导出数据引发的OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%87%B4%E7%9A%84%E7%B3%BB%E7%BB%9Fcpu%E9%A3%9A%E9%AB%98"><span class="nav-number">17.7.3.</span> <span class="nav-text">单个缓存数据过大导致的系统CPU飚高</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E7%BB%8F%E5%B8%B8100-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D"><span class="nav-number">17.7.4.</span> <span class="nav-text">CPU经常100% 问题定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%A3%9A%E9%AB%98%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D"><span class="nav-number">17.7.5.</span> <span class="nav-text">内存飚高问题定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%E7%B3%BB%E7%BB%9F%E9%A2%91%E7%B9%81-full-gc"><span class="nav-number">17.7.6.</span> <span class="nav-text">数据分析平台系统频繁 Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E5%AF%B9%E6%8E%A5%E7%BD%91%E5%85%B3-oom"><span class="nav-number">17.7.7.</span> <span class="nav-text">业务对接网关 OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%89%B4%E6%9D%83%E7%B3%BB%E7%BB%9F%E9%A2%91%E7%B9%81%E9%95%BF%E6%97%B6%E9%97%B4-full-gc"><span class="nav-number">17.7.8.</span> <span class="nav-text">鉴权系统频繁长时间 Full GC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cms%E4%B8%8Eg1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">CMS与G1垃圾回收器的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cms%E6%94%B6%E9%9B%86%E5%99%A8-1"><span class="nav-number">18.1.</span> <span class="nav-text">CMS收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9safepoint"><span class="nav-number">18.1.1.</span> <span class="nav-text">安全点(Safepoint)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">18.1.2.</span> <span class="nav-text">安全区域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#g1%E6%94%B6%E9%9B%86%E5%99%A8-1"><span class="nav-number">18.2.</span> <span class="nav-text">G1收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%A1%E8%A1%A8card-table"><span class="nav-number">18.2.1.</span> <span class="nav-text">卡表（Card Table）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">18.3.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">堆和栈的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">19.1.</span> <span class="nav-text">堆内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98"><span class="nav-number">19.2.</span> <span class="nav-text">栈内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.3.</span> <span class="nav-text">栈和堆的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.4.</span> <span class="nav-text">新生代和老年代的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E6%A0%88%E6%BA%A2%E5%87%BA%E6%83%85%E5%86%B5"><span class="nav-number">20.</span> <span class="nav-text">简述栈溢出情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">21.</span> <span class="nav-text">对象的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%98%B6%E6%AE%B5created"><span class="nav-number">21.1.</span> <span class="nav-text">创建阶段(Created)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5in-use"><span class="nav-number">21.2.</span> <span class="nav-text">应用阶段(In Use)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E8%A7%81%E9%98%B6%E6%AE%B5invisible"><span class="nav-number">21.3.</span> <span class="nav-text">不可见阶段(Invisible)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E8%BE%BE%E9%98%B6%E6%AE%B5unreachable"><span class="nav-number">21.4.</span> <span class="nav-text">不可达阶段(Unreachable)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E9%98%B6%E6%AE%B5collected"><span class="nav-number">21.5.</span> <span class="nav-text">收集阶段(Collected)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E5%BD%B1%E5%93%8Djvm%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E9%80%9F%E5%BA%A6"><span class="nav-number">21.5.1.</span> <span class="nav-text">会影响JVM的对象分配与回收速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%8D%E6%AC%A1%E5%A4%8D%E6%B4%BB"><span class="nav-number">21.5.2.</span> <span class="nav-text">可能造成该对象的再次“复活”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E7%BB%93%E9%98%B6%E6%AE%B5"><span class="nav-number">21.6.</span> <span class="nav-text">终结阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E9%98%B6%E6%AE%B5"><span class="nav-number">21.7.</span> <span class="nav-text">对象空间重新分配阶段</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

