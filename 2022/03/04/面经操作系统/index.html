<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="再不见风样的少年格子衬衫一角扬起，从此寂寞了的白塔后山今夜悄悄落雨">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="再不见风样的少年格子衬衫一角扬起，从此寂寞了的白塔后山今夜悄悄落雨">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.468Z">
<meta property="article:modified_time" content="2022-03-28T08:56:29.981Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-28 16:56:29" itemprop="dateModified" datetime="2022-03-28T16:56:29+08:00">2022-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">再不见风样的少年格子衬衫一角扬起，从此寂寞了的白塔后山今夜悄悄落雨</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="系统调用-用户态和内核态">系统调用 / 用户态和内核态</h1>
<p>据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ul>
<li><strong>用户态(user mode)</strong> :
用户态运行的进程可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel
mode)</strong>:可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ul>
<h1 id="什么是系统调用">什么是系统调用</h1>
<ul>
<li>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了。</li>
<li>也就是说在我们<strong>运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</strong></li>
</ul>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li><strong>设备管理</strong>。完成设备的请求或释放，以及设备启动等功能。</li>
<li><strong>文件管理</strong>。完成文件的读、写、创建及删除等功能。</li>
<li><strong>进程控制</strong>。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li><strong>进程通信</strong>。完成进程之间的消息传递或信号传递等功能。</li>
<li><strong>内存管理</strong>。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h1 id="如何从用户态切换到内核态">如何从用户态切换到内核态</h1>
<ul>
<li><strong>系统调用</strong>
这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如
read 操作，比如前例中 fork()
实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int
80h中断。</li>
<li><strong>异常</strong>
当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>
<li><strong>外围设备的中断</strong>
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
</ul>
<p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>
<h1 id="其他必会知识">其他必会知识</h1>
<ul>
<li><strong>并行与并发</strong>
<strong>并发</strong>：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。
<strong>并行</strong>：两个程序在某一时刻同时运行，强调同时发生。</li>
<li><strong>阻塞与非阻塞</strong>
阻塞是指调用线程或者进程被操作系统挂起。
非阻塞是指调用线程或者进程不会被操作系统挂起。</li>
<li><strong>同步与异步</strong>
同步与异步同步是阻塞模式，异步是非阻塞模式。
同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；
异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。</li>
</ul>
<h1 id="线程进程协程的区别">线程、进程、协程的区别</h1>
<ul>
<li><strong>进程是资源分配的最基本的单位</strong>，运行一个程序会创建一个或多个进程，进程就是运行起来的可执行程序。</li>
<li><strong>线程是程序执行的最基本的单位</strong>，是轻量级的进程，每个进程里都有一个主线程，且只能有一个，和进程是相互依存的关系，生命周期和进程一样。</li>
<li><strong>协程是用户态的轻量级线程</strong>，是线程内部的基本单位。无需线程上下文切换的开销、无需原子操作锁定及同步的开销、方便切换控制流，简化编程模型。</li>
</ul>
<h2 id="进程和线程的区别">进程和线程的区别</h2>
<ul>
<li>首先从<code>资源</code>来说，<strong>进程是资源分配的基本单位</strong>，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
<li>然后从<code>调度</code>来说，<strong>线程是独立调度的基本单位</strong>，在同一进程中线程切换的话不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程的切换。</li>
<li>从<code>系统开销</code>来讲，由于创建或撤销进程，系统都要分配回收资源，所付出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换的时候，涉及当前执行进程
CPU 环境的保存及新调度进程 CPU
环境设置，而线程切换只需保存和设置少量寄存器的内容，开销很小。</li>
<li><code>通信</code>方面来说，线程间可以通过直接读写同一进程的数据进行通信，但是进程通信需要借助一些复杂的方法。</li>
</ul>
<h1 id="pcb进程管理块是什么">PCB（进程管理块）是什么？</h1>
<ul>
<li>PCB主要包含下面几部分的内容：
<ul>
<li><strong>进程的描述信息</strong>，比如进程的名称，标识符，</li>
<li><strong>处理机的状态信息</strong>，当程序中断时保留此时的信息，以便
CPU 返回时能从断点执行</li>
<li><strong>进程调度信息</strong>，比如阻塞原因，状态，优先级等等</li>
<li><strong>进程控制和资源占用</strong>，同步通信机制，链接指针（指向队列中下一个进程的
PCB 地址）</li>
</ul></li>
<li><strong>PCB 的作用</strong>
<ul>
<li>PCB是进程实体的一部分，是操作系统中最重要的数据结构</li>
<li>由于它的存在，使得多道程序环境下，不能独立运行的程序成为一个能独立运行的基本单位，使得程序可以并发执行</li>
<li>系统通过 PCB 来感知进程的存在。（换句话说，PCB
是进程存在的唯一标识）</li>
<li>进程的组成可以用下图来表示，PCB 就是唯一标识符。</li>
</ul></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7gSMUf"><img
src="https://s4.ax1x.com/2022/01/20/7gSMUf.png"
alt="7gSMUf.png" /></a></p>
<h1 id="进程的五种状态">进程的五种状态</h1>
<p>面试在答的时候这么答：有<strong>创建状态、就绪状态、运行状态、阻塞状态、结束状态</strong>。</p>
<ul>
<li>其中只有就绪状态和运行状态能互相转化，当进程为就绪态时，等待 CPU
分配时间片，得到时间片后就进入 运行状态。</li>
<li>运行状态在使用完 CPU 时间片后，又重回就绪态。</li>
<li>阻塞状态是进程在运行状态时，需要等待某个资源比如打印机资源，而进入一个挂起的状态，等资源拿到后会回到就绪状态，等待
CPU 时间片。</li>
</ul>
<h1 id="进程调度算法">进程调度算法</h1>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h2 id="批处理系统">批处理系统</h2>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<ol type="1">
<li><strong>先来先服务 first-come first-serverd（FCFS）</strong></li>
</ol>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<ol start="2" type="1">
<li><strong>短作业优先 shortest job first（SJF）</strong></li>
</ol>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<ol start="3" type="1">
<li><strong>最短剩余时间优先 shortest remaining time
next（SRTN）</strong></li>
</ol>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。
当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h2 id="交互式系统">交互式系统</h2>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<ol type="1">
<li><strong>时间片轮转</strong></li>
</ol>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU
时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把
CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<figure>
<img
src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="2" type="1">
<li><strong>优先级调度</strong></li>
</ol>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<ol start="3" type="1">
<li><strong>多级反馈队列</strong></li>
</ol>
<p>一个进程需要执行 100
个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如
1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换
7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<figure>
<img
src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="实时系统">实时系统</h2>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为<strong>硬实时</strong>和<strong>软实时</strong>，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h1 id="进程同步的方式">进程同步的方式</h1>
<ol type="1">
<li><p><strong>信号量</strong></p>
<p>用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，P操作和V操作，这三种操作都是原子操作。</p>
<p>P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。</p>
<p><strong>基本原理</strong>是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。</p>
<p>为通过信号量s传送信号，进程可执行原语semSignal(s);为通过信号量s接收信号，进程可执行原语semWait(s);如果相应的信号仍然没有发送，则进程被阻塞，直到发送完为止。</p>
<p>可把信号量视为一个具有整数值的变量，在它之上定义三个操作：</p>
<ul>
<li><strong>一个信号量可以初始化为非负数</strong></li>
<li><strong>semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。</strong></li>
<li><strong>semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞。</strong></li>
</ul></li>
<li><p><strong>管程</strong></p>
<p><strong>管程</strong>是由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：</p>
<ul>
<li><strong>局部数据变量只能被管程的过程访问，任何外部过程都不能访问。</strong></li>
<li><strong>一个进程通过调用管程的一个过程进入管程。</strong></li>
<li><strong>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。</strong></li>
</ul>
<p>管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问。有两个函数可以操作条件变量：</p>
<ul>
<li>cwait(c)：调用进程的执行在条件c上阻塞，管程现在可被另一个进程使用。</li>
<li>csignal(c)：恢复执行在cwait之后因为某些条件而阻塞的进程。如果有多个这样的进程，选择其中一个；如果没有这样的进程，什么以不做。</li>
</ul></li>
<li><p><strong>消息传递</strong></p>
<p><strong>消息传递</strong>的实际功能以一对原语的形式提供：</p>
<ul>
<li>send(destination,message)</li>
<li>receive(source,message)</li>
</ul>
<p>这是进程间进程消息传递所需要的最小操作集。</p>
<p>一个进程以消息的形式给另一个指定的目标进程发送消息；</p>
<p>进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</p></li>
</ol>
<h1 id="进程间通信的方式">进程间通信的方式</h1>
<h2 id="常见的通信方式">常见的通信方式：</h2>
<ol type="1">
<li><strong>管道pipe</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li><strong>命名管道FIFO</strong>：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li><strong>消息队列MessageQueue</strong>：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li><strong>共享内存SharedMemory</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的
IPC
方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li><strong>信号量Semaphore</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>套接字Socket</strong>：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li>
<li><strong>信号 ( sinal )</strong> ：
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ol>
<h2 id="管道">管道</h2>
<p>管道可以分为两类：<strong>匿名管道</strong>和<strong>命名管道</strong>。</p>
<p>常见的Linux命令 "|"
其实就是匿名管道，表示把一个进程的输出传输到另外一个进程，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Happyjava&quot;</span> | awk -F <span class="string">&#x27;j&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 输出 ava</span></span><br></pre></td></tr></table></figure>
<p>另外，我们可以通过 mkfifo <pipename> 命令创建一个命名管道，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo pipe</span><br></pre></td></tr></table></figure>
<p>一个进程往管道输入数据，则会阻塞等待别的进程从管道读取数据：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7gEWdJ"><img
src="https://s4.ax1x.com/2022/01/20/7gEWdJ.md.png"
alt="7gEWdJ.md.png" /></a></p>
<p>如果我另外一个窗口没有执行 cat &lt; pipe 命令，则左边的窗口（echo
'Happyjava' &gt; pipe）会一直阻塞。</p>
<h2 id="消息队列">消息队列</h2>
<p>注意，此消息队列不是我们常用的MQ，如kafka，rabbitmq，rocketmq等。</p>
<p><strong>消息队列</strong>提供了一种从一个进程向另一个进程发送一个数据块的方法。
每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>
<p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p>
<h2 id="共享内存">共享内存</h2>
<p><strong>共享内存</strong>这个通信方式就可以很好着解决拷贝所消耗的时间了。系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
<h2 id="信号量">信号量</h2>
<p>共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的<strong>线程安全</strong>问题。如何解决这个问题？这个时候我们的<strong>信号量</strong>就上场了。</p>
<p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是
1，然后 a 进程来访问<strong>内存1</strong>的时候，我们就把信号量的值设为
0，然后进程b 也要来访问<strong>内存1</strong>的时候，看到信号量的值为 0
就知道已经有进程在访问<strong>内存1</strong>了，这个时候进程 b
就会访问不了<strong>内存1</strong>。所以说，信号量也是进程之间的一种通信方式。</p>
<h2 id="socket">Socket</h2>
<p>这个就是我们一直在用的进程间的通信方式了，如我们的微信APP跟微信服务器通信，其实就是使用的Socket套接字进行通信的。</p>
<h1 id="生产者消费者模型">生产者消费者模型</h1>
<p>生产者和消费者模型，期间就需要线程之间进行通信来实现互斥和同步。</p>
<p>需求是这样的：</p>
<ul>
<li>生产者每生成一个产品，就消耗一个缓冲区，只有当缓冲区不满的时候才能放入；</li>
<li>消费者每消费一个产品，就消耗一个产品，只有当缓冲区不空的时候才能消费。</li>
</ul>
<p>做法：</p>
<ul>
<li>因为缓冲区是临界资源，所以需要定义一个互斥信号量，为 mutex
来实现两者对临界资源的互斥访问。</li>
<li>为了同步生产者和消费者的操作，需要记录缓冲区的剩余大小 empty 和
产品的个数 full。当缓冲区大小不为 0
时，生产者才能放入产品；当产品个数不为 0 时，消费者才能拿走产品。</li>
<li>注意！不可对临界区先加锁，设想这样一个情况：当 empty = 0
时，生产者此时先对临界区加锁，然后发现缓冲区的数量为
0，则开始进入阻塞等待消费者消费的状态，而此时一个消费者开始进入消耗一个产品，但发现临界区被加锁，所以生产者在等待消费者消费产品，而消费者在等待生产者释放临界区锁，进入了一个死锁状态。</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mutex = <span class="number">1</span>;</span><br><span class="line">empty = N;</span><br><span class="line">full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Producer</span><span class="params">()</span> &#123;</span><br><span class="line">    P(empty); <span class="comment">// 生产者生产一个产品，消耗一个缓冲区 </span></span><br><span class="line">    P(mutex);</span><br><span class="line">    ....      <span class="comment">// 临界区</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(full); <span class="comment">// 产品数量加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    P(full); <span class="comment">// 消费者消耗一个产品，释放一个缓冲区</span></span><br><span class="line">    P(mutex); <span class="comment">// 临界区上锁</span></span><br><span class="line">    ....</span><br><span class="line">    V(mutex); <span class="comment">// 临界区锁释放</span></span><br><span class="line">    V(empty); <span class="comment">// 增加一个缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">P</span><span class="params">(S)</span>&#123;</span><br><span class="line">    S--;</span><br><span class="line">    <span class="keyword">if</span>(S &lt; <span class="number">0</span>) block();  <span class="comment">// 如果小于0，代表资源没了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">V</span><span class="params">(S)</span>&#123;</span><br><span class="line">    S++;</span><br><span class="line">    <span class="keyword">if</span>(S &lt;= <span class="number">0</span>) wakeUp(); <span class="comment">// 如果小于等于0，代表有进程仍然在等待，通知他们ok了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="手写生产者消费者模型">手写生产者消费者模型</h1>
<h2 id="可重入锁reentrantlock-方式">可重入锁ReentrantLock 方式</h2>
<h4 id="可重入锁概念">可重入锁概念：</h4>
<p>ReentrantLock类实现Lock接口，并在方法访问共享资源时为其提供同步。操作共享资源的代码会锁定当前工作线程并阻止尝试锁定共享资源的所有其他线程。</p>
<p>顾名思义，ReentrantLock允许线程不止一次地锁定资源。当线程首次进入锁定状态时，保持计数(hold
count)设置为1。解锁之前，线程可以再次重新进入锁定状态，并且将计数增加1。
对于每个解锁请求，保持计数减1，当保持计数为0时，资源解锁。
可重入锁还提供公平参数，可以实现所谓公平锁和非公平锁。</p>
<ol type="1">
<li>公平锁能：新老线程一律需要排队使用锁。</li>
<li>非公平锁：老的线程排队使用锁；但是无法保证新线程抢占已经在排队的线程的锁。</li>
</ol>
<p>ReentrantLock 可重入锁的方式，需要配合Condition使用，Condition
与Lock的主要区别在于是否能够响应中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndConsumerByLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProducerAndConsumerByLock</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerAndConsumerByLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    while (getCount() == maxNum) &#123;</span></span><br><span class="line"><span class="comment">//                        producerCondition.await();</span></span><br><span class="line"><span class="comment">//                        System.out.println(&quot;生产能力达到上限，进入等待状态&quot;);</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class="line">                    <span class="comment">//唤醒消费者</span></span><br><span class="line">                    consumerCondition.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//获取锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">700</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    while (count == 0) &#123;</span></span><br><span class="line"><span class="comment">//                        consumerCondition.await();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"></span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class="line">                    <span class="comment">//唤醒生产者</span></span><br><span class="line">                    producerCondition.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不少人使用注释掉的while 语句来判断当前生成者产能是否已满。
不过这种while循环本身也属于一个独立线程，会有冲突的可能，放在演示代码里，输出顺序可能会混乱。</p>
<h1 id="死锁发生的条件是什么">死锁发生的条件是什么？</h1>
<ol type="1">
<li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程--资源的环形链。</li>
</ol>
<h1 id="页面置换算法">页面置换算法</h1>
<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其<strong>移出</strong>内存，以便为即将调入的页面让出空间。而用来<strong>选择淘汰</strong>哪一页的规则叫做<strong>页面置换算法</strong>。</p>
<h2 id="最佳置换算法optoptimal">最佳置换算法（OPT，Optimal）</h2>
<p>算法思想：每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。
举例说明，假设系统为进程分配了三个内存块，并考虑到有以下页面号引用串（会依次访问这些页面）：7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1</p>
<blockquote>
<p>第一个访问的是7号页，内存中没有此页，由缺页中断机构将7号页调入内存。此时有三个可用的内存块，不需要置换。即第一次(7)
：7</p>
</blockquote>
<blockquote>
<p>同理，第二个访问的是0号页，和第一次一样，第三次访问的是1号页，同样1号页也会被调入内存，1号内被调入内存后，此时分配给该进程内存空间已占满。
第二次(0)：7 0 第三次(1)：7 0 1</p>
</blockquote>
<blockquote>
<p>第四个访问的页是2号页，此时内存已经用完，需要将一个页调出内存，根据最佳置换算法，淘汰一个以后永不使用或最长时间不使用的，此时内存中的页有7、0、1，查看待访问页号序列中这三个页号的先后位置，下图可以看到，0号页和1号页在不久又会被访问到，而7号页需要被访问的时间最久。所以该算法会淘汰7号页。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7gKulR"><img
src="https://s4.ax1x.com/2022/01/20/7gKulR.md.png"
alt="7gKulR.md.png" /></a></p>
<blockquote>
<p>第一次(7) ：7 第二次(0)：7 0 第三次(1)：7 0 1 第四次(2)：0 1 2</p>
</blockquote>
<p>....按照此算法依次执行，最后的结果如下</p>
<blockquote>
<p>第一次(7) ：7 第二次(0)：7 0 第三次(1)：7 0 1 第四次(2)：0 1 2
第五次(0)：0 1 2（命中） 第六次(3) ：0 3 1 第七次(0) ：0 3 1（命中）
第八次(4) ：3 2 4 第九次(2) ：3 2 4（命中） 第十次(3) ：3 2 4（命中）
第十一次(0) ：3 2 0 第十二次(3) ：3 2 0（命中） .....</p>
</blockquote>
<p>结果图</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7gKsAS"><img
src="https://s4.ax1x.com/2022/01/20/7gKsAS.md.png"
alt="7gKsAS.md.png" /></a></p>
<blockquote>
<p>整个过程缺页中断发生了9次，页面置换发生了6次。缺页率 = 9 / 20 =
45%。</p>
</blockquote>
<p>注：缺页时未必发生页面置换，若还有可用的空闲内存空间就不用进行页面置换。</p>
<p>最佳置换算法可以保证最低的缺页率，但是实际上，只有进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面的访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</p>
<h2 id="先进先出置换算法fifo">先进先出置换算法（FIFO）</h2>
<p>算法思想：每次选择<strong>淘汰的页面是最早进入内存的页面。</strong></p>
<p>该算法很简单，每次淘汰最在内存中待时间最久的各个，下面分别给出系统为进程分为配三个内存块和四个内存块的执行情况图。访问序列为3,2,1,0,3,2,4,3,2,1,0,4</p>
<p>分配三个内存块的情况：</p>
<blockquote>
<p>第一次(3) ：3 第二次(2) ：3 2 第三次(1) ：3 2 1 第四次(0) ：2 1 0
第五次(3) ：1 0 3 第六次(2) ：0 3 2 第七次(4) ：3 2 4 第八次(3) ：3 2
4（命中） 第九次(2) ：3 2 4（命中） 第十次(1) ：2 4 1 第十一次(0) ：4 1
0 第十二次(4) ：4 1 0（命中）</p>
</blockquote>
<blockquote>
<p>分配三个内存块时，缺页次数：<strong>9</strong>次。</p>
</blockquote>
<p>分配四个内存块的情况：</p>
<blockquote>
<p>第一次(3) ：3 第二次(2) ：3 2 第三次(1) ：3 2 1 第四次(0) ：3 2 1 0
第五次(3) ：3 2 1 0（命中） 第六次(2) ：3 2 1 0 （命中） 第七次(4) ：2 1
0 4 第八次(3) ：1 0 4 3 第九次(2) ：0 4 3 2 第十次(1) ：4 3 2 1
第十一次(0) ：3 2 1 0 第十二次(4) ：2 1 0 4</p>
</blockquote>
<blockquote>
<p>分配四个内存块时，缺页次数：<strong>10</strong>次。</p>
</blockquote>
<p>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象称为<strong>贝莱迪（Belay）异常</strong>。</p>
<p><strong>只有FIFO算法会产生Belay异常。</strong>另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应。因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差。</strong></p>
<h2
id="最近最久未使用置换算法lruleast-recently-used">最近最久未使用置换算法（LRU，Least
Recently Used）</h2>
<p>算法思想：<strong>每次淘汰的页面是最近最久未使用的页面。</strong></p>
<p>实现方法：赋予每个页面对应的页表项中，用<strong>访问字段记录该页面自上次被访问以来所经历的时间t。</strong>当需要淘汰一个页面时，选择现有页面中t最大的页面，即最近最久未使用。</p>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/18464438-7a7cf93c5bce6624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>举例说明，加入某系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：1,8,1,7,8,2,7,2,1,8,3,8,2,1,3,1,7,1,3,7</p>
<p>这里先直接给出答案</p>
<blockquote>
<p>第一次(1) ：1 第二次(8) ：1 8 第三次(1) ：8 1
（命中）（由于1号页又被访问过了，所以放到最后） 第四次(7) ：8 1 7
第五次(8) ：1 7 8（命中） 第六次(2) ：1 7 8 2 第七次(7) ：1 8 2
7（命中） 第八次(2) ：1 8 7 2（命中） 第九次(1) ：8 7 2 1（命中）
第十次(8) ：7 2 1 8（命中） 第十一次(3) ：2 1 8 3 第十二次(8) ：2 1 3
8（命中） 第十三次(2) ：1 3 8 2（命中） 第十四次(1) ：3 8 2 1（命中）
第十五次(3) ：8 2 1 3（命中） 第十六次(1) ：8 2 3 1（命中） 第十七次(7)
：2 3 1 7 ....</p>
</blockquote>
<blockquote>
<p>这里前10次都1、8、7、2这四个页，四个内存块号正好可以满足，当第11次要访问的3号页进入内存时，需要从1、8、7、2这四个页淘汰一个页，按照该算法，从页号为3的开始，从右往左一次找到这4个页第一次出现的地方，在最左边的就是最近最少使用的页。如下图所示，所以该算法最终淘汰的是7号页。同时直接从第十次的访问结果
7 2 1
8也可以直接看出，7号页在最前面，是最久没有被访问过的，所以淘汰应该是7号页。</p>
</blockquote>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/18464438-cb19ce47127d1574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/443/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>结果图</p>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/18464438-42d29673b6abaf67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/884/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="最不常用算法least-frequently-used-lfu">最不常用算法（Least
Frequently Used, LFU）</h2>
<ul>
<li><p><strong>思路</strong>：缺页时，置换<strong>访问次数最少</strong>的页面</p></li>
<li><p><strong>实现</strong>：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面</p></li>
<li><p><strong>特点</strong>：算法开销大，开始时频繁使用，但以后不使用的页面很难置换</p></li>
</ul>
<h2 id="时钟置换算法">时钟置换算法</h2>
<p>思路：仅对页面的访问情况进行大致统计</p>
<p>实现：在页表项中增加访问位，描述页面在过去一段时间的内访问情况，将各页面组织成环形链表，指针指向最先调入的页面，访问页面时，在页表项记录页面访问情况，缺页时，从指针处开始顺序查找未被访问的页面进行置换</p>
<p>特点：时钟算法是LRU和FIFO的折中</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bYlZuj"><img
src="https://s4.ax1x.com/2022/03/03/bYlZuj.png"
alt="bYlZuj.png" /></a></p>
<h2 id="小结">小结</h2>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/18464438-1d6a6fb356c4dd5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/859/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="进程的状态">进程的状态</h1>
<p><strong>线程在一定条件下，状态会发生变化。线程一共有以下几种状态：</strong></p>
<ol type="1">
<li><p><strong>新建状态(New)</strong>：新创建了一个线程对象。</p></li>
<li><p><strong>就绪状态(Runnable)</strong>：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“<strong>可运行线程池</strong>”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</p></li>
<li><p><strong>运行状态(Running)：</strong>就绪状态的线程获取了CPU，执行程序代码。</p></li>
<li><p><strong>阻塞状态(Blocked)：</strong>阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</p></li>
</ol>
<h1 id="简述什么是僵尸进程">简述什么是僵尸进程</h1>
<p>所谓<strong>僵死进程</strong>，指的是一个进程已经退出，它的内存和相关的资源已经被内核释放掉，但是在进程表中这个进程项（entry）还保留着，以便它的父进程得到它的退出状态。一个进程退出时，它的父进程会收到一个SIGCHLD信号。一般情况下，这个信号的句柄通常执行wait系统调用，这样处于僵死状态的进程会被删除。如果父进程没有这么做，结果是什么呢？毫无疑问，进程会处于僵死状态。实际上，僵死进程不会对系统有太大的伤害，最多就是它的进程号(PID)和进程表中的进程项系统不能使用。</p>
<h1 id="僵尸进程和孤儿进程的区别">僵尸进程和孤儿进程的区别</h1>
<ol type="1">
<li>僵尸进程</li>
</ol>
<ul>
<li>一个父进程利用<code>fork</code>创建子进程，如果子进程退出，而父进程没有利用
<code>wait</code> 或者 <code>waitpid</code>
来获取子进程的状态信息，那么<strong>子进程的状态描述符</strong>依然保存在系统中。</li>
</ul>
<ol start="2" type="1">
<li>孤儿进程</li>
</ol>
<ul>
<li>一个父进程退出，
而它的一个或几个子进程仍然还在运行，那么这些子进程就会变成孤儿进程，孤儿进程将被init进程（进程号为1）所收养，并由init进程对它们完成状态收集的工作</li>
</ul>
<h1 id="io多路复用原理">IO多路复用原理</h1>
<ul>
<li><strong>IO
多路复用</strong>是一种<code>同步IO模型</code>，实现一个线程可以监视多个文件句柄；</li>
<li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li>
<li>没有文件句柄就绪就会阻塞应用程序，交出CPU。</li>
</ul>
<blockquote>
<p>多路是指网络连接，复用指的是同一个线程</p>
</blockquote>
<h2 id="为什么有io多路复用机制">为什么有IO多路复用机制？</h2>
<h2 id="selectpollepoll简介">select、poll、epoll简介</h2>
<p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，<code>其中epoll是Linux所特有，而select则应该是POSIX所规定</code>，一般操作系统均有实现。</p>
<h3 id="select">select</h3>
<p><strong>基本原理：</strong></p>
<blockquote>
<p>select
函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据
可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
</blockquote>
<p><strong>基本流程，如图所示：</strong></p>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/2062729-d75fcc4fa728dadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1090/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>select目前几乎在所有的平台上支持，<code>其良好跨平台支持也是它的一个优点</code>。<code>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</code>，在Linux上一般为1024，<code>可以通过修改宏定义甚至重新编译内核的方式提升这一限制</code>，但是这样也会造成效率的降低。</p>
<p><code>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理</code>。这样所带来的缺点是：</p>
<ol type="1">
<li><strong>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</strong></li>
</ol>
<blockquote>
<p>一般来说这个数目和系统内存关系很大，<code>具体数目可以cat /proc/sys/fs/file-max察看</code>。32位机默认是1024个。64位机默认是2048.</p>
</blockquote>
<ol type="1">
<li><strong>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</strong></li>
</ol>
<blockquote>
<p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<code>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</code>，这正是epoll与kqueue做的。</p>
</blockquote>
<ol type="1">
<li><strong><code>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</code></strong></li>
</ol>
<h3 id="poll">poll</h3>
<p><strong>基本原理：</strong></p>
<blockquote>
<p><code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
</blockquote>
<p><strong>它没有最大连接数的限制，<code>原因是它是基于链表来存储的</code>，但是同样有一个缺点：</strong></p>
<blockquote>
<ol type="1">
<li><code>大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</li>
<li><code>poll还有一个特点是“水平触发”</code>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
</ol>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
</blockquote>
<h3 id="epoll">epoll</h3>
<p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<code>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</code>。</p>
<p><strong>基本原理：</strong></p>
<blockquote>
<p><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p>
</blockquote>
<p><strong>epoll的优点：</strong></p>
<blockquote>
<ol type="1">
<li><code>没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li><code>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li><code>内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</li>
</ol>
</blockquote>
<p><strong>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</strong></p>
<blockquote>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
</blockquote>
<ol type="1">
<li><strong>LT模式</strong></li>
</ol>
<blockquote>
<p><code>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。<code>如果你不作任何操作，内核还是会继续通知你的</code>。</p>
</blockquote>
<ol type="1">
<li><strong>ET模式</strong></li>
</ol>
<blockquote>
<p><code>ET(edge-triggered)是高速工作方式，只支持no-block socket</code>。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK
错误）。<code>但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</code>。</p>
<p><code>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</code>。epoll工作在ET模式的时候，<code>必须使用非阻塞套接口</code>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</blockquote>
<ol type="1">
<li>在select/poll中，<code>进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描</code>，而epoll事先通过epoll_ctl()来注册一个文件描述符，<code>一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制</code>，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。</code>)</li>
</ol>
<p><strong>注意：</strong></p>
<blockquote>
<p>如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。</p>
</blockquote>
<h2 id="selectpollepoll区别">select、poll、epoll区别</h2>
<ol type="1">
<li><strong>支持一个进程所能打开的最大连接数</strong></li>
</ol>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/2062729-a9f94d9cbaccc8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1170/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li><strong>FD剧增后带来的IO效率问题</strong></li>
</ol>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/2062729-34d8955371a90dad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1168/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li><strong>消息传递方式</strong></li>
</ol>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/2062729-4798b7e2d5199e6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1168/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</strong></p>
<blockquote>
<ol type="1">
<li>表面上看epoll的性能最好，<code>但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好</code>，毕竟epoll的通知机制需要很多函数回调。</li>
<li><code>select低效是因为每次它都需要轮询</code>。但低效也是相对的，视情况而定，也可通过良好的设计改善。</li>
</ol>
</blockquote>
<h1 id="虚拟内存及其作用介绍">虚拟内存及其作用介绍</h1>
<p>电脑中所运行的程序均需经过内存执行，若执行的程序占用的内存很大很多，则会导致内存消耗殆尽，为解决该问题，WINDOWS运用了虚拟内存技术，<strong>即拿出一部分硬盘空间来充当内存使用</strong>，这部分空间即称为<strong>虚拟内存</strong>。</p>
<p><strong>虚拟内存技术允许执行进程不必完全处于内存</strong>。这种方案的一个主要优点就是，程序可以大于物理内存。此外，虚拟内存将内存抽象成一个巨大的、统一的存储数组，进而实现了用户看到的<strong>逻辑内存与物理内存的分离</strong>。这种技术使得程序员不再担忧内存容量的限制。</p>
<p><strong>虚拟内存还允许进程轻松共享文件和实现共享内存</strong>。此外，它为创建进程提供了有效的机制。然而，虚拟内存的实现并不容易，并且使用不当还可能会大大降低性能。</p>
<h1 id="内存泄露概念与产生原因与影响">内存泄露概念与产生原因与影响</h1>
<h2 id="为什么会产生内存泄漏">为什么会产生内存泄漏？</h2>
<p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<h2 id="内存泄漏对程序的影响">内存泄漏对程序的影响？</h2>
<p>内存泄漏是<strong>造成应用程序OOM</strong>的主要原因之一。我们知道Android系统为每个应用程序分配的内存是有限的，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过系统分配的内存限额，这就造成了内存溢出从而导致应用Crash。</p>
<h2 id="常见的内存泄漏及解决方法">常见的内存泄漏及解决方法</h2>
<h3 id="单例造成的内存泄漏">单例造成的内存泄漏</h3>
<p>由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。
示例：防止单例导致内存泄漏的实例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AppManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span>(<span class="params">Context context</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span>(<span class="params">Context context</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏。？？？</p>
<h3
id="非静态内部类创建静态实例造成的内存泄漏">非静态内部类创建静态实例造成的内存泄漏</h3>
<p>例如，有时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现如下写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">TestResource</span> <span class="variable">mResource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">if</span>(mResource == <span class="literal">null</span>)&#123;</span><br><span class="line">            mResource = <span class="keyword">new</span> <span class="title class_">TestResource</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TestResource</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据。虽然这样避免了资源的重复创建，但是这种写法却会造成内存泄漏。因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，从而导致Activity的内存资源不能被正常回收。
<strong>解决方法</strong>：将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，就使用Application的Context。</p>
<h3 id="handler造成的内存泄漏">Handler造成的内存泄漏</h3>
<p>示例：创建匿名内部类的静态对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                handler.sendEmptyMessage(<span class="number">0x123</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、从Android的角度
当Android应用程序启动时，该应用程序的主线程会自动创建一个Looper对象和与之关联的MessageQueue。当主线程中实例化一个Handler对象后，它就会自动与主线程Looper的MessageQueue关联起来。所有发送到MessageQueue的Messag都会持有Handler的引用，所以Looper会据此回调Handle的handleMessage()方法来处理消息。只要MessageQueue中有未处理的Message，Looper就会不断的从中取出并交给Handler处理。另外，主线程的Looper对象会伴随该应用程序的整个生命周期。
2、 Java角度
在Java中，非静态内部类和匿名类内部类都会潜在持有它们所属的外部类的引用，但是静态内部类却不会。</p>
<p>对上述的示例进行分析，当MainActivity结束时，未处理的消息持有handler的引用，而handler又持有它所属的外部类也就是MainActivity的引用。这条引用关系会一直保持直到消息得到处理，这样阻止了MainActivity被垃圾回收器回收，从而造成了内存泄漏。
<strong>解决方法</strong>：将Handler类独立出来或者使用静态内部类，这样便可以避免内存泄漏。</p>
<h3 id="线程造成的内存泄漏">线程造成的内存泄漏</h3>
<p>示例：AsyncTask和Runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyAsyncTask</span>(<span class="built_in">this</span>).execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span>&lt;Void, Void, Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyAsyncTask</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Void <span class="title function_">doInBackground</span><span class="params">(Void... params)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPostExecute</span><span class="params">(Void aVoid)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AsyncTask和Runnable都使用了匿名内部类，那么它们将持有其所在Activity的隐式引用。如果任务在Activity销毁之前还未完成，那么将导致Activity的内存资源无法被回收，从而造成内存泄漏。
<strong>解决方法</strong>：将AsyncTask和Runnable类独立出来或者使用静态内部类，这样便可以避免内存泄漏。</p>
<h3 id="资源未关闭造成的内存泄漏">资源未关闭造成的内存泄漏</h3>
<p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏。</p>
<p>1）比如在Activity中register了一个BraodcastReceiver，但在Activity结束后没有unregister该BraodcastReceiver。
2）资源性对象比如Cursor，Stream、File文件等往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于
java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null，而不关闭它们，往往会造成内存泄漏。
3）对于资源性对象在不使用的时候，应该调用它的close()函数将其关闭掉，然后再设置为null。在我们的程序退出时一定要确保我们的资源性对象已经关闭。
4）Bitmap对象不在使用时调用recycle()释放内存。2.3以后的bitmap应该是不需要手动recycle了，内存已经在java层了。</p>
<h3 id="使用listview时造成的内存泄漏">使用ListView时造成的内存泄漏</h3>
<p>初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些View对象缓存起来。当向上滚动ListView时，原先位于最上面的Item的View对象会被回收，然后被用来构造新出现在下面的Item。这个构造过程就是由getView()方法完成的，getView()的第二个形参convertView就是被缓存起来的Item的View对象（初始化时缓存中没有View对象则convertView是null）。</p>
<p>构造Adapter时，没有使用缓存的convertView。
<strong>解决方法</strong>：在构造Adapter时，使用缓存的convertView。</p>
<h3 id="集合容器中的内存泄露">集合容器中的内存泄露</h3>
<p>我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。
<strong>解决方法</strong>：在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。</p>
<h3 id="webview造成的泄露">WebView造成的泄露</h3>
<p>当我们不要使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存，否则其长期占用的内存也不能被回收，从而造成内存泄露。
<strong>解决方法</strong>：为WebView另外开启一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>
<h1 id="线程的状态">线程的状态</h1>
<ol type="1">
<li><strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</li>
<li><strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁。</li>
<li><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8FRedis/" rel="prev" title="Redis">
      <i class="fa fa-chevron-left"></i> Redis
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">1.</span> <span class="nav-text">系统调用 &#x2F; 用户态和内核态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">什么是系统调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">3.</span> <span class="nav-text">如何从用户态切换到内核态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%BF%85%E4%BC%9A%E7%9F%A5%E8%AF%86"><span class="nav-number">4.</span> <span class="nav-text">其他必会知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">线程、进程、协程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">进程和线程的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pcb%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%9D%97%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.</span> <span class="nav-text">PCB（进程管理块）是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">7.</span> <span class="nav-text">进程的五种状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.1.</span> <span class="nav-text">批处理系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.2.</span> <span class="nav-text">交互式系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.3.</span> <span class="nav-text">实时系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">进程同步的方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">进程间通信的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">10.1.</span> <span class="nav-text">常见的通信方式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">10.2.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">10.3.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">10.4.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">10.5.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket"><span class="nav-number">10.6.</span> <span class="nav-text">Socket</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">11.</span> <span class="nav-text">生产者消费者模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">12.</span> <span class="nav-text">手写生产者消费者模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrantlock-%E6%96%B9%E5%BC%8F"><span class="nav-number">12.1.</span> <span class="nav-text">可重入锁ReentrantLock 方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%A6%82%E5%BF%B5"><span class="nav-number">12.1.0.1.</span> <span class="nav-text">可重入锁概念：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">13.</span> <span class="nav-text">死锁发生的条件是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">14.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95optoptimal"><span class="nav-number">14.1.</span> <span class="nav-text">最佳置换算法（OPT，Optimal）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95fifo"><span class="nav-number">14.2.</span> <span class="nav-text">先进先出置换算法（FIFO）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95lruleast-recently-used"><span class="nav-number">14.3.</span> <span class="nav-text">最近最久未使用置换算法（LRU，Least
Recently Used）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95least-frequently-used-lfu"><span class="nav-number">14.4.</span> <span class="nav-text">最不常用算法（Least
Frequently Used, LFU）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">14.5.</span> <span class="nav-text">时钟置换算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">14.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">15.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">16.</span> <span class="nav-text">简述什么是僵尸进程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">17.</span> <span class="nav-text">僵尸进程和孤儿进程的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-number">18.</span> <span class="nav-text">IO多路复用原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">18.1.</span> <span class="nav-text">为什么有IO多路复用机制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#selectpollepoll%E7%AE%80%E4%BB%8B"><span class="nav-number">18.2.</span> <span class="nav-text">select、poll、epoll简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">18.2.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-number">18.2.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">18.2.3.</span> <span class="nav-text">epoll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#selectpollepoll%E5%8C%BA%E5%88%AB"><span class="nav-number">18.3.</span> <span class="nav-text">select、poll、epoll区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">19.</span> <span class="nav-text">虚拟内存及其作用介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E4%B8%8E%E5%BD%B1%E5%93%8D"><span class="nav-number">20.</span> <span class="nav-text">内存泄露概念与产生原因与影响</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">20.1.</span> <span class="nav-text">为什么会产生内存泄漏？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%AF%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">20.2.</span> <span class="nav-text">内存泄漏对程序的影响？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">20.3.</span> <span class="nav-text">常见的内存泄漏及解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">20.3.1.</span> <span class="nav-text">单例造成的内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">20.3.2.</span> <span class="nav-text">非静态内部类创建静态实例造成的内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handler%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">20.3.3.</span> <span class="nav-text">Handler造成的内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">20.3.4.</span> <span class="nav-text">线程造成的内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%9C%AA%E5%85%B3%E9%97%AD%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">20.3.5.</span> <span class="nav-text">资源未关闭造成的内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8listview%E6%97%B6%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">20.3.6.</span> <span class="nav-text">使用ListView时造成的内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">20.3.7.</span> <span class="nav-text">集合容器中的内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webview%E9%80%A0%E6%88%90%E7%9A%84%E6%B3%84%E9%9C%B2"><span class="nav-number">20.3.8.</span> <span class="nav-text">WebView造成的泄露</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">21.</span> <span class="nav-text">线程的状态</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

