<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Satellites contain us Traffic lights control us Rockets shoot us up into the stars">
<meta property="og:type" content="article">
<meta property="og:title" content="框架">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="Satellites contain us Traffic lights control us Rockets shoot us up into the stars">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.471Z">
<meta property="article:modified_time" content="2022-03-09T08:42:47.442Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%A1%86%E6%9E%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>框架 | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8F%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          框架
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-09 16:42:47" itemprop="dateModified" datetime="2022-03-09T16:42:47+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">Satellites contain us Traffic lights control us Rockets shoot us up into the stars</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7RvJmR"><img
src="https://s4.ax1x.com/2022/01/21/7RvJmR.md.png"
alt="7RvJmR.md.png" /></a></p>
<h1 id="spring框架的优缺点">Spring框架的优缺点</h1>
<p><strong>Spring
是一种轻量级开发框架</strong>，旨在提高开发人员的<strong>开发效率</strong>以及系统的<strong>可维护性</strong>。</p>
<p>一般说 Spring 框架指的都是
<code>Spring Framework</code>，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：<strong>核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块</strong>。比如：Core
Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context
组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 <strong>Spring 的 6 个特征</strong>:</p>
<ul>
<li><strong>核心技术</strong>
：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC
测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong>
：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h2 id="spring框架的好处"><strong>Spring框架的好处？</strong></h2>
<ul>
<li><strong>轻量级</strong>：Spring框架是轻量级的，最基础的版本大约只有2MB。</li>
<li><strong>控制反转（IOC）</strong>：通过控制反转技术，实现了<strong>解耦合</strong>。对象给出它们的依赖，而不是创建或查找依赖的对象。</li>
<li><strong>面向切面（AOP）</strong>:Spring支持<strong>面向切面</strong>的编程，并将<strong>应用程序业务逻辑</strong>与<strong>系统服务</strong>分离。</li>
<li><strong>MVC框架</strong>：Spring的WEB框架是一个设计良好的web
MVC框架，它为web框架提供了一个很棒的替代方案。</li>
<li><strong>容器</strong>：Spring包含并管理<strong>对象的生命周期和配置</strong>。</li>
<li><strong>事务管理</strong>：Spring提供了一个<strong>一致性</strong>的事务管理接口，可以收缩到本地事务，也可以扩展到全局事务（JTA）。</li>
<li><strong>异常处理</strong>：Spring提供了方便的<strong>API</strong>来将具体技术的异常（由JDBC、Hibernate或JDO抛出）转换为<strong>一致的unchecked
异常</strong>。</li>
</ul>
<h2 id="spring框架的缺点"><strong>Spring框架的缺点？</strong></h2>
<p>Spring 能够给我们带来很多方便之处，但是同样也存在很多的问题：</p>
<p><strong>使用了大量的反射机制，反射机制非常占用内存</strong>。</p>
<p><strong>（一）重量级框架</strong> 我们看到 Spring 架构图时会发现
Spring
里面包含有很多其他组件，比如数据访问、MVC、事务管理、面向切点、WebSocket
功能等，因此这么复杂的组件集中到一起就会提高初学者的学习成本。还有一方面随着你的服务越多，那么
Spring 的启动就会变得越慢。</p>
<p><strong>（二）集成复杂</strong> 比如想要使用 MyBatis 或者
MongoDB的时候，我们要做很多工作不管使用配置方式也好还是使用注解方式。</p>
<p><strong>（三）配置复杂</strong> 在使用 Spring
的时候，我们更多可能是选择 XML
进行配置，但目前这种配置方式已不再流行。</p>
<p><strong>（四）构建和部署复杂</strong> 启动 Spring 的 IOC
容器，是完全要依赖于第三方的 web 服务器。自身不能启动的。</p>
<h1
id="spring中有两个重要特性是什么">Spring中有两个重要特性是什么？</h1>
<p>回答：Spring中有两个非常重要的特性<strong>IOC</strong>和<strong>AOP</strong>，其中AOP是对IOC功能的拓展，</p>
<p><strong>IOC</strong>：IOC是一种设计思想，就是
<strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong>负责创建对象，使用依赖注入（dependency
injection，DI）管理它们，将对象集中起来，配置对象，管理对象的整个生命周期。</p>
<p><strong>AOP</strong>：AOP模块用于为支持Spring应用程序面向切面的开发。AOP联盟提供了很多支持，这样就确保了Spring和其他AOP框架的共通性。面向切面编程能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<h2 id="aop是怎么实现的">AOP是怎么实现的？</h2>
<p><strong>AOP是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring
AOP会使用<strong>JDK
Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK
Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong>
，这时候Spring AOP会使用 <strong>Cglib</strong>
生成一个被代理对象的子类来作为代理</p>
<h3 id="jdk代理和cglib代理的区别">JDK代理和Cglib代理的区别？</h3>
<ol type="1">
<li>CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高(1.6和1.7的时候，CGLib更快;1.8的时候，jdk更快)</li>
<li>CGLib在创建对象的时候所花费的时间却比JDK动态代理多</li>
<li>singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反之，则适合用JDK动态代理</li>
<li>JDK生成的代理类类型是Proxy(因为继承的是Proxy)，CGLIB生成的代理类类型是Enhancer类型</li>
<li>JDK动态代理是面向接口的，CGLib动态代理是通过字节码底层继承代理类来实现（如果被代理类被final关键字所修饰，那么会失败）</li>
<li>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；
如果要被代理的对象不是实现类，那么Spring会强制使用CGLib来实现动态代理。</li>
</ol>
<h1 id="spring-bean-的生命周期">Spring Bean 的生命周期</h1>
<p>对于普通的 Java 对象，当 new
的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java
自动进行垃圾回收。</p>
<p>而 Spring 中的对象是 bean，bean 和普通的 Java
对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC
容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC
容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean
的生命周期完全由容器控制。</p>
<ul>
<li><p>Bean 的生命周期概括起来就是 <strong>4 个阶段</strong>：</p>
<ol type="1">
<li>实例化（Instantiation）</li>
<li>属性赋值（Populate）</li>
<li>初始化（Initialization）</li>
<li>销毁（Destruction）</li>
</ol>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/1704860a4de235aa~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li><strong>实例化</strong>：第 1 步，实例化一个 bean 对象；</li>
<li><strong>属性赋值</strong>：第 2 步，为 bean
设置相关属性和依赖；</li>
<li><strong>初始化</strong>：第 3~7 步，步骤较多，其中第 5、6
步为初始化操作，第 3、4 步为在初始化前执行，第 7
步在初始化后执行，该阶段结束，才能被用户使用；</li>
<li><strong>销毁</strong>：第
8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁
bean 时再执行相应的方法。</li>
</ol></li>
</ul>
<p><strong>最后总结下如何记忆 Spring Bean 的生命周期：</strong></p>
<ul>
<li>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</li>
<li>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor
在初始化前后的处理以及 InitializingBean 和 init-method
的初始化操作；</li>
<li>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和
destory-method 进行销毁。</li>
</ul>
<h1 id="spring中bean有哪些作用域">Spring中bean有哪些作用域？</h1>
<ul>
<li><strong>singleton</strong>：Spring将bean定义的范围限定为每个Spring
IOC容器只有一个单实例。</li>
<li><strong>prototype</strong>：单个bean定义有任意数量的对象实例。</li>
<li><strong>request</strong>：作用域为一次http请求，该作用域仅在基于web的Spring
ApplicationContext情形下有效。</li>
<li><strong>session</strong>：作用域为HTTP
Session，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li><strong>global-session</strong>：作用域为全局的HTTP
session。该作用域也是仅在基于web的Spring
ApplicationContext情形下有效。</li>
</ul>
<p><strong>默认的作用域是singleton。</strong></p>
<h3 id="追问单例模式是线程安全的吗">追问：单例模式是线程安全的吗？</h3>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。(这个大家可以自行去网上搜一下，顺便学习一下。)</p>
<h1 id="spring中有哪些常见的注解">Spring中有哪些常见的注解？</h1>
<p>回答：这个问题可以选择几个常见的说一下就行，下面给大家列出比较全面的，主要说几个自己项目里用到的即可。</p>
<ul>
<li><strong><span class="citation"
data-cites="Component">@Component</span></strong>：用于指示类是组件。这些类用于自动注入，并在使用基于注解的配置时配置为bean。</li>
<li><strong><span class="citation"
data-cites="Controller">@Controller</span></strong>：是一种特定类型的组件，用于MVC应用程序，主要与@RequestMapping注解一起使用。</li>
<li><strong><span class="citation"
data-cites="Repository">@Repository</span></strong>：用于表示组件用作存储库和存储/检索/搜索数据的操作。我们可以将此注解应用于DAO实现类。</li>
<li><strong><span class="citation"
data-cites="Service">@Service</span></strong>：用于指示类是服务层。</li>
<li><strong><span class="citation"
data-cites="Required">@Required</span>:</strong>
此注解简单地说明作用的bean属性必须在配置时通过bean定义中的显式属性值或通过自动注入填充。如果作用的bean属性未填充，容器将抛出BeanInitializationException。</li>
<li><strong><span class="citation"
data-cites="ResponseBody">@ResponseBody</span></strong>：用于将对象作为response，通常用于将XML或JSON数据作为response发送。</li>
<li><strong><span class="citation"
data-cites="PathVariable">@PathVariable</span></strong>:
用于将动态值从URI映射到处理方法参数。</li>
<li><strong><span class="citation"
data-cites="Autowired">@Autowired</span></strong>:
对自动注入的位置和方式提供了更细粒度的控制。它可以用于在setter方法上自动注入bean。就像@Required
注解一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</li>
<li><strong><span class="citation"
data-cites="Qualifier">@Qualifier</span></strong>：当有多个相同类型的bean并且只需要将一个bean自动注入时，<span
class="citation"
data-cites="Qualifier注解与">@Qualifier注解与</span><span
class="citation"
data-cites="Autowired注释一起使用">@Autowired注释一起使用</span>，通过指定将连接哪个bean来消除歧义。</li>
<li><strong><span class="citation"
data-cites="Scope">@Scope</span></strong>: 配置Spring
bean的作用域。</li>
<li><strong><span class="citation"
data-cites="Configuration">@Configuration</span></strong>：表示Spring
IOC容器可以将该类用作bean定义的源。</li>
<li><strong><span class="citation"
data-cites="ComponentScan">@ComponentScan</span></strong>:
应用此注解时，将扫描包下的所有可用类。</li>
<li><strong><span class="citation"
data-cites="Bean">@Bean</span></strong>：对于基于java的配置，用@Bean注解修饰的方法将返回一个在Spring应用程序上下文中注册为Bean的对象。</li>
<li>用于配置切面和通知、<span class="citation"
data-cites="Aspect">@Aspect</span>、<span class="citation"
data-cites="Before">@Before</span>、<span class="citation"
data-cites="After">@After</span>、<span class="citation"
data-cites="Around">@Around</span>、<span class="citation"
data-cites="Pointcut等的AspectJ注解">@Pointcut等的AspectJ注解</span>。</li>
</ul>
<h1 id="springboot的常用注解">SpringBoot的常用注解</h1>
<p><strong>1、<span class="citation"
data-cites="SpringBootApplication">@SpringBootApplication</span></strong></p>
<p>这个注解是Spring Boot最核心的注解，<strong>用在 Spring
Boot的主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot
的各项能力</strong>。实际上这个注解是@Configuration,<span
class="citation"
data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span>,<span
class="citation"
data-cites="ComponentScan三个注解的组合">@ComponentScan三个注解的组合</span>。由于这些注解一般都是一起使用，所以Spring
Boot提供了一个统一的注解@SpringBootApplication。</p>
<p><strong>2、<span class="citation"
data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span></strong></p>
<p>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot
就能根据当前类路径下的包或者类来配置 Spring Bean。</p>
<p>如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration
注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。</p>
<p><span class="citation"
data-cites="EnableAutoConfiguration实现的关键在于引入了AutoConfigurationImportSelector">@EnableAutoConfiguration实现的关键在于引入了AutoConfigurationImportSelector</span>，其核心逻辑为selectImports方法，逻辑大致如下：</p>
<p>　●　从配置文件META-INF/spring.factories加载所有可能用到的自动配置类；</p>
<p>　●　去重，并将exclude和excludeName属性携带的类排除；</p>
<p>　●　过滤，将满足条件（<span class="citation"
data-cites="Conditional">@Conditional</span>）的自动配置类返回；</p>
<p><strong>3、<span class="citation"
data-cites="Configuration">@Configuration</span></strong></p>
<p>用于<strong>定义配置类，指出该类是 Bean
配置的信息源</strong>，相当于传统的xml配置文件，一般加在主类上。如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p>
<p><strong>4、<span class="citation"
data-cites="ComponentScan">@ComponentScan</span></strong></p>
<p><strong>组件扫描</strong>。让spring
Boot扫描到Configuration类并把它加入到程序上下文。</p>
<p><span class="citation"
data-cites="ComponentScan注解默认就会装配标识了">@ComponentScan注解默认就会装配标识了</span><span
class="citation" data-cites="Controller">@Controller</span>，<span
class="citation" data-cites="Service">@Service</span>，<span
class="citation" data-cites="Repository">@Repository</span>，<span
class="citation"
data-cites="Component注解的类到spring容器中">@Component注解的类到spring容器中</span>。</p>
<p><strong>5、<span class="citation"
data-cites="Repository">@Repository</span></strong></p>
<p>用于标注数据访问组件，即DAO组件。</p>
<p>使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p>
<p><strong>6、<span class="citation"
data-cites="Service">@Service</span></strong></p>
<p>一般用于修饰service层的组件</p>
<p><strong>7、<span class="citation"
data-cites="RestController">@RestController</span></strong></p>
<p>用于标注控制层组件(如struts中的action)，表示这是个控制器bean,并且是将函数的返回值直
接填入HTTP响应体中,是REST风格的控制器；它是@Controller和<span
class="citation"
data-cites="ResponseBody的合集">@ResponseBody的合集</span>。</p>
<p><strong>8、<span class="citation"
data-cites="ResponseBody">@ResponseBody</span></strong></p>
<p>表示该方法的返回结果直接写入HTTP response body中</p>
<p>一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP
response
body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p>
<p><strong>9、<span class="citation"
data-cites="Component">@Component</span></strong></p>
<p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<p><strong>10、<span class="citation"
data-cites="Bean">@Bean</span></strong></p>
<p>相当于XML中的<bean></bean>,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p>
<p><strong>11、<span class="citation"
data-cites="AutoWired">@AutoWired</span></strong></p>
<p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。</p>
<p>当加上（required=false）时，就算找不到bean也不报错。</p>
<p><strong>12、<span class="citation"
data-cites="Qualifier">@Qualifier</span></strong></p>
<p>当有多个同一类型的Bean时，可以用@Qualifier("name")来指定。与@Autowired配合使用</p>
<p><strong>13、<span class="citation"
data-cites="Resource">@Resource</span>(name="name",type="type")</strong></p>
<p>没有括号内内容的话，默认byName。与@Autowired干类似的事。</p>
<p><strong>14、<span class="citation"
data-cites="RequestMapping">@RequestMapping</span></strong></p>
<p>RequestMapping是一个用来处理请求地址映射的注解；提供路由信息，负责URL到Controller中的具体函数的映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<h1 id="xml配置和注解之间有什么区别">XML配置和注解之间有什么区别</h1>
<p><strong>注解的优点</strong>：</p>
<ul>
<li>所有信息都在一个文件中</li>
<li>当类更改了，不用修改xml配置文件</li>
</ul>
<p><strong>xml配置的优点</strong>：</p>
<ul>
<li>POJO及其行为之间更清晰地分离</li>
<li>当你不知道哪个POJO负责该行为时，更容易找到该POJO</li>
</ul>
<h1 id="spring支持的事务管理类型">Spring支持的事务管理类型</h1>
<ul>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ul>
<p><strong>声明式事务又分为两种：</strong></p>
<ol type="1">
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h1 id="spring-事务中的隔离级别有哪几种">Spring
事务中的隔离级别有哪几种?</h1>
<p><strong>TransactionDefinition
接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>
使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别
Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong>
最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>
允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>
对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>
最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h1
id="spring的事务是什么与数据库的事务是否一样">spring的事务是什么？与数据库的事务是否一样</h1>
<p>先说一下什么是事务，<strong>事务</strong>：是对数据库的一些列操作。</p>
<p>之前一直觉得事务只针对于数据库当中，5种隔离级别，7种传播行为，后来才发现这是针对Spring的，对数据库来说<strong>隔离级别</strong>只有4种，Spring多了一个DEFAULT，这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。</p>
<p>总的来说，<strong>本质上其实是同一个概念</strong>。</p>
<p>spring的事务是对数据库的事务的<strong>封装</strong>,最后本质的实现还是在数据库,假如数据库不支持事务的话,spring的事务是没有作用的。</p>
<p>数据库的事务说简单就只有开启,回滚和关闭,spring对数据库事务的包装,原理就是拿一个<strong>数据连接</strong>,根据spring的<strong>事务配置</strong>,操作这个数据连接对数据库进行事务开启,回滚或关闭操作.但是spring除了实现这些,还配合spring的传播行为对事务进行了更广泛的管理.其实这里还有个重要的点,那就是事务中涉及的隔离级别,以及spring如何对数据库的隔离级别进行封装。事务与隔离级别放在一起理解会更好些。</p>
<h1
id="什么是ioc和didi是如何实现的">什么是IoC和DI？DI是如何实现的？</h1>
<p>IoC叫<code>控制反转</code>，DI叫<code>依赖注入</code>。控制反转是把传统上由程序代码直接操控的对象的调用权交给<strong>容器，通过容器来实现对象组件的装配和管理</strong>。"<code>控制反转</code>"就是<strong>对组件对象控制权的转移</strong>，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。<code>依赖注入的基本原则</code>是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，即<strong>由容器动态的将某种依赖关系注入到组件之中</strong>。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```依赖注入```是从应用程序的角度在描述：**应用程序依赖容器创建并注入它所需要的外部资源**；</span><br><span class="line"></span><br><span class="line">```控制反转```是从容器的角度在描述：**容器控制应用程序**，由容器反向的向应用程序注入应用程序所需要的外部资源。</span><br><span class="line"></span><br><span class="line"># springIOC原理是什么？如果要实现IOC需要怎么做？请简单描述一下实现步骤？</span><br><span class="line"></span><br><span class="line">1. IOC是spring的核心，由spring来负责**控制对象的生命周期和对象间的关系**。</span><br><span class="line"></span><br><span class="line">   **IOC**只是一种模式,一种思想,他没有固定的使用方法,spring的底层大量使用了IOC的思想.**IOC是控制反转**.简单说就是将原先需要new出来的对象,先把它**实例化**,同时把它放到一个**容器**里,这样后面需要这个对象的时候,直接通过**注入**的方式拿到,为什么说是注入,其实应该说是从容器里面拿,只不过在spring里,用的更多的是注入, spring中使用IOC的模式,首先,在spring容器中有两个map集合,一个是用来存放bean的配置信息,另一个是用来存放bean的实例。</span><br><span class="line"></span><br><span class="line">   我们在SpringBoot项目里启动主启动类后,系统根据@ConponentScan(&quot;&quot;)和@EnablleAutoConfiguration这两个注解去扫描项目中@ConponentScan(&quot;&quot;)路径下的对象以及@Controller,@Service…等有这类注解的对象,随后将这些对象的信息,像Scope,Lazy,Lifecyle等的信息存入到上面一个map集合里,key就是对象的名字.value则是这些属性信息.再然后,根据两个上下文对象,</span><br><span class="line">   @AnnotationConfigApplicationContext</span><br><span class="line">   @ClassPathXmlApplicationContext</span><br><span class="line">   去生成bean的实例对象,并将它们存放到下面一个map中,key是对象名,value是对象实例,在图中也可以知道一个是通过注解生成实例,一个是通过xml配置信息生成实例.这里看到有人说的是有5个上下文对象,当然,这里用得比较多的就是我说的这两种. 这个时候,map里就有了对象的实例,我们需要的时候,就可以通过getBean(&quot;&quot;)方法去拿我们想要的实例对象.</span><br><span class="line"></span><br><span class="line">   IOC的一个在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI来实现的。比如对象A需要操作数据库，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像***一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</span><br><span class="line"></span><br><span class="line">2. 实现`IOC`的**步骤**</span><br><span class="line"></span><br><span class="line">   定义用来描述bean的配置的Java类、解析bean的配置、遍历存放HashMap对象</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"># Spring中自动装配的方式有哪些？</span><br><span class="line"></span><br><span class="line">1. `no`：不进行自动装配，手动设置Bean的依赖关系。</span><br><span class="line">2. `byName`：根据Bean的名字进行自动装配。</span><br><span class="line">3. `byType`：根据Bean的类型进行自动装配。</span><br><span class="line">4. `constructor`：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。</span><br><span class="line">5. `autodetect`：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</span><br><span class="line"></span><br><span class="line"># 请简要说明一下IOC和AOP是什么？</span><br><span class="line"></span><br><span class="line">`控制反转（IoC）`与`依赖注入（DI）`是同一个概念，  </span><br><span class="line">**引入IOC的目的**：  </span><br><span class="line"></span><br><span class="line">1. 脱开、降低类之间的耦合；  </span><br><span class="line">2. 倡导面向接口编程、实施依赖倒换原则；  </span><br><span class="line">3. 提高系统可插入、可测试、可修改等特性。</span><br><span class="line">3. 可维护性、可扩展性更好。</span><br><span class="line"></span><br><span class="line">**具体做法**：  </span><br><span class="line"></span><br><span class="line">1. 将bean之间的依赖关系尽可能地抓换为关联关系；</span><br><span class="line"></span><br><span class="line">2. 将对具体类的关联尽可能地转换为对Java interface的关联，而不是与具体的服务对象相关联；</span><br><span class="line"></span><br><span class="line">3. Bean实例具体关联相关Java interface的哪个实现类的实例，在配置信息的元数据中描述；</span><br><span class="line"></span><br><span class="line">4. 由IoC组件（或称容器）根据配置信息，实例化具体bean类、将bean之间的依赖关系注入进来。</span><br><span class="line"></span><br><span class="line">`AOP`，即面向切面编程，它利用一种称为&quot;横切&quot;的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为&quot;Aspect&quot;，所谓&quot;切面&quot;是那些**与业务无关，却为业务模块所共同调用的逻辑或责任封装起来**，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</span><br><span class="line"></span><br><span class="line">使用&quot;横切&quot;技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开。</span><br><span class="line"></span><br><span class="line"># Spring支持的事务管理类型有哪些？以及在项目中会使用哪种方式？</span><br><span class="line"></span><br><span class="line">Spring支持`编程式事务管理`和`声明式事务管理`。许多Spring框架的用户选择**声明式事务管理**，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。</span><br><span class="line"></span><br><span class="line"># 如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</span><br><span class="line"></span><br><span class="line">1. `连接点（Joinpoint）`：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。</span><br><span class="line">2. `切点`：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。</span><br><span class="line">3. `增强（Advice）`：增强是织入到目标类连接点上的一段程序代码。</span><br><span class="line">4. `引介（Introduction）`：引介是一种特殊的增强，它为类添加一些属性和方法。</span><br><span class="line">5. `织入（Weaving）`：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式</span><br><span class="line">   6.` 切面`：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</span><br><span class="line"></span><br><span class="line"># AOP的原理是什么？</span><br><span class="line"></span><br><span class="line">`AOP`指**面向切面编程**，用于**处理系统中分布于各个模块的横切关注点**，比如事务管理、日志、缓存等等。AOP实现的关键在于**AOP框架自动创建的AOP代理**。所谓&quot;切面&quot;是那些**与业务无关，却为业务模块所共同调用的逻辑或责任封装起来**，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</span><br><span class="line"></span><br><span class="line">AOP分为静态AOP和动态AOP。静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。动态AOP是指将切面代码进行动态织入实现的AOP。**Spring的AOP为动态AOP**，实现的技术为：**JDK提供的动态代理技术** 和 **CGLIB(动态字节码增强技术)**。尽管实现技术不一样，但都是基于代理模式，都是生成一个代理对象。</span><br><span class="line"></span><br><span class="line">`JDK动态代理`通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。核心是**InvocationHandler接口**和**Proxy类**。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</span><br><span class="line"></span><br><span class="line">`CGLIB（Code Generation Library）`，是一个代码生成的类库，可以在运行时动态的生成某个类的子类。</span><br><span class="line"></span><br><span class="line"># 请问AOP的应用场景有哪些？</span><br><span class="line"></span><br><span class="line">Authentication 权限 ，Caching 缓存 ，Context passing 内容传递 ，Error handling 错误处理 ，Lazy loading 懒加载 ，Debugging 调试 ，logging, tracing, profiling and monitoring 记录跟踪　优化　校准，Performance optimization 性能优化 ，Persistence 持久化 ，Resource pooling 资源池 ，Synchronization 同步，Transactions 事务。</span><br><span class="line"></span><br><span class="line"># Spring框架为企业级开发带来的好处有哪些？ </span><br><span class="line"></span><br><span class="line">1. `非侵入式`：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。</span><br><span class="line">2. `IoC容器`：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。</span><br><span class="line">3. `AOP`：将所有的横切关注功能封装到切面中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。</span><br><span class="line">4. `MVC`：Spring的MVC框架为Web表示层提供了更好的解决方案。</span><br><span class="line">5. `事务管理`：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。</span><br><span class="line">6. `其他`：Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。</span><br><span class="line"></span><br><span class="line"># AOP实现的几种方式</span><br><span class="line"></span><br><span class="line">第一种：`静态织入`，即在编译时，就将各种涉及AOP拦截的代码注入到符合一定规则的类中，编译后的代码与我们直接在RealA调用属性或方法前后增加代码是相同的，只是这个工作交由编译器来完成。</span><br><span class="line"></span><br><span class="line">第二种：`EMIT反射`，即：通过Emit反射动态生成代理类</span><br><span class="line"></span><br><span class="line">第三种：`普通反射+利用Remoting的远程访问对象时的直实代理类`来实现</span><br><span class="line"></span><br><span class="line"># Spring如何选择用JDK还是CGLiB？</span><br><span class="line"></span><br><span class="line">1. 当Bean**实现接口**时，Spring就会用`JDK的动态代理`。</span><br><span class="line"></span><br><span class="line">2. 当Bean**没有实现接口**时，Spring使用`CGlib`实现。</span><br><span class="line"></span><br><span class="line"># 持久层设计要考虑的问题有哪些？用过的持久层框架都有哪些？</span><br><span class="line"></span><br><span class="line">所谓&quot;**持久**&quot;就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。`持久层`就是系统中专注于实现数据持久化的相对独立的层面。</span><br><span class="line"></span><br><span class="line">**持久层设计的目标包括：**</span><br><span class="line"></span><br><span class="line">1. 数据存储逻辑的分离，提供抽象化的数据访问接口。  </span><br><span class="line">2. 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。  </span><br><span class="line">3. 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。</span><br><span class="line">4. 数据抽象，提供更面向对象的数据操作。</span><br><span class="line"></span><br><span class="line"># 实体对象的三种状态是什么？以及对应的转换关系是什么？</span><br><span class="line"></span><br><span class="line">Hibernate文档中为`Hibernate对象`定义了`四种状态`，分别是：**瞬时态**（new, or transient）、**持久态**（managed, or persistent）、**游状态**（detached）和**移除态**</span><br><span class="line"></span><br><span class="line">1. `瞬时态`：当new一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save()、saveOrUpdate()、persist()、merge()方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对象。</span><br><span class="line">2. `持久态`：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态对象进行delete操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。</span><br><span class="line">3. `游离态`：当Session进行了close()、clear()、evict()或flush()后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。</span><br><span class="line"></span><br><span class="line"># 锁机制的作用是什么？Hibernate的悲观锁和乐观锁机制是什么？</span><br><span class="line"></span><br><span class="line">有些业务逻辑在执行过程中要求**对数据进行排他性的访问**，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的`锁机制`。</span><br><span class="line"></span><br><span class="line">Hibernate支持`悲观锁`和`乐观锁`两种锁机制。**悲观锁**，顾名思义**悲观的认为在数据处理过程中极有可能存在修改数据的并发事务**（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，**乐观锁**，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。</span><br><span class="line"></span><br><span class="line">- **依赖注入的注入方式：**</span><br><span class="line"></span><br><span class="line">  1. 使用`构造函数`提供  </span><br><span class="line">  2. 使用`set方法`提供  </span><br><span class="line">  3. 使用`注解`提供</span><br><span class="line"></span><br><span class="line">- **创建bean的方式：**</span><br><span class="line"></span><br><span class="line">  1. 使用默认构造函数  </span><br><span class="line">  2. 使用普通工厂中的方法创建对象  </span><br><span class="line">  3. 使用工厂中的静态方法创建对象</span><br><span class="line"></span><br><span class="line">- **Aspectj对AOP的实现：**</span><br><span class="line"></span><br><span class="line">  1）注册bean  </span><br><span class="line"></span><br><span class="line">  2) 配置aop  </span><br><span class="line">     3）定义切入点  </span><br><span class="line">     4）定义切面（哪种通知）</span><br><span class="line"></span><br><span class="line"># Spring如何解决循环依赖</span><br><span class="line"></span><br><span class="line">spring中`循环依赖`有三种情况：</span><br><span class="line"></span><br><span class="line">1. **构造器注入形成的循环依赖**。也就是beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成舒适化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决。</span><br><span class="line"></span><br><span class="line">2. **setter注入构成的循环依赖**。beanA需要在beanB的setter方法中完成初始化，beanB也需要在beanA的setter方法中完成初始化，spring设计的机制主要就是解决这种循环依赖</span><br><span class="line"></span><br><span class="line">3. **prototype作用域bean的循环依赖**。这种循环依赖同样无法解决，因为spring不会缓存`prototype`作用域的bean，而spring中循环依赖的解决正是通过缓存来实现的。</span><br><span class="line"></span><br><span class="line">spring只能解决`setter注入`构成的依赖，第二种情况中循环依赖的**解决方案**：</span><br><span class="line"></span><br><span class="line">**步骤一**：beanA进行初始化，并且将自己进行初始化的状态记录下来，并提前向外暴露一个单例工程方法，从而使其他bean能引用到该bean。</span><br><span class="line"></span><br><span class="line">**步骤二**：beanA中有beanB的依赖，于是开始初始化beanB。</span><br><span class="line"></span><br><span class="line">**步骤三**：初始化beanB的过程中又发现beanB依赖了beanA,于是又进行beanA的初始化，这时发现beanA已经在进行初始化了，程序发现了存在的循环依赖，然后通过步骤一中暴露的单例工程方法拿到beanA的引用（注意，此时的beanA只是完成了构造函数的注入但为完成其他步骤），从而beanB拿到beanA的引用，完成注入，完成了初始化，如此beanB的引用也就可以被beanA拿到，从而beanA也就完成了初始化。</span><br><span class="line"></span><br><span class="line"># Spring的加载过程</span><br><span class="line"></span><br><span class="line">初始化环境—&gt;加载配置文件—&gt;实例化Bean—&gt;调用Bean显示信息</span><br><span class="line"></span><br><span class="line"># @Transactional 详解</span><br><span class="line"></span><br><span class="line">- **@Transactional** 是`声明式事务管理`编程中使用的**注解**。</span><br><span class="line">- 添加位置</span><br><span class="line">  - 接口实现类或接口实现方法上，而不是接口类中。</span><br><span class="line">- 访问权限：`public` 的方法才起作用。</span><br><span class="line">  - `@Transactional 注解`应该只被应用到 `public` 方法上，这是由 `Spring AOP` 的本质决定的。</span><br><span class="line">- **系统设计**：将标签放置在需要进行事务管理的方法上，而不是放在所有接口实现类上：只读的接口就不需要事务管理，由于配置了`@Transactional`就需要AOP拦截及事务的处理，可能影响系统性能。</span><br><span class="line">- 错误使用：</span><br><span class="line">  - 接口中A、B两个方法，A无@Transactional标签，B有，上层通过A间接调用B，此时事务不生效。</span><br><span class="line"></span><br><span class="line">  - 接口中异常（运行时异常）被捕获而没有被抛出</span><br><span class="line">    - 默认配置下，spring 只有在抛出的异常为运行时 unchecked 异常时才回滚该事务，也就是抛出的异常为RuntimeException 的子类(Errors也会导致事务回滚)，而抛出 checked 异常则不会导致事务回滚。</span><br><span class="line">    - 可通过 @Transactional rollbackFor进行配置。</span><br><span class="line"></span><br><span class="line">  - 多线程下事务管理</span><br><span class="line">    - 因为线程不属于 spring 托管，故线程不能够默认使用 spring 的事务,也不能获取spring 注入的 bean。</span><br><span class="line">    - 在被 spring 声明式事务管理的方法内开启多线程，多线程内的方法不被事务控制。</span><br><span class="line">      - 一个使用了@Transactional 的方法，如果方法内包含多线程的使用，方法内部出现异常，不会回滚线程中调用方法的事务。</span><br><span class="line"></span><br><span class="line">## 声明式事务管理实现方式</span><br><span class="line"></span><br><span class="line">基于 `tx` 和 `aop` 名字空间的 `xml` 配置文件</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// 基本配置</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;</span><br><span class="line">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span><br><span class="line">                          http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span><br><span class="line">                          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd</span><br><span class="line">                          http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd</span><br><span class="line">                          http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.1.xsd</span><br><span class="line">                          http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd</span><br><span class="line">                          http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-4.1.xsd&quot;&gt;</span><br><span class="line">&lt;bean name=&quot;transactionManager&quot;</span><br><span class="line">        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; proxy-target-class=&quot;true&quot; /&gt;</span><br><span class="line">// MyBatis 自动参与到 spring 事务管理中，无需额外配置，</span><br><span class="line">只要 org.mybatis.spring.SqlSessionFactoryBean 引用的数据源与</span><br><span class="line">DataSourceTransactionManager 引用的数据源一致即可，否则事务管理会不起作用。</span><br><span class="line">// &lt;annotation-driven&gt; 标签的声明，</span><br><span class="line">是在 Spring 内部启用 @Transactional 来进行事务管理，使用 @Transactional 前需要配置。</span><br></pre></td></tr></table></figure></p>
<h2 id="transactional注解"><span class="citation"
data-cites="Transactional注解">@Transactional注解</span></h2>
<p><code>@Transactional</code> 实质是使用了 JDBC
的事务来进行事务控制的</p>
<p><code>@Transactional</code> 基于 Spring 的动态代理的机制</p>
<p><strong><span class="citation"
data-cites="Transactional">@Transactional</span> 实现原理</strong>：</p>
<ol type="1">
<li><p>事务开始时，通过AOP机制，生成一个代理connection对象，并将其放入
<code>DataSource</code> 实例的某个与
<code>DataSourceTransactionManager</code>
相关的某处容器中。在接下来的整个事务中，客户代码都应该使用该 connection
连接数据库，执行所有数据库命令。[不使用该 connection
连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]（物理连接
connection 逻辑上新建一个会话session；DataSource 与 TransactionManager
配置相同的数据源）</p></li>
<li><p>事务结束时，回滚在第1步骤中得到的代理 connection
对象上执行的数据库命令，然后关闭该代理 connection
对象。（事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用）</p></li>
</ol>
<h2 id="声明式事务的管理实现本质">声明式事务的管理实现本质</h2>
<p><strong>事务的两种开启方式</strong>：</p>
<ol type="1">
<li>显示开启 <code>start transaction | begin</code>，通过
<code>commit | rollback</code> 结束事务</li>
<li>关闭数据库中自动提交
<code>autocommit set autocommit = 0</code>；MySQL
默认开启自动提交；通过手动提交或执行回滚操作来结束事务</li>
</ol>
<p>Spring
关闭数据库中自动提交：在方法执行前关闭自动提交，方法执行完毕后再开启自动提交</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.jdbc.datasource.DataSourceTransactionManager.java 源码实现</span></span><br><span class="line"><span class="comment">// switch to manual commit if necessary. this is very expensive in some jdbc drivers,</span></span><br><span class="line"><span class="comment">// so we don&#x27;t want to do it unnecessarily (for example if we&#x27;ve explicitly</span></span><br><span class="line"><span class="comment">// configured the connection pool to set it already).</span></span><br><span class="line"><span class="keyword">if</span> (con.getautocommit()) &#123;</span><br><span class="line">    txobject.setmustrestoreautocommit(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isdebugenabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;switching jdbc connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    con.setautocommit(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ul>
<li><p>关闭自动提交后，若事务一直未完成，即未手动执行<code>commit</code>
或 <code>rollback</code> 时如何处理已经执行过的SQL操作？</p>
<ul>
<li>C3P0默认的策略是回滚任何未提交的事务。</li>
<li>C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。</li>
<li>JNDI(Java Naming and Directory
Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI
API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。</li>
</ul></li>
</ul>
<h2 id="spring事务特性">spring事务特性</h2>
<p>spring所有的事务管理策略类都继承自<code>org.springframework.transaction.PlatformTransactionManager</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">  TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span></span><br><span class="line">  <span class="keyword">throws</span> TransactionException;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>事务的隔离级别</strong>：是指若干个并发的事务之间的隔离程度</p>
<ul>
<li><p><code>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code>：读取未提交数据(会出现脏读,
不可重复读) 基本不使用</p></li>
<li><p><code>@Transactional(isolation = Isolation.READ_COMMITTED)</code>：读取已提交数据(会出现不可重复读和幻读)</p></li>
<li><p><code>@Transactional(isolation = Isolation.REPEATABLE_READ)</code>：可重复读(会出现幻读)</p></li>
<li><p><code>@Transactional(isolation = Isolation.SERIALIZABLE)</code>：串行化</p></li>
</ul>
<p><strong>事务传播行为</strong>：如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为</p>
<ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li>
<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li><code>TransactionDefinition.PROPAGATION_NESTED</code>：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="transactional-属性配置"><span class="citation"
data-cites="Transactional">@Transactional</span> 属性配置</h2>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 36%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">value</td>
<td style="text-align: center;">String</td>
<td
style="text-align: center;">可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr class="even">
<td style="text-align: center;">propagation</td>
<td style="text-align: center;">enum: Propagation</td>
<td style="text-align: center;">可选的事务传播行为设置</td>
</tr>
<tr class="odd">
<td style="text-align: center;">isolation</td>
<td style="text-align: center;">enum: Isolation</td>
<td style="text-align: center;">可选的事务隔离级别设置</td>
</tr>
<tr class="even">
<td style="text-align: center;">readOnly</td>
<td style="text-align: center;">boolean</td>
<td style="text-align: center;">读写或只读事务，默认读写</td>
</tr>
<tr class="odd">
<td style="text-align: center;">timeout</td>
<td style="text-align: center;">int (in seconds granularity)</td>
<td style="text-align: center;">事务超时时间设置</td>
</tr>
<tr class="even">
<td style="text-align: center;">rollbackFor</td>
<td style="text-align: center;">Class对象数组，必须继承自Throwable</td>
<td style="text-align: center;">导致事务回滚的异常类数组</td>
</tr>
<tr class="odd">
<td style="text-align: center;">rollbackForClassName</td>
<td style="text-align: center;">类名数组，必须继承自Throwable</td>
<td style="text-align: center;">导致事务回滚的异常类名字数组</td>
</tr>
<tr class="even">
<td style="text-align: center;">noRollbackFor</td>
<td style="text-align: center;">Class对象数组，必须继承自Throwable</td>
<td style="text-align: center;">不会导致事务回滚的异常类数组</td>
</tr>
<tr class="odd">
<td style="text-align: center;">noRollbackForClassName</td>
<td style="text-align: center;">类名数组，必须继承自Throwable</td>
<td style="text-align: center;">不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>value</strong>
：主要用来指定不同的事务管理器；主要用来满足在同一个系统中，存在不同的事务管理器。比如在Spring中，声明了两种事务管理器txManager1,
txManager2。然后，用户可以根据这个参数来根据需要指定特定的txManager。
<ul>
<li><strong>value
适用场景</strong>：在一个系统中，需要访问多个数据源或者多个数据库，则必然会配置多个事务管理器</li>
</ul></li>
<li><code>REQUIRED_NEW</code>和<code>NESTED</code>两种不同的传播机制的区别
<ul>
<li><strong>REQUIRED_NEW</strong>：内部的事务独立运行，在各自的作用域中，可以独立的回滚或者提交；而外部的事务将不受内部事务的回滚状态影响</li>
</ul></li>
<li><strong>ESTED的事务</strong>，基于单一的事务来管理，提供了多个保存点。这种多个保存点的机制允许内部事务的变更触发外部事务的回滚。而外部事务在混滚之后，仍能继续进行事务处理，即使部分操作已经被混滚。
由于这个设置基于JDBC的保存点，所以只能工作在JDBC的机制</li>
<li><strong>rollbackFor</strong> ：
让受检查异常回滚；即让本来不应该回滚的进行回滚操作</li>
<li><strong>noRollbackFor</strong>
：忽略非检查异常；即让本来应该回滚的不进行回滚操作</li>
</ul>
<h2 id="嵌套事务">嵌套事务</h2>
<p>带有事务的方法调用其他事务的方法，此时执行的情况取决配置的事务的传播属性</p>
<ul>
<li><strong>PROPAGATION_REQUIRES_NEW</strong> ：
<ul>
<li>启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited
或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等.
当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时,
外部事务将继续执行.</li>
</ul></li>
<li><strong>PROPAGATION_NESTED</strong> ：
<ul>
<li>如果外部事务 commit, 嵌套事务也会被 commit；如果外部事务 roll back,
嵌套事务也会被 roll back 。</li>
<li>开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务.
嵌套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败,
我们将回滚到此 savepoint. 嵌套事务是外部事务的一部分,
只有外部事务结束后它才会被提交</li>
</ul></li>
</ul>
<h2 id="spring事务回滚规则">spring事务回滚规则</h2>
<ul>
<li>指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常.
spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务</li>
<li>默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。</li>
<li>用 spring
事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行期例外(throw
new
RuntimeException(“注释”);)会回滚，即遇到不受检查（unchecked）的例外时回滚；而遇到需要捕获的例外(throw
new
Exception(“注释”);)不会回滚,即遇到受检查的例外（就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常）时，需我们指定方式来让事务回滚要想所有异常都回滚,要加上
<span class="citation" data-cites="Transactional">@Transactional</span>(
rollbackFor={Exception.class,其它异常}) .如果让unchecked例外不回滚：
<span class="citation"
data-cites="Transactional">@Transactional</span>(notRollbackFor=RunTimeException.class)</li>
</ul>
<h2 id="注意事项">注意事项：</h2>
<ul>
<li><span class="citation"
data-cites="Transactional">@Transactional</span> 使用位置
类上方、方法上方
<ul>
<li>Spring
建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效
当作用于类上时，该类的所有 public
方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</li>
</ul></li>
<li>方法的访问权限为 public
<ul>
<li><span class="citation"
data-cites="Transactional">@Transactional</span> 注解应该只被应用到
public 方法上，这是由 Spring AOP 的本质决定的。在 protected、private
或者默认可见性的方法上使用 <span class="citation"
data-cites="Transactional">@Transactional</span>
注解，这将被忽略，也不会抛出任何异常</li>
</ul></li>
<li>默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰
<ul>
<li><em>例如一</em>：同一个类中方法，A方法未使用此标签，B使用了，C未使用，A
调用 B , B 调用 C ；则外部调用A之后，B的事务是不会起作用的</li>
<li><em>例如二</em>：若是有上层（按照
Controller层、Service层、DAO层的顺序）由Action 调用 Service
直接调用，发生异常会发生回滚；若间接调用，Action 调用 Service 中 的A
方法，A无@Transactional 注解，B有，A调用B，B的注解无效</li>
</ul></li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li>事务方法的嵌套调用会产生事务传播</li>
<li>spring 的事务管理是线程安全的</li>
<li>父类的声明的@Transactional会对子类的所有方法进行事务增强；子类覆盖重写父类方式可覆盖其@Transactional中的声明配置</li>
<li>类名上方使用@Transactional，类中方法可通过属性配置覆盖类上的@Transactional配置；比如：类上配置全局是可读写，可在某个方法上改为只读</li>
</ul>
<h1 id="springmvc拦截器和过滤器">SpringMVC：拦截器和过滤器</h1>
<p>首先说明一下二者的区别：</p>
<ol type="1">
<li><p>拦截器基于java的反射机制，而过滤器是基于函数回调</p></li>
<li><p>拦截器不依赖于servlet容器，过滤器依赖servlet容器</p></li>
<li><p>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用</p></li>
<li><p>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次</p></li>
<li><p>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器注入一个service，可以调用业务逻辑</p></li>
</ol>
<h2 id="什么是过滤器filter">什么是过滤器(Filter)</h2>
<p><strong>过滤器</strong>：</p>
<p>过滤器使用filter实现，拦截的是request请求，基于回调，基于servlet规范</p>
<p>依赖容器，有初始化方法和销毁方法，拦截的是地址，粒度很大</p>
<p><strong>过滤器Filter</strong>:过滤器通过实现Filter接口，实现了过滤器的三个方法，分别是初始化方法，dofilter方法和销毁方法，随着容器的启动和销毁而初始化和销毁，依赖于servlet容器，过滤器拦截的是地址栏请求，过滤器实在进入容器后执行的servlet之前后执行，针对的在处理业务之前的操作。</p>
<p><code>chain.doFilter(request, response);这个方法的调用作为分水岭。事实上调用Servlet的doService()方法是在这个方法中进行的。</code></p>
<h3 id="代码实现">代码实现</h3>
<p>过滤器代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;过滤器1销毁方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;过滤器1，客户端向Servlet发送的请求被我拦截到了，设置请求编码&quot;</span>);</span><br><span class="line">		chain.doFilter(request, response);</span><br><span class="line">		System.out.println(<span class="string">&quot;过滤器1，Servlet向客户端发送的响应被我拦截到了，设置相应编码&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;过滤器1初始化方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.thit.filters.Filter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span></span><br><span class="line">  &lt;/filter&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- /*是对所有的文件进行拦截 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="什么是拦截器">什么是拦截器</h2>
<p><strong>拦截器</strong>：</p>
<p>是基于Java的jdk动态代实现的，实现HandlerInterceptor接口。不依赖于servlet容器，</p>
<p>拦截器针对于controller方法，并且能获取到所有的类，对类里面所有的方法实现拦截，粒度更小，拦截器中可以注入service，也可以调用业务逻辑</p>
<h3 id="代码实现-1">代码实现</h3>
<p>拦截器1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拦截器1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//预处理1.程序先执行preHandle()方法，如果该方法的返回值为true，则程序会继续向下执行处理器中的方法，否则将不再向下执行。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;1:拦截器1,程序进入preHandle方法&quot;</span>);</span><br><span class="line">		User u=(User) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(u==<span class="literal">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;在进入方法之前判断session的用户是否为空！&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;地址：&quot;</span>+request.getContextPath());</span><br><span class="line">			<span class="comment">//http://localhost:8080/login</span></span><br><span class="line">			response.sendRedirect(request.getContextPath()+<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后处理 	2.在业务处理器（即控制器Controller类）处理完请求后，会执行postHandle()方法，然后会通过DispatcherServlet向客户端返回响应。</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">			ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;2:拦截器1,程序进入postHandle方法&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//完工之后 	3.在DispatcherServlet处理完请求后，才会执行afterCompletion()方法。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;3:拦截器1,程序进入afterCompletion方法&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拦截器2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拦截器2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interceptor2</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;1:拦截器2,进入到preHandle&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">			ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;2:拦截器2,进入到postHandle&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;3:拦截器2,进入到afterCompletion&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拦截器于过滤器对比">拦截器于过滤器对比</h2>
<ol type="1">
<li><p>两者都是AOP编程思想的实现，都能够实现权限控制和日志记录等问题的处理，但是两者粒度不同拦截对象不一样</p></li>
<li><p><strong>适用范围不同</strong>
：Filter是servlet的规范，只能用于web程序，但是拦截器可以用于application等程序。</p></li>
<li><p><strong>规范不同</strong>：Filter是servlet的规范。但是Interceptor是spring容器支撑，有spring框架支持。</p></li>
<li><p><strong>使用资源不一样</strong>：spring的拦截器由于依赖spring，也是spring的一个组件，因此能够在拦截器中使用spring的任何资源和对象。例如service对象，数据源，事务管理等，通过ioc注入拦截器即可，而filter不能</p></li>
<li><p><strong>粒度不同</strong>：Filter只能在servlet的前后起作用，而拦截器能在方法前后异常前后执行，更加灵活，粒度更小，spring框架程序优先使用拦截器。</p></li>
</ol>
<h2 id="案例执行图">案例执行图</h2>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7eB44s"><img
src="https://s4.ax1x.com/2022/01/11/7eB44s.md.png"
alt="7eB44s.md.png" /></a></p>
<h1 id="springspringmvc-springboot的区别">Spring、SpringMVC
、Springboot的区别</h1>
<h2
id="什么是spring它解决了什么问题">什么是Spring？它解决了什么问题？</h2>
<p>我们说到Spring，一般指代的是Spring
Framework，它是一个开源的应用程序框架，提供了一个简易的开发方式，<strong>通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象，说的更通俗一点就是由框架来帮你管理这些对象，包括它的创建，销毁等</strong>，比如基于Spring的项目里经常能看到的<code>Bean</code>，它代表的就是由Spring管辖的对象。</p>
<p>而在被管理对象与业务逻辑之间，Spring通过IOC（控制反转）架起使用的桥梁，IOC也可以看做Spring最核心最重要的思想，通过IOC能带来什么好处呢？首先来看一个实际开发中的典型应用场景，假设我们有一个基于MVC分层结构的应用，通过controller层对外提供接口，而通过service层提供具体的实现，在service层中有一个<code>WelcomeService</code>服务接口，一般情况下都是通过<code>WelcomeService service = new WelcomeServiceImpl();</code>创建实例并进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">WelcomeService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WelcomeServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/welcome&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> service.retrieveWelcomeMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后发现一切正常，此时，功能提交，需要进行测试，而由于实际应用环境与测试环境有所区别，需要替换<code>WelcomeServiceImpl</code>为一个<code>MockWelcomeServiceImpl</code>，以方便测试，怎么办？没有其他办法，只有改代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> WelcomeService service = <span class="keyword">new</span> <span class="built_in">MockWelcomeServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试OK后再将代码改回去，这种方式太过于繁琐，且对代码的侵入性很强；
下面看通过Spring的IOC如何实现，首先将<code>WelcomeService</code>交由Spring管理：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;WelcomeService&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;XXX.XXX.XXX.service.impl.WelcomeServiceImpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>然后在业务代码处通过Spring IOC拿到具体对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WelcomeService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="string">&quot;/welcome&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String welcome() &#123;</span><br><span class="line">        <span class="keyword">return</span> service.retrieveWelcomeMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试的时候，只需要更改配置文件，将<code>WelcomeService</code>对应的实现改为<code>MockWelcomeServiceImpl</code>即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;WelcomeService&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;XXX.XXX.XXX.service.impl.MockWelcomeServiceImpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式对业务代码没有任何侵入，<strong>它有效的实现松耦合</strong>，大家都知道紧耦合的代码是业务发展的噩梦；同时，Spring
IOC提供的远不止这些，如通过单例减少创建无用的对象，通过延迟加载优化初始化成本等</p>
<p>当然，Spring 的核心功能远不知这些，如：</p>
<ul>
<li>Spring AOP</li>
<li>Spring JDBC</li>
<li>Spring MVC</li>
<li>Spring ORM</li>
<li>Spring JMS</li>
<li>Spring Test</li>
</ul>
<p>其实不通过Spring框架依然可以实现这些功能特定，但是Spring
提供了更优雅的抽象接口以方便对这些功能的组装，同时又给予每个具体实现以灵活的配置；另外，基于Spring，你可以方便的与其他框架进行集成，如<code>hibernate</code>，<code>ibatis</code>等，Spring官方的原则是绝不重复造轮子，有好的解决方案只需要通过Spring进行集成即可。<strong>纵览Spring的结构，你会发现Spring
Framework
本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案</strong>。</p>
<h2 id="什么是spring-mvc它解决了什么问题">什么是Spring
MVC？它解决了什么问题？</h2>
<p>Spring MVC是Spring的一部分，Spring
出来以后，大家觉得很好用，于是按照这种模式设计了一个
MVC框架（一些用Spring
解耦的组件），<strong>主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher
Servlet, ModelAndView 和 View
Resolver，让应用开发变得很容易</strong>，一个典型的Spring
MVC应用开发分为下面几步： 首先通过配置文件声明Dispatcher Servlet：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.qgd.oms.web.common.mvc.OmsDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过配置文件声明servlet详情，如MVC resource，data source，bean等</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/css/&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;21600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/js/&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;21600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/views/**/*.html&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/views/&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;21600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/fonts/**/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/fonts/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/ueditor/**/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/js/lib/ueditor/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/**/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/img/&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQuery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.validationQuery&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultAutoCommit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxOpenPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;configService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.qgd.oms.web.common.service.ConfigService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configStore&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.qgd.oms.web.common.service.impl.DbConfigStore&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;taskScheduler&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;defaultScheduler&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;refreshInterval&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>若需添加其它功能，如security，则需添加对应配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">&quot;/css/**/*&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">&quot;/js/**/*&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">&quot;/views/**/*.html&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">&quot;/fonts/**/*&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">&quot;/ueditor/**/*&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">&quot;/img/**/*&quot;</span> <span class="attr">security</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">use-expressions</span>=<span class="string">&quot;true&quot;</span> <span class="attr">entry-point-ref</span>=<span class="string">&quot;omsAuthenticationEntryPoint&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logout</span> <span class="attr">logout-url</span>=<span class="string">&quot;/omsmc/authentication/logout/*&quot;</span> <span class="attr">success-handler-ref</span>=<span class="string">&quot;omsLogoutSuccessHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">&#x27;/omsmc/authentication/login*&#x27;</span> <span class="attr">access</span>=<span class="string">&quot;permitAll&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">&#x27;/ms/**/*&#x27;</span> <span class="attr">access</span>=<span class="string">&quot;permitAll&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">&#x27;/**&#x27;</span> <span class="attr">access</span>=<span class="string">&quot;authenticated&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;security:form-login /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">custom-filter</span> <span class="attr">ref</span>=<span class="string">&quot;omsUsernamePasswordAuthenticationFilter&quot;</span> <span class="attr">position</span>=<span class="string">&quot;FORM_LOGIN_FILTER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remember-me</span> <span class="attr">services-ref</span>=<span class="string">&quot;omsRememberMeServices&quot;</span> <span class="attr">key</span>=<span class="string">&quot;yfboms&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">csrf</span> <span class="attr">disabled</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加业务代码，如controller，service，model等，最后生成war包，通过容器进行启动</p>
<h2 id="什么是spring-boot它解决了什么问题">什么是Spring
Boot？它解决了什么问题？</h2>
<p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node.Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring
Boot，它的目的在于<strong>实现自动配置，降低项目搭建的复杂度</strong>，如需要搭建一个接口服务，通过Spring
Boot，几行代码即可实现，请看代码示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入spring-boot-starter-web依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明Spring Boot应用，直接写业务逻辑即可</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockServerApplication</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hi&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;how are you!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MockServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为<code>spring-boot-starter-web</code>模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring
Boot，不是说原来的配置没有了，而是Spring
Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring
Boot遵循的也是<strong>约定优于配置</strong>原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，Spring
Boot一样支持</p>
<p>在Spring
Boot中，你会发现你引入的所有包都是<em>starter</em>形式，如：</p>
<ul>
<li><code>spring-boot-starter-web-services</code>，针对SOAP Web
Services</li>
<li><code>spring-boot-starter-web</code>，针对Web应用与网络接口</li>
<li><code>spring-boot-starter-jdbc</code>，针对JDBC</li>
<li><code>spring-boot-starter-data-jpa</code>，基于hibernate的持久层框架</li>
<li><code>spring-boot-starter-cache</code>，针对缓存支持</li>
<li>等等</li>
</ul>
<p>Spring Boot对starter的解释如下：</p>
<blockquote>
<p>Starters are a set of convenient dependency descriptors that you can
include in your application. You get a one-stop-shop for all the Spring
and related technology that you need, without having to hunt through
sample code and copy paste loads of dependency descriptors. For example,
if you want to get started using Spring and JPA for database access,
just include the spring-boot-starter-data-jpa dependency in your
project, and you are good to go</p>
</blockquote>
<p>这句话的译意为：</p>
<blockquote>
<p>Starters是一系列极其方便的依赖描述，通过在你的项目中包含这些starter，你可以一站式获得你所需要的服务，而无需像以往那样copy各种示例配置及代码，然后调试，真正做到开箱即用；比如你想使用Spring
JPA进行数据操作，只需要在你的项目依赖中引入spring-boot-starter-data-jpa即可</p>
</blockquote>
<h2 id="springspring-mvcspring-boot-三者比较">Spring，Spring MVC，Spring
Boot 三者比较</h2>
<p>其实写到这里，很多读者应该已经清楚，这三者专注的领域不同，解决的问题也不一样；总的来说，Spring
就像一个大家族，有众多衍生产品例如
Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和
AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring
MVC是基于 Servlet 的一个 MVC 框架，主要解决 <strong>WEB
开发</strong>的问题，因为 Spring
的<strong>配置</strong>非常复杂，各种xml，properties处理起来比较繁琐。于是为了<strong>简化</strong>开发者的使用，Spring社区创造性地推出了Spring
Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能，下面用一张图来描述三者的关系：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7XX89U"><img
src="https://s4.ax1x.com/2022/01/27/7XX89U.md.png"
alt="7XX89U.md.png" /></a></p>
<p>最后一句话总结：<strong>Spring MVC和Spring Boot都属于Spring，Spring
MVC 是基于Spring的一个 MVC 框架，而Spring Boot
是基于Spring的一套快速开发整合包</strong>。</p>
<h1 id="springboot-自动装配原理">SpringBoot 自动装配原理</h1>
<p>使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。即使 Spring
后面引入了基于注解的配置，我们在开启某些 Spring
特性或者引入第三方依赖的时候，还是需要用 XML 或 Java 进行显式配置。</p>
<p>举个例子。没有 Spring Boot 的时候，我们写一个 RestFul Web
服务，还首先需要进行如下配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RESTConfiguration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">jsonTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MappingJackson2JsonView</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2JsonView</span>();</span><br><span class="line">        view.setPrettyPrint(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameViewResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">spring-servlet.xml</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">    xmlns:mvc=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/context/ http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/mvc/ http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.howtodoinjava.demo&quot;</span> /&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- JSON Support --&gt;</span><br><span class="line">    &lt;bean name=<span class="string">&quot;viewResolver&quot;</span> class=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>/&gt;</span><br><span class="line">    &lt;bean name=<span class="string">&quot;jsonTemplate&quot;</span> class=<span class="string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>但是，Spring Boot
项目，我们只需要添加相关依赖，无需配置，通过启动下面的 <code>main</code>
方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且，我们通过 Spring Boot 的全局配置文件
<code>application.properties</code>或<code>application.yml</code>即可对项目进行设置比如更换端口号，配置
JPA 属性等等。</p>
<p><strong>为什么 Spring Boot 使用起来这么酸爽呢？</strong>
这得益于其自动装配。<strong>自动装配可以说是 Spring Boot
的核心，那究竟什么是自动装配呢？</strong></p>
<h2 id="什么是-springboot-自动装配">什么是 SpringBoot 自动装配？</h2>
<p>我们现在提到自动装配的时候，一般会和 Spring Boot
联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring
Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</p>
<blockquote>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot
在启动时会扫描外部引用 jar
包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到
Spring 容器（此处涉及到 JVM 类加载机制与 Spring
的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照
SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
</blockquote>
<p>没有 Spring Boot
的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring
Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis
的话，直接在项目中引入对应的 starter 即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入 starter
之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p>
<p>在我看来，自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在
Spring Boot 的帮助下实现某块功能。</strong></p>
<h2 id="springboot-是如何实现自动装配的">SpringBoot
是如何实现自动装配的？</h2>
<p>我们先看一下 SpringBoot 的核心注解 <code>SpringBootApplication</code>
。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line">&lt;<span class="number">1.</span>&gt;<span class="meta">@SpringBootConfiguration</span></span><br><span class="line">&lt;<span class="number">2.</span>&gt;<span class="meta">@ComponentScan</span></span><br><span class="line">&lt;<span class="number">3.</span>&gt;<span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//实际上它也是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概可以把 <code>@SpringBootApplication</code>看作是
<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>
注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><p><code>@EnableAutoConfiguration</code>：启用 SpringBoot
的自动配置机制</p></li>
<li><p><code>@Configuration</code>：允许在上下文中注册额外的 bean
或导入其他配置类</p></li>
<li><p><code>@ComponentScan</code>： 扫描被<code>@Component</code>
(<code>@Service</code>,<code>@Controller</code>)注解的
bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些
bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</p>
<p><a
target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc73490afbe4c6ba62acde6a94ffdfd~tplv-k3u1fbpfcp-watermark.image"><img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc73490afbe4c6ba62acde6a94ffdfd~tplv-k3u1fbpfcp-watermark.image"
alt="img" /></a></p></li>
</ul>
<p><code>@EnableAutoConfiguration</code>
是实现自动装配的重要注解，我们以这个注解入手。</p>
<h3 id="enableautoconfiguration实现自动装配的核心注解"><span
class="citation"
data-cites="EnableAutoConfiguration:实现自动装配的核心注解">@EnableAutoConfiguration:实现自动装配的核心注解</span></h3>
<p><code>EnableAutoConfiguration</code>
只是一个简单地注解，自动装配核心功能的实现实际是通过
<code>AutoConfigurationImportSelector</code>类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所欲组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在重点分析下<code>AutoConfigurationImportSelector</code>
类到底做了什么？</p>
<h3
id="autoconfigurationimportselector加载自动装配类">AutoConfigurationImportSelector:加载自动装配类</h3>
<p><code>AutoConfigurationImportSelector</code>类的继承体系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>AutoConfigurationImportSelector</code> 类实现了
<code>ImportSelector</code>接口，也就实现了这个接口中的
<code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到
IoC 容器中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//&lt;2&gt;.获取所有需要装配的bean</span></span><br><span class="line">            <span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">            AutoConfigurationImportSelector.<span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> <span class="built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法主要负责加载自动配置类的。</p>
<p>该方法调用链如下：</p>
<p><a
target="_blank" rel="noopener" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c1200712655443ca4b38500d615bb70~tplv-k3u1fbpfcp-watermark.image"><img
src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c1200712655443ca4b38500d615bb70~tplv-k3u1fbpfcp-watermark.image"
alt="img" /></a></p>
<p>现在我们结合<code>getAutoConfigurationEntry()</code>的源码来详细分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AutoConfigurationEntry</span> <span class="variable">EMPTY_ENTRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>();</span><br><span class="line"></span><br><span class="line">AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="built_in">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>第 1 步</strong>:</p>
<p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在
<code>application.properties</code> 或 <code>application.yml</code>
中设置</p>
<p><a
target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77aa6a3727ea4392870f5cccd09844ab~tplv-k3u1fbpfcp-watermark.image"><img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77aa6a3727ea4392870f5cccd09844ab~tplv-k3u1fbpfcp-watermark.image"
alt="img" /></a></p>
<p><strong>第 2 步</strong> ：</p>
<p>用于获取<code>EnableAutoConfiguration</code>注解中的
<code>exclude</code> 和 <code>excludeName</code>。</p>
<p><a
target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6ec93bbda1453aa08c52b49516c05a~tplv-k3u1fbpfcp-zoom-1.image"><img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6ec93bbda1453aa08c52b49516c05a~tplv-k3u1fbpfcp-zoom-1.image"
alt="img" /></a></p>
<p><strong>第 3 步</strong></p>
<p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58c51920efea4757aa1ec29c6d5f9e36~tplv-k3u1fbpfcp-watermark.image"><img
src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58c51920efea4757aa1ec29c6d5f9e36~tplv-k3u1fbpfcp-watermark.image"
alt="img" /></a></p>
<p>从下图可以看到这个文件的配置内容都被我们读取到了。<code>XXXAutoConfiguration</code>的作用就是按需加载组件。</p>
<p><a
target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d6e1a060ac41db97043e1758789026~tplv-k3u1fbpfcp-watermark.image"><img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d6e1a060ac41db97043e1758789026~tplv-k3u1fbpfcp-watermark.image"
alt="img" /></a></p>
<p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有
Spring Boot Starter
下的<code>META-INF/spring.factories</code>都会被读取到。</p>
<p>所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter
就创建了<code>META-INF/spring.factories</code>文件。</p>
<p>如果，我们自己要创建一个 Spring Boot
Starter，这一步是必不可少的。</p>
<p><a
target="_blank" rel="noopener" href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68fa66aeee474b0385f94d23bcfe1745~tplv-k3u1fbpfcp-watermark.image"><img
src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68fa66aeee474b0385f94d23bcfe1745~tplv-k3u1fbpfcp-watermark.image"
alt="img" /></a></p>
<p><strong>第 4 步</strong> ：</p>
<p>到这里可能面试官会问你:“<code>spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p>
<p>很明显，这是不现实的。我们 debug
到后面你会发现，<code>configurations</code> 的值变小了。</p>
<p><a
target="_blank" rel="noopener" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/267f8231ae2e48d982154140af6437b0~tplv-k3u1fbpfcp-watermark.image"><img
src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/267f8231ae2e48d982154140af6437b0~tplv-k3u1fbpfcp-watermark.image"
alt="img" /></a></p>
<p>因为，这一步有经历了一遍筛选，<code>@ConditionalOnXXX</code>
中的所有条件都满足，该类才会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span></span><br><span class="line"><span class="comment">// 存在才会加载</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RabbitProperties.class)</span></span><br><span class="line"><span class="meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有兴趣的童鞋可以详细了解下 Spring Boot 提供的条件注解</p>
<ul>
<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean
的情况下</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean
在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li>
<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>
<li><code>@ConditionalOnExpression</code>：基于 SpEL
表达式作为判断条件</li>
<li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
<li><code>@ConditionalOnJndi</code>：在 JNDI
存在的条件下差在指定的位置</li>
<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web
项目的条件下</li>
<li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项
目的条件下</li>
</ul>
<h1
id="mybatis的一级二级缓存有什么区别">mybatis的一级二级缓存有什么区别</h1>
<ol type="1">
<li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis
Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h1 id="mybatisibatis中和的区别">MyBatis/Ibatis中#和$的区别</h1>
<ol type="1">
<li>#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order
by #user_id#，如果传入的值是111,那么解析成sql时的值为order by "111",
如果传入的值是id，则解析成的sql为order by "id".</li>
<li>$将传入的数据直接显示生成在sql中。如：order by <span
class="math inline">\(user_id\)</span>，如果传入的值是111,那么解析成sql时的值为order
by user_id, 如果传入的值是id，则解析成的sql为order by id.</li>
<li>#方式能够很大程度防止sql注入；$方式无法防止Sql注入。</li>
<li>$方式一般用于传入数据库对象，例如传入表名.</li>
</ol>
<p><strong>一般能用#的就别用$.</strong></p>
<h1 id="spring的注入方式有哪些">spring的注入方式有哪些</h1>
<p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：<strong>构造方法注入，setter注入，基于注解的注入。</strong></p>
<h1 id="jwt实现单点登录及流程描述">JWT实现单点登录及流程描述</h1>
<h2 id="什么是单点登录">什么是单点登录</h2>
<p>所谓单点登录就是有多个应用部署在不同的服务器上，只需登录一次就可以互相访问不同服务器上的资源。</p>
<h2 id="单点登录流程">单点登录流程</h2>
<figure>
<img
src="https://img.jbzj.com/file_images/article/202007/202007011004048.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>当一个访问请求发给应用A，如果这个请求需要登录以后才能访问，那么应用A就会向认证服务器请求授权，这时候就把用户引导到认证服务器上。用户在认证服务器上完成认证并授权。认证授权完成后，认证服务器返回给应用A一个授权码，应用A携带授权码到认证服务器请求令牌，认证服务器返回应用A一个JWT，应用A解析JWT里面的信息，完成登录。这是一个标准的OAuth2的授权码流程。</p>
<p>走完认证流程后，给出去的JWT实际上里面包含的就是当前用户在认证服务器上登录以后用户的认证信息，应用A解析JWT后，自己生成一个经过认证的Authentication放到它的SpringSecurity和SecurityContext里面。</p>
<p>当访问应用服务器B的时候，同样引导用户去认证服务器请求授权（不需要登录），用户授权可以用登录的信息去访问应用B，后面同样是授权码流程，返回JWT给应用B。两个应用返回不同的JWT，但是解析出的信息是一样的。</p>
<h1 id="springmvc处理一个http请求">SpringMVC处理一个HTTP请求</h1>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bMdZpF"><img
src="https://s4.ax1x.com/2022/02/28/bMdZpF.md.png"
alt="bMdZpF.md.png" /></a></p>
<ol type="1">
<li>客户端发送HTTP请求到指定的URL；</li>
<li>Spring MVC的<code>DispatcherServlet</code>接收到请求；</li>
<li>DispatcherServlet把请求传到用@Controller和<span class="citation"
data-cites="RequestMapping注解的">@RequestMapping注解的</span><code>controller</code>；</li>
<li>Spring
MVC返回<strong>逻辑视图</strong>的名称和模型给DispatcherServlet；</li>
<li>DispatcherServlet咨询<strong>视图处理器</strong>直到有实际的视图来展示数据为止；</li>
<li>DispatcherServlet使用<strong>模型数据</strong>联系所选的视图，例如Thymeleaf,Freemarker,JSP,并<strong>根据数据模型呈现输出</strong>；</li>
<li>呈现的输出作为响应返回给客户端。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="计算机网络">
      <i class="fa fa-chevron-left"></i> 计算机网络
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="设计模式">
      设计模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">Spring框架的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E6%A1%86%E6%9E%B6%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.1.</span> <span class="nav-text">Spring框架的好处？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">Spring框架的缺点？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">Spring中有两个重要特性是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#aop%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">2.1.</span> <span class="nav-text">AOP是怎么实现的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk%E4%BB%A3%E7%90%86%E5%92%8Ccglib%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.</span> <span class="nav-text">JDK代理和Cglib代理的区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.</span> <span class="nav-text">Spring Bean 的生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%B8%ADbean%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.</span> <span class="nav-text">Spring中bean有哪些作用域？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E9%97%AE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">4.0.1.</span> <span class="nav-text">追问：单例模式是线程安全的吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">Spring中有哪些常见的注解？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springboot%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-number">6.</span> <span class="nav-text">SpringBoot的常用注解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#xml%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B3%A8%E8%A7%A3%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">XML配置和注解之间有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text">Spring支持的事务管理类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">9.</span> <span class="nav-text">Spring
事务中的隔离级别有哪几种?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E4%B8%80%E6%A0%B7"><span class="nav-number">10.</span> <span class="nav-text">spring的事务是什么？与数据库的事务是否一样</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFioc%E5%92%8Cdidi%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">11.</span> <span class="nav-text">什么是IoC和DI？DI是如何实现的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#transactional%E6%B3%A8%E8%A7%A3"><span class="nav-number">11.1.</span> <span class="nav-text">@Transactional注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0%E6%9C%AC%E8%B4%A8"><span class="nav-number">11.2.</span> <span class="nav-text">声明式事务的管理实现本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="nav-number">11.3.</span> <span class="nav-text">spring事务特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#transactional-%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">11.4.</span> <span class="nav-text">@Transactional 属性配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1"><span class="nav-number">11.5.</span> <span class="nav-text">嵌套事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E8%A7%84%E5%88%99"><span class="nav-number">11.6.</span> <span class="nav-text">spring事务回滚规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">11.7.</span> <span class="nav-text">注意事项：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">11.8.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springmvc%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text">SpringMVC：拦截器和过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%87%E6%BB%A4%E5%99%A8filter"><span class="nav-number">12.1.</span> <span class="nav-text">什么是过滤器(Filter)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">12.1.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">12.2.</span> <span class="nav-text">什么是拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">12.2.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BA%8E%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="nav-number">12.3.</span> <span class="nav-text">拦截器于过滤器对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E6%89%A7%E8%A1%8C%E5%9B%BE"><span class="nav-number">12.4.</span> <span class="nav-text">案例执行图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springspringmvc-springboot%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">Spring、SpringMVC
、Springboot的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFspring%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">13.1.</span> <span class="nav-text">什么是Spring？它解决了什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFspring-mvc%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">13.2.</span> <span class="nav-text">什么是Spring
MVC？它解决了什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFspring-boot%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">13.3.</span> <span class="nav-text">什么是Spring
Boot？它解决了什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springspring-mvcspring-boot-%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83"><span class="nav-number">13.4.</span> <span class="nav-text">Spring，Spring MVC，Spring
Boot 三者比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springboot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="nav-number">14.</span> <span class="nav-text">SpringBoot 自动装配原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-springboot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">14.1.</span> <span class="nav-text">什么是 SpringBoot 自动装配？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springboot-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84"><span class="nav-number">14.2.</span> <span class="nav-text">SpringBoot
是如何实现自动装配的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#enableautoconfiguration%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">14.2.1.</span> <span class="nav-text">@EnableAutoConfiguration:实现自动装配的核心注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autoconfigurationimportselector%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%B1%BB"><span class="nav-number">14.2.2.</span> <span class="nav-text">AutoConfigurationImportSelector:加载自动装配类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">15.</span> <span class="nav-text">mybatis的一级二级缓存有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mybatisibatis%E4%B8%AD%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">MyBatis&#x2F;Ibatis中#和$的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">17.</span> <span class="nav-text">spring的注入方式有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jwt%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="nav-number">18.</span> <span class="nav-text">JWT实现单点登录及流程描述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="nav-number">18.1.</span> <span class="nav-text">什么是单点登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="nav-number">18.2.</span> <span class="nav-text">单点登录流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springmvc%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82"><span class="nav-number">19.</span> <span class="nav-text">SpringMVC处理一个HTTP请求</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

