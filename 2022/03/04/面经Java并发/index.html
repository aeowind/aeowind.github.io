<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这是一个没有营养的晚上，在严重缺乏维他命B及维他命C的情况下，我开始不停地想念你">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJava%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="这是一个没有营养的晚上，在严重缺乏维他命B及维他命C的情况下，我开始不停地想念你">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.458Z">
<meta property="article:modified_time" content="2022-03-09T09:50:42.269Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJava%E5%B9%B6%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发 | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJava%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-09 17:50:42" itemprop="dateModified" datetime="2022-03-09T17:50:42+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">这是一个没有营养的晚上，在严重缺乏维他命B及维他命C的情况下，我开始不停地想念你</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1
id="深入图解aqs实现原理和源码分析">深入图解AQS实现原理和源码分析</h1>
<p>AQS底层实现原理用一句话总结就是：<strong>volatile + CAS +
一个虚拟的FIFO双向队列(CLH队列)。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#名词解释</span><br><span class="line">（1）CAS：无锁的策略使用一种比较交换的技术（Compare And Swap）来鉴线程修改冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。</span><br><span class="line">（2）AQS：AbstractQuenedSynchronizer抽象的队列式同步器，主要提供了一些锁操作的模板方法。J.U.C都是基于AQS实现的。</span><br></pre></td></tr></table></figure>
<h2 id="cas底层原理">CAS底层原理</h2>
<p>java中CAS操作都是通过Unsafe类实现的，Unsafe类是在sun.misc包下，不属于Java标准，但是<strong>很多Java基础类库的CAS操作都是使用Unsafe。</strong>包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Hadoop、Kafka等。</p>
<p>使用Unsafe的CAS进行一个变量进行修改，实质是直接操作变量的内存地址来实现的，CPU需要通过寻找变量的物理地址来读取或修改变量。那么我们需要先了解一下CPU是怎么寻址物理地址的，这会涉及到计算机底层的段地址、偏移量和逻辑地址(即物理地址)相关概念，下面以8086
CPU处理器为例来讲解。</p>
<h3 id="段地址偏移量和逻辑地址关系">段地址、偏移量和逻辑地址关系</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#段地址、偏移量和逻辑地址(即物理地址)的关系：</span><br><span class="line">（1）关系：8086 CPU的逻辑地址由段地址和段内偏移量两部分组成</span><br><span class="line">    物理地址 = 段地址*16 + offset偏移量。</span><br><span class="line"> </span><br><span class="line">（2）段地址</span><br><span class="line">    8086 CPU能提供20位的地址信息，可直接对1M(1M = 1024 * 1024 = 2^20)个存储单元进行访问，而CPU内部可用来</span><br><span class="line">    提供地址信息的寄存器都是16位，那怎样用16位寄存器来实现20位地址寻址呢? 8086 CPU的20位的地址信息可以对1M个内存单元进行访问，</span><br><span class="line">    也就是说编址00000H~FFFFFH，而段寄器CS，DS，SS，ES即存放了这些地址的高4位。</span><br><span class="line">    如：123456H，则某个段寄存器便会存储1234H高4位信息，这即为段地址。</span><br><span class="line"> </span><br><span class="line">（3）偏移量：段内偏移地址就是移动后相对于段地址的偏移量。</span><br><span class="line"> </span><br><span class="line">（4）逻辑地址(物理地址):物理地址就是地址总线上提供的20位地址信息。</span><br><span class="line">    物理地址 = 段地址*10H + 段内偏移地址。段地址乘以10H是因为段地址当时是取高四位得到的，</span><br><span class="line">    所以还原后要让段地址左移4位（10H = 10000B）。</span><br><span class="line"> </span><br><span class="line">例如：（cs）= 20A8H，（offset）=2008H，则物理地址为20A8H*10H+2008H = 22A88H。</span><br></pre></td></tr></table></figure>
<h3 id="unsafe中cas实现原理">Unsafe中CAS实现原理</h3>
<p>Unsafe的CAS操作方法基本都是native方法，具体的实现是由C实现的，下面以<code>compareAndSwapInt()</code>方法为例看看处理器低层是怎么实现CAS操作的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#1.源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> final native boolean <span class="title">compareAndSwapInt</span>(<span class="params">Object o,<span class="built_in">long</span> offset,<span class="built_in">int</span> expect,<span class="built_in">int</span> update</span>)</span></span><br><span class="line"><span class="function">#2.调用：该方法一般的调用形式是：<span class="built_in">object</span>对象传的是<span class="keyword">this</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsafe</span>.<span class="title">compareAndSwapInt</span>(<span class="params"><span class="keyword">this</span>, Offset, expect, update</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>CAS操作的比较原理</strong>：</p>
<ol type="1">
<li>CPU的寻址方式：处理器会找到this寄存器cs里的段地址，通过段地址*16 +
Offset偏移量得到物理地址。</li>
<li>将物理地址处的存储值 和
期望值expect比较，如果相等，则进行update操作后返回true；不相等返回false。</li>
<li>比较操作 和
更新赋值操作是原子进行的，CPU处理器是通过lock锁实现的(总线锁和缓存锁)。</li>
</ol>
<p><strong>CAS操作在intel X86处理器的源代码的片段</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest,jint compare_value)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov edx, dest</span><br><span class="line">        mov ecx, exchange_value</span><br><span class="line">        mov eax, compare_value</span><br><span class="line">        #程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀，lock锁的实现：总线锁和缓存锁</span><br><span class="line">        <span class="built_in">LOCK_IF_MP</span>(mp)</span><br><span class="line">        cmpxchg dword ptr [edx], ecx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CAS操作指令解析</strong></p>
<ol type="1">
<li>is_MP()函数判断当前处理器是多核，还是单核。</li>
<li>如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（Lock
Cmpxchg）。如果程序是在单处理器上运行，就省略lock前缀。</li>
</ol>
<p><strong>intel处理器lock前缀作用</strong></p>
<ol type="1">
<li>确保对内存的读-改-写操作原子执行。处理器会使用总线锁 或
缓存锁来保持原子性。</li>
<li>禁止该指令，与之前和之后的读和写指令重排序。</li>
<li>把CPU写缓冲区中的所有数据刷新到内存中，使其它CPU缓存失效。</li>
</ol>
<h2 id="aqs实现原理">AQS实现原理</h2>
<p><strong>AQS</strong>全称为<code>AbstractQueuedSynchronizer</code>，<strong>AQS定义了一套多线程访问共享资源的同步器框架，为java并发同步组件提供统一的底层支持。</strong>常见的有:Lock、ReentrantLock、ReentrantReadWriteLock、CyclicBarrier、CountDownLatch、ThreadPoolExecutor等都是基于AQS实现的。</p>
<p><strong>AQS</strong>是一个抽象类，主要是通过继承的方式实现其模版方法，它本身没有实现任何的同步接口，仅仅是定义了同步状态的获取以及释放的方法来提供自定义的同步组件。</p>
<h3 id="aqs的独占锁和共享锁">AQS的独占锁和共享锁</h3>
<p><strong>独占锁</strong>：每次只能有一个线程持有锁，比如ReentrantLock就是以独占方式实现的互斥锁。</p>
<p><strong>共享锁</strong>：允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock。</p>
<h3 id="aqs内部实现">AQS内部实现</h3>
<p><strong>AQS的实现依赖内部的FIFO双向队列同步(只是一个虚拟的双向队列)和共享锁state变量</strong>。当线程竞争锁(state变量)失败时，那么AQS会把当前线程以及等待状态信息构造成一个<code>Node</code>加入到同步队列中，同时再阻塞该线程；当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。
AQS具体实现如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7rmHVs"><img
src="https://s4.ax1x.com/2022/01/19/7rmHVs.md.png"
alt="7rmHVs.md.png" /></a></p>
<ul>
<li><p><strong>AQS底层实现原理</strong> <strong>volatile + CAS +
一个虚拟的FIFO双向队列(CLH队列)</strong>。</p></li>
<li><p><strong>AQS同步队列特点</strong>：</p>
<ul>
<li>AQS同步队列内部维护的是一个FIFO的双向链表，双向链表可以从任意一个节点开始很方便的访问前驱和后继。</li>
<li>添加节点：每个Node其实是由线程封装的(node里面包含一个thread变量)，当线程竞争锁失败后会封装成Node加入到AQS同步队列尾部。</li>
<li>移除节点：AQS同步队列中每个node都在等待同一个资源(锁状态state变量)释放，锁释放后每次只有队列的第二个节点(head的后继节点)才有机会抢占锁，如果成功获取锁，则此节点晋升为头节点。</li>
</ul></li>
</ul>
<h1 id="线程之间为什么是不可见的">线程之间为什么是不可见的</h1>
<p>关于线程之间为什么是不可见的，谈到这个问题时我觉得有必要先了解一下线程执行时的一个内存空间；在Java中每一个的线程都有一块独立的内存空间，俗称线程工作区，当它们去执行临界区的资源（共享资源）时，都会先去主内存将共享资源复制一份到自己的工作内存中再进行操作，最后再把操作完的副本写入到主内存中；看似表面上是直接操作了共享资源，其实实际上是操作了共享资源的副本；</p>
<p>线程内存之间的关系图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TP6hjK"><img
src="https://s4.ax1x.com/2021/12/16/TP6hjK.md.png"
alt="TP6hjK.md.png" /></a></p>
<p>线程运行时的具体流程：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TPcB8I"><img
src="https://s4.ax1x.com/2021/12/16/TPcB8I.md.png"
alt="TPcB8I.md.png" /></a></p>
<p>因为线程每次执行时都是要先拿取资源的副本，再在自己的工作内存里进行操作，最后再写入到主内存资源中；那这时容易出现一种情况，例如当多个线程要修改同一资源时，一个线程优先去复制了资源在自己内存进行操作时，突然某一线程趁机也偷偷的把资源复制到自己工作内存中操作，这时原先的那个先执行的线程执行完了操作把副本内容写入了主内存中时，偷偷摸摸的那个线程也跟着执行完了把结果写入到了主内存后，最后导致将原先执行的线程写入的结果给覆盖了，在这种情况下时我们就可以称之为<strong>线程之间的不可见</strong>
。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TP2nh9"><img
src="https://s4.ax1x.com/2021/12/16/TP2nh9.md.png"
alt="TP2nh9.md.png" /></a></p>
<h1
id="在项目开发中的遇到的并发问题是怎么解决的">在项目开发中的遇到的并发问题是怎么解决的</h1>
<h2 id="相关概念">相关概念</h2>
<p><strong>并发</strong>：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行；在互联网时代，所讲的并发，高并发通常是指并发访问，也就是在某个时间点，有多少个访问同时到来。通常一个系统的日PV在千万以上，有可能是一个高并发的系统。有的公司完全不走技术路线，全靠机器堆，这不在讨论范围内。</p>
<ul>
<li><p><strong>QPS</strong>
：<code>每秒钟请求或者查询的数量</code>，在互联网领域，指每秒响应请求数(指HTTP请求)；并发连接数是系统同时处理的请求数量。</p></li>
<li><p><strong>吞吐量</strong>：<code>单位时间内处理的请求数量</code>(通常由QPS与并发数决定)。</p></li>
<li><p><strong>响应时间</strong>：<code>从请求发出到收到响应花费的时间</code>。例如系统处理一个HTTP请求需要100ms。</p></li>
<li><p><strong>PV</strong>：综合浏览量(page
view)，<code>即页面浏览量或者点击量</code>，一个访客在24小时内访问的页面数量；同一个人浏览网站同一页面，只记作一次PV。</p></li>
<li><p><strong>UV</strong>：独立访客(unique
visitor)，即<code>一定时间范围内相同访客多次访问网站</code>，只计算为一个独立访客。</p></li>
<li><p><strong>带宽</strong>：计算带宽大小需关注两个指标，峰值流量和页面的平均大小。</p></li>
</ul>
<p>　　日网站带宽=PV/统计时间(换算到s)<em>平均页面大小(单位KB)</em>8；峰值一般是平均值的倍数，根据实际情况来定</p>
<p>　　峰值每秒请求数(QPS)=(总PV数<em>80%)/(6小时秒数</em>20%)；80%的访问量集中在20%的时间</p>
<ul>
<li><strong>压力测试</strong>：测试能承受的最大并发，测试最大承受的QPS值</li>
</ul>
<p><strong>QPS达到极限</strong>：随着QPS的增长，每个阶段需要根据实际情况来进行优化，优化的方案也与硬件条件、网络带宽息息相关；</p>
<p>QPS达到50，可以称之为小型网站，一般的服务器就可以应付；</p>
<p>QPS达到100，假设关系型数据库的每次请求在0.01s完成，假设单页面只有一个SQL查询，那么100QPS意味着1s完成100次请求，但是此时并不能保证数据库查询能完成100次，数据库缓存层，数据库的负载均衡；</p>
<p>QPS达到800，假设使用百兆带宽，意味着网站出口的实际带宽是8M左右，假设每个页面只有10k，在这个并发条件下，百兆带宽已经吃完，CDN加速，负载均衡；</p>
<p>QPS达到1000，假设使用memcache缓存数据库查询数据，每个页面对memcache的请求远大于直接对db的请求，memcache的悲观并发数在2w左右，但有可能在之前内网带宽已经吃光，表现出不稳定，静态HTML缓存；</p>
<p>QPS达到2000，这个级别下，文件系统访问锁都成为了灾难，做业务分离，分布式存储高并发解决方案案例。</p>
<p><strong>高并发解决方案案例：</strong></p>
<ul>
<li><p><strong>流量优化</strong>：防盗链处理<a
href="防盗链">https://blog.csdn.net/linshichen/article/details/51679074</a></p></li>
<li><p><strong>前端优化</strong>：减少HTTP请求，合并css或js，添加异步请求，启用浏览器缓存和文件压缩，CDN加速，建立独立图片服务器，</p></li>
<li><p><strong>服务端优化</strong>：页面静态化，并发处理，队列处理</p></li>
<li><p><strong>数据库优化</strong>：数据库缓存，分库分表，分区操作，读写分离，负载均衡</p></li>
<li><p><strong>web服务器优化</strong>：负载均衡，nginx反向代理，7,4层LVS软件</p></li>
</ul>
<h2 id="核心问题">核心问题</h2>
<p><strong>并发问题核心是如何解决慢和等，核心一个是短，一个是少，一个是分流。</strong></p>
<p><code>短是指路径要短</code>。典型的mvc结构是<code>请求-&gt;controller-&gt;model-&gt;dao-&gt;view</code>，然后把页面返回给用户。要想短的话，</p>
<ol type="1">
<li><p><strong>页面静态化</strong>-
用户可以直接获取页面，不用走那么多流程，比较适用于页面不频繁更新。</p></li>
<li><p><strong>使用缓存</strong>-
第一次获取数据从数据库中提取，然后保存在缓存中，以后就可以直接从缓存提取数据。不过需要有机制维持缓存和数据库的一致性。</p></li>
<li><p><strong>批量读取</strong> -
高并发情况下，可以把多个请求的查询合并到一次进行，以减少数据库的访问次数。</p></li>
<li><p><strong>延迟修改</strong> -
高并发情况下，可以把多次修改请求，先保存在缓存中，然后定时将缓存中的数据保存到数据库中，风险是可能会断电丢失缓存中的数据。</p></li>
<li><p><strong>使用索引</strong> -
索引可以看作是特殊的缓存，尽量使用索引就要求where字句中精确的给出索引列的值。</p></li>
</ol>
<p><code>少是指查询的数据要少</code></p>
<ol type="1">
<li><p><strong>分表</strong> -
把本来同一张表的内容，可以按照地区，类别等分成多张表，很简单的一个思路，但是要尽量避免分出来的多表关联查询。</p></li>
<li><p><strong>分离活跃数据</strong> -
例如登录用户业务，注册用户很多，但是活跃的登录用户很少，可以把活跃用户专门保存一张表，查询是先查询活跃表，没有的话再查总表，这也类似于缓存。</p></li>
</ol>
<p><code>分流就是将原有的一个并发的流进行拆分</code></p>
<ol type="1">
<li><p>微服务</p></li>
<li><p>分布式</p></li>
<li><p>负载均衡</p></li>
</ol>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37788067/article/details/79250623">https://blog.csdn.net/qq_37788067/article/details/79250623</a></p>
<ol start="4" type="1">
<li>读写分离（主从复制）</li>
</ol>
<p>核心最重点：<strong>分流</strong></p>
<h1
id="实现多线程的方式两个线程交替执行">实现多线程的方式，两个线程交替执行</h1>
<blockquote>
<p><strong>问题</strong>: 线程A向一个map中存数据,
然后线程B从map中取数据, 循环这个过程, 最终效果像: 线程A存入1,
线程B取出1, 线程A存入2, 线程B取出2, 线程A存入3, 线程B取出3…
直到线程A存入100, 线程B取出100。</p>
</blockquote>
<p>问题的要求非常像生产者消费者模式, 但是有个很大的区别,
那就是生产者的生产和消费者的消费没有顺序要求,
但是这道题要求线程A和线程B轮流执行。</p>
<p><strong>考察点: 如何让两个线程轮流执行</strong></p>
<p>下面写了五个例子 前三个例子使用了<strong>阻塞+唤醒</strong>的思路,
涉及用户态和内核态的切换, 效率偏低,
但是CPU压力小；后两个例子使用了<strong>vaolatile+CAS</strong>,
不能操作时通过自旋进行等待, 更高效, 但是CPU压力大。</p>
<ul>
<li><strong>方法一: 使用synchronized修饰函数</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程B的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">this</span>.notify(); <span class="comment">//等待队列中只有一个线程, 所以不用使用notifyAll()</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> map.get(i - <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + cur);</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//最多等待1s, 等待1s后没被唤醒则自己醒过来</span></span><br><span class="line">                <span class="comment">//因为最后一次循环时, 当前方法让出CPU后, 再也不会被唤醒了</span></span><br><span class="line">                <span class="built_in">this</span>.wait(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">Thread-0  97</span></span><br><span class="line"><span class="comment">Thread-1  97</span></span><br><span class="line"><span class="comment">Thread-0  98</span></span><br><span class="line"><span class="comment">Thread-1  98</span></span><br><span class="line"><span class="comment">Thread-0  99</span></span><br><span class="line"><span class="comment">Thread-1  99</span></span><br><span class="line"><span class="comment">Thread-0  100</span></span><br><span class="line"><span class="comment">Thread-1  100</span></span><br><span class="line"><span class="comment">Thread-0执行完毕</span></span><br><span class="line"><span class="comment">Thread-1执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>方法二: 使用synchronized代码块</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">100</span>; k++)&#123;</span><br><span class="line">                map.put(i,i);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">100</span>; k++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> map.get(i-<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + cur);</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//最后一次wait()后, 不会被唤醒, 所以需要设置最长阻塞时间</span></span><br><span class="line">                    <span class="built_in">this</span>.wait(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">Thread-0  97</span></span><br><span class="line"><span class="comment">Thread-1  97</span></span><br><span class="line"><span class="comment">Thread-0  98</span></span><br><span class="line"><span class="comment">Thread-1  98</span></span><br><span class="line"><span class="comment">Thread-0  99</span></span><br><span class="line"><span class="comment">Thread-1  99</span></span><br><span class="line"><span class="comment">Thread-0  100</span></span><br><span class="line"><span class="comment">Thread-1  100</span></span><br><span class="line"><span class="comment">Thread-0执行完毕</span></span><br><span class="line"><span class="comment">Thread-1执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>方法三: 使用ReentrantLock+Condition;
因为synchronized能实现的功能ReentrantLock也能实现</strong></li>
</ul>
<p>起初想使用ReentrantLock的公平锁模式,
按照线程进入AQS等待队列的顺序获取锁, 这样就不用Condition了,
不过运行时有问题, 线程A启动后, 执行了好几次循环, 线程B才开始执行,
这样就没法保证轮流执行了</p>
<p><strong>使用注意事项</strong>: Condition的signal(), signalAll(),
await()方法必须在ReentrantLock的lock()和unlock()之间使用，否则报错:IllegalMonitorStateException，这跟wait(),
notify(), notifyAll()一定要在synchronized块内执行是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">con</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                map.put(i, i);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                con.signal();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    con.await(); <span class="comment">//让出锁, 但是state应该不变, state应该由lock控制, 并不是con来控制</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> map.get(i - <span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + cur);</span><br><span class="line">                con.signal();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">	                <span class="comment">//最后一次让出锁后, 无法被唤醒, 所以需要定时</span></span><br><span class="line">                    con.await(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0  97</span></span><br><span class="line"><span class="comment">Thread-1  97</span></span><br><span class="line"><span class="comment">Thread-0  98</span></span><br><span class="line"><span class="comment">Thread-1  98</span></span><br><span class="line"><span class="comment">Thread-0  99</span></span><br><span class="line"><span class="comment">Thread-1  99</span></span><br><span class="line"><span class="comment">Thread-0  100</span></span><br><span class="line"><span class="comment">Thread-0执行完毕</span></span><br><span class="line"><span class="comment">Thread-1  100</span></span><br><span class="line"><span class="comment">Thread-1执行完毕</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>方法四: 使用Unsafe类的CAS操作, 不能操作时便自旋;
不涉及线程的阻塞与唤醒, 更高效</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//使用volatile保证flag在两个线程中的可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//0表示线程0可以执行, 1表示线程1可以执行</span></span><br><span class="line"><span class="comment">//    private static final Unsafe unsafe = Unsafe.getUnsafe(); //直接这么用会报错</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> flagOffset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处, try catch必须放到代码块中!</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unsafe = getUnsafeInstance();</span><br><span class="line">            <span class="comment">//获取flag的偏移量, 为CAS操作做准备</span></span><br><span class="line">            <span class="comment">//getDeclaredField()与getField</span></span><br><span class="line">            flagOffset = unsafe.objectFieldOffset(MyTest.class.getDeclaredField(<span class="string">&quot;flag&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line"><span class="comment">//            throw new Error(e);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;初始化flagOffset失败&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;初始化unsafe失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取unsafe实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafeInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 通过反射获取rt.jar下的Unsafe类</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">theUnsafeInstance</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafeInstance.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// return (Unsafe) theUnsafeInstance.get(null);是等价的</span></span><br><span class="line">        <span class="keyword">return</span> (Unsafe) theUnsafeInstance.get(Unsafe.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">            <span class="comment">//自旋; 等待flag为true</span></span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> flag;</span><br><span class="line">            <span class="comment">//使用CAS赋值</span></span><br><span class="line">            unsafe.compareAndSwapInt(<span class="built_in">this</span>, flagOffset, tmp, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> map.get(i - <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + cur);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> flag;</span><br><span class="line">            unsafe.compareAndSwapInt(<span class="built_in">this</span>, flagOffset, tmp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">Thread-0  97</span></span><br><span class="line"><span class="comment">Thread-1  97</span></span><br><span class="line"><span class="comment">Thread-0  98</span></span><br><span class="line"><span class="comment">Thread-1  98</span></span><br><span class="line"><span class="comment">Thread-0  99</span></span><br><span class="line"><span class="comment">Thread-1  99</span></span><br><span class="line"><span class="comment">Thread-0  100</span></span><br><span class="line"><span class="comment">Thread-1  100</span></span><br><span class="line"><span class="comment">Thread-0执行完毕</span></span><br><span class="line"><span class="comment">Thread-1执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>方法五: 使用AtomicInteger; 不能操作时便自旋</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//充当线程A的角色</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);<span class="comment">//0表示线程0可以执行, 1表示线程1可以执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">100</span>; k++)&#123;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="keyword">if</span>((flag.intValue()&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(i,i);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">            flag.compareAndSet(flag.intValue(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">100</span>; k++)&#123;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="keyword">if</span>((flag.intValue()&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> map.get(i-<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + cur);</span><br><span class="line">            flag.compareAndSet(flag.intValue(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行结果</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">Thread-1  97</span></span><br><span class="line"><span class="comment">Thread-0  98</span></span><br><span class="line"><span class="comment">Thread-1  98</span></span><br><span class="line"><span class="comment">Thread-0  99</span></span><br><span class="line"><span class="comment">Thread-1  99</span></span><br><span class="line"><span class="comment">Thread-0  100</span></span><br><span class="line"><span class="comment">Thread-1  100</span></span><br><span class="line"><span class="comment">Thread-1执行完毕</span></span><br><span class="line"><span class="comment">Thread-0执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1
id="线程的三种创建方式和他们的优缺点">线程的三种创建方式和他们的优缺点</h1>
<h2 id="线程的三种创建方式">线程的三种创建方式</h2>
<p><strong>继承Thread类方式</strong></p>
<p>创建一个类继承Thread类，重写run()方法，在主线程中创建此类的对象，调用对象的start()方法，可启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mt.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;aaaaa&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现Runnable接口</strong></p>
<p>创建一个类实现Runnable接口，在主线程中创建这个类的对象实例，新创建一个线程并调用start()方法启动线程，需要先将实现Runnable接口的类的对象当做参数传给这个新的线程，这样就实现了线程的启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">newThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">newThread</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(thread).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">newThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bbbb&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现Callable接口</strong></p>
<p>可以和使用实现<code>Runnable接口方式</code>创建线程方式比较，<strong>就是相当于多包装了一层</strong>，原来将Runnable对象直接丢到new
Thread()中，也就是传入目标对象后调用start()方法启动线程，现在是不仅要创建实现Callable接口的对象，还需要util包下的concurrent下的FutureTask，创建FutureTask对象时需要传入实现Callable接口的对象到构造方法中，将FutureTask对象作为Thread的目标对象启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">callableThread</span> <span class="variable">ct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">callableThread</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(ct);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">callableThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三种创建方式优缺点">三种创建方式优缺点</h2>
<blockquote>
<p>使用实现Runnable接口比使用继承Thread具有的优势</p>
</blockquote>
<ol type="1">
<li>通过创建任务，然后给线程分配的方式实现多线程，更适合多个线程同时执行相同的任务的情况；</li>
<li>可以避免单继承所带来的局限性；</li>
<li>任务与线程本身是分离的，提高了程序的健壮性；</li>
<li>线程池接受Runnable类型，不接受Thread类型。</li>
</ol>
<ul>
<li><strong>使用Thread类</strong>
<ul>
<li>优点：编写相对简单，访问当前线程直接使用this就可以获得当前线程。</li>
<li>缺点：由于线程类已经继承了Thread类，所以不能再继承其他的父类。</li>
</ul></li>
<li><strong>使用Runnable接口</strong>
<ul>
<li>优点：没有继承Thread类，所以可以继承其他的类，<strong>适合多线程访问同一资源的情况</strong>，将cpu和数据分开，形成清晰的模型，较好的体现了面向对象的思想</li>
<li>缺点：编程相对复杂，要想获得当前线程对象，需要使用Thread.currentThread()方法。</li>
</ul></li>
<li><strong>使用callable接口</strong>
<ul>
<li>优点：也可以继承其他的类，<strong>多线程可以共享同一个target对象</strong>，适合多线程访问同一资源的情况，将cpu和数据分开，形成清晰的模型，较好的体现了面向对象的思想，还有返回值</li>
<li>缺点：编程稍显复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</li>
</ul></li>
</ul>
<h1
id="关于java线程池关键参数拒绝策略调度方式">关于JAVA线程池关键参数，拒绝策略，调度方式</h1>
<h2 id="线程池核心参数">线程池核心参数</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>参数</strong></th>
<th style="text-align: center;"><strong>类型</strong></th>
<th style="text-align: center;"><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">corePoolSize</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">核心线程数</td>
</tr>
<tr class="even">
<td style="text-align: center;">maximumPoolSize</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">最大并行线程数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">keepAliveTime</td>
<td style="text-align: center;">long</td>
<td style="text-align: center;">非核心线程最大存活时间</td>
</tr>
<tr class="even">
<td style="text-align: center;">unit</td>
<td style="text-align: center;">TimeUnit</td>
<td style="text-align: center;">描述存活时间的单位</td>
</tr>
<tr class="odd">
<td style="text-align: center;">workQueue</td>
<td style="text-align: center;">BlockingQueue</td>
<td style="text-align: center;">存放任务阻塞队列</td>
</tr>
<tr class="even">
<td style="text-align: center;">threadFactory</td>
<td style="text-align: center;">ThreadFactory</td>
<td style="text-align: center;">线程工厂</td>
</tr>
<tr class="odd">
<td style="text-align: center;">handler</td>
<td style="text-align: center;">RejectedExecutionHandler</td>
<td style="text-align: center;">拒绝策略</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>corePoolSize（线程池的基本大小）：</strong></li>
</ul>
<ol type="1">
<li>提交一个任务到线程池时，线程池会创建一个新的线程来执行任务。<strong>注意：</strong>
即使有<code>空闲的基本线程</code> 能执行该任务，也会创建新的线程。</li>
<li>如果线程池中的线程数已经大于或等于<code>corePoolSize</code>，则不会创建新的线程。</li>
<li>如果调用了线程池的<code>prestartAllCoreThreads()方法</code>，线程池会<code>提前创建并启动所有基本线程</code>。</li>
</ol>
<ul>
<li><strong>maximumPoolSize（线程池的最大数量）：</strong>
线程池允许创建的最大线程数。</li>
</ul>
<ol type="1">
<li>阻塞队列已满，线程数小于<code>maximumPoolSize</code>便可以创建新的线程执行任务。</li>
<li>如果<strong>使用无界的阻塞队列</strong>，<code>该参数没有什么效果</code>。</li>
</ol>
<ul>
<li><strong>workQueue（工作队列）：</strong>
用于保存等待执行的任务的阻塞队列。</li>
</ul>
<ol type="1">
<li><code>ArrayBlockingQueue：</code>
基于数组结构的<strong>有界阻塞队列</strong>，按<strong>FIFO（先进先出）原则</strong>对任务进行排序。使用该队列，线程池中能创建的最大线程数为<code>maximumPoolSize</code>。</li>
<li><code>LinkedBlockingQueue：</code>
基于链表结构的<strong>无界阻塞队列</strong>，按<strong>FIFO（先进先出）原则</strong>对任务进行排序，吞吐量高于<code>ArrayBlockingQueue</code>。使用该队列，线程池中能创建的最大线程数为<code>corePoolSize</code>。<strong>静态工厂方法</strong>
<code>Executor.newFixedThreadPool()</code>使用了这个队列。</li>
<li><code>SynchronousQueue：</code>
一个<strong>不存储元素</strong>的阻塞队列。<code>添加任务的操作必须等到另一个线程的移除操作</code>，<code>否则添加操作一直处于阻塞状态</code>
。<strong>静态工厂方法</strong>
<code>Executor.newCachedThreadPool()</code>使用了这个队列。</li>
<li><code>PriorityBlokingQueue：</code>
一个<strong>支持优先级</strong>的<strong>无界阻塞队列</strong>。使用该队列，线程池中能创建的最大线程数为<code>corePoolSize</code>。</li>
</ol>
<ul>
<li><strong>keepAliveTime（线程活动保持时间）：</strong>
线程池的<code>工作线程空闲后</code>，<code>保持存活的时间</code>。如果<code>任务多而且任务的执行时间比较短</code>，可以<strong>调大</strong><code>keepAliveTime</code>，提高线程的利用率。</li>
<li><strong>unit（线程活动保持时间的单位）：</strong>
可选单位有<code>DAYS</code>、<code>HOURS</code>、<code>MINUTES</code>、<code>毫秒</code>、<code>微秒</code>、<code>纳秒</code>。</li>
<li><strong>handler（饱和策略，或者又称拒绝策略）：</strong>
当<strong>队列和线程池都满了</strong>，即<strong>线程池饱和了</strong>，必须采取一种策略处理提交的新任务。</li>
</ul>
<ol type="1">
<li><code>AbortPolicy：</code>
无法处理新任务时，<code>直接抛出异常</code>
，这是<strong>默认策略</strong>。</li>
<li><code>CallerRunsPolicy：</code> 用调用者所在的线程来执行任务。</li>
<li><code>DiscardOldestPolicy：</code>
丢弃阻塞队列中<strong>最靠前</strong>的一个任务，并执行当前任务。</li>
<li><code>DiscardPolicy：</code> 直接丢弃任务。</li>
</ol>
<ul>
<li><strong>threadFactory：</strong> 构建线程的工厂类</li>
<li><strong>总结：</strong>
<ul>
<li>常用的5个，核心池、最大池、空闲时间、时间的单位、阻塞队列；另外两个：拒绝策略、线程工厂类。</li>
</ul></li>
</ul>
<h2 id="线程池调度方式">线程池调度方式</h2>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7zMY80"><img
src="https://s4.ax1x.com/2022/01/28/7zMY80.md.png"
alt="7zMY80.md.png" /></a></p>
<p>一个新的任务到线程池时，线程池的处理流程如下：</p>
<ol type="1">
<li><strong>线程池判断核心线程池里的线程是否都在执行任务。</strong>
<ul>
<li>如果不是，创建一个新的工作线程来执行任务。</li>
<li>如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
</ul></li>
<li><strong>线程池判断阻塞队列是否已满。</strong>
<ul>
<li>如果阻塞队列没有满，则将新提交的任务存储在阻塞队列中。</li>
<li>如果阻塞队列已满，则进入下个流程。</li>
</ul></li>
<li><strong>线程池判断线程池里的线程是否都处于工作状态。</strong>
<ul>
<li>如果没有，则创建一个新的工作线程来执行任务。</li>
<li>如果已满，则交给<strong>饱和策略</strong>来处理这个任务。</li>
</ul></li>
</ol>
<h2 id="线程池中的拒绝策略">线程池中的拒绝策略</h2>
<p>实现自己的线程池拒绝策略就是这个接口，在线程池已满的情况下，我们可以把任务放进MQ，Redis，
应用内部队列中保存起来，找特定的时间窗口再去执行，当然，具体情况具体分析，反正接口，就在那里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK大佬提供的拒绝策略：</p>
<ul>
<li><strong>AbortPolicy</strong>（默认）：直接报错</li>
<li><strong>DiscardPolicy</strong>：不报错，悄悄的就丢了，注意是悄悄的，什么反应都没有</li>
<li><strong>DiscardOldestPolicy</strong>：不报错，悄悄的把队列中等得最久得丢了</li>
<li><strong>CallerRunsPolicy</strong>：调用者自己处理</li>
</ul>
<blockquote>
<p><strong>使用线程池的注意事项</strong></p>
</blockquote>
<ol type="1">
<li>注意初始化线程池时确定合理的并行数</li>
<li>不要使用没有边界的队列</li>
<li>拒绝策略需结合业务需求慎重选择，当然如果项目规模不大，且并发量低请忽略，默认即可，因为根本走不到那一步，但是咱不能不知道</li>
</ol>
<h1
id="java的内存模型jmm以及共享变量的可见性">Java的内存模型JMM以及共享变量的可见性</h1>
<p><strong>JMM</strong>决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main
Memory)中，每个线程都有一个私有的本地内存（Local
Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7dNssK"><img
src="https://s4.ax1x.com/2022/01/17/7dNssK.md.png"
alt="7dNssK.md.png" /></a></p>
<p>对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。<strong>解决这种共享变量在多线程模型中的不可见性问题</strong>，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，<strong>比较合理的方式其实就是volatile</strong>。</p>
<p>需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。</p>
<h1 id="volatile变量的作用及特性">volatile变量的作用及特性</h1>
<ol type="1">
<li><p><strong>保证可见性，不保证原子性</strong></p>
<ul>
<li>当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；</li>
<li>这个写会操作会导致其他线程中的volatile变量缓存无效。</li>
</ul></li>
<li><p><strong>禁止指令重排</strong></p>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：</p>
<ul>
<li>重排序操作不会对存在数据依赖关系的操作进行重排序。</li>
<li>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</li>
</ul></li>
</ol>
<p>　
比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，
所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p>
<p>重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//状态切换为true</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> changeStatus&#123;</span><br><span class="line">		a = <span class="number">2</span>;   <span class="comment">//1</span></span><br><span class="line">		status = <span class="literal">true</span>;  <span class="comment">//2</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//若状态为true，则为running</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(status)&#123;   <span class="comment">//3</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a + <span class="number">1</span>;  <span class="comment">//4</span></span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，<strong>会在指令序列中插入内存屏障</strong>来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：</p>
<ol type="1">
<li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
<ul>
<li>即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。</li>
</ul></li>
</ol>
<h1 id="volatile原理">volatile原理</h1>
<p><strong>volatile</strong>可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“<strong>内存屏障</strong>”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，<strong>加入volatile关键字时，会多出一个lock前缀指令</strong>，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），<code>内存屏障会提供3个功能</code>：</p>
<ol type="1">
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>
<h1 id="volatile与synchronized的区别">volatile与synchronized的区别</h1>
<ol type="1">
<li><code>volatile</code>仅能使用在变量级别；
<code>synchronized</code>则可以使用在变量、方法、和类级别</li>
<li><code>volatile</code>仅能实现变量的修改可见性，并不能保证原子性；<code>synchronized</code>则可以保证变量的修改可见性和原子性</li>
<li><code>volatile</code>不会造成线程的阻塞；
<code>synchronized</code>可能会造成线程的阻塞</li>
<li><code>volatile</code>标记的变量不会被编译器优化；<code>synchronized</code>标记的变量可以被编译器优化</li>
</ol>
<h1
id="synchronized和reentrantlock实现原理和区别">synchronized和ReentrantLock实现原理和区别</h1>
<p>在JDK1.5之前共享对象的协调机制只有<strong>synchronized</strong>和<strong>volatile</strong>，在JDK1.5中增加了新的机制<strong>ReentrantLock</strong>，该机制的诞生并不是为了替代synchronized，而是在
synchronized 不适用的情况下，提供一种可以选择的高级功能。</p>
<blockquote>
<p><strong>synchronized</strong> 和 <strong>ReentrantLock</strong>
是如何实现的？它们有什么区别？</p>
</blockquote>
<p><strong>synchronized</strong>
属于<strong>独占式悲观锁</strong>，是通过 JVM
隐式实现的，<strong>synchronized
只允许同一时刻只有一个线程操作资源</strong>。</p>
<p>在 Java 中每个对象都隐式包含一个
monitor（监视器）对象，加锁的过程其实就是竞争 monitor
的过程，当线程进入字节码 monitorenter 指令之后，线程将持有 monitor
对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor
对象时，则需要阻塞等待获取该对象。</p>
<p><strong>ReentrantLock</strong> 是 Lock 的默认实现方式之一，它是基于
<code>AQS（Abstract Queued Synchronizer，队列同步器）</code>实现的，它默认是通过<strong>非公平锁</strong>实现的，在它的内部有一个
<strong>state 的状态字段</strong>用于表示锁是否被占用，如果是 0
则表示锁未被占用，此时线程就可以把 state 改为
1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p>
<p>synchronized 和 ReentrantLock
都提供了锁的功能，具备互斥性和不可见性。在 JDK 1.5 中 synchronized
的性能远远低于 ReentrantLock，但在 JDK 1.6 之后 <strong>synchronized
的性能略低于 ReentrantLock，它的区别如下</strong>：</p>
<ol type="1">
<li><strong>synchronized</strong>是JVM隐式实现的，而<strong>ReentrantLock</strong>是Java语言提供的API；</li>
<li><strong>ReentrantLock</strong>可设置为公平锁，而<strong>synchronized</strong>却不行；</li>
<li><strong>ReentrantLock</strong> 只能修饰代码块，而
<strong>synchronized</strong> 可以用于修饰方法、修饰代码块等；</li>
<li><strong>ReentrantLock</strong>
需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而
<strong>synchronized</strong> 无需手动释放锁；</li>
<li><strong>ReentrantLock</strong> 可以知道是否成功获得了锁，而
<strong>synchronized</strong> 却不行。</li>
</ol>
<h1 id="cas原理分析">CAS原理分析</h1>
<p><strong>CAS</strong>的英文为Compare and Swap 翻译为比较并交换。</p>
<p><strong>CAS加volatile关键字</strong>是实现并发包的基石。没有CAS就不会有并发包，synchronized是一种独占锁、悲观锁，<code>java.util.concurrent</code>中借助了CAS指令实现了一种区别于synchronized的一种乐观锁。</p>
<h2
id="乐观锁的实现方式-cascompare-and-swap">乐观锁的实现方式-CAS（Compare
and Swap）：</h2>
<blockquote>
<p><strong>jdk1.5之前锁存在的问题</strong>：</p>
</blockquote>
<p>java在1.5之前都是靠<code>synchronized</code>关键字保证同步，<code>synchronized</code>保证了无论哪个线程持有共享变量的锁，都会采用独占的方式来访问这些变量。这种情况下：</p>
<ol type="1">
<li><p>在多线程竞争下，加锁、释放锁会导致较多的上下文切换和调度延时，引起性能问题。</p></li>
<li><p>如果一个线程持有锁，其他的线程就都会挂起，等待持有锁的线程释放锁。</p></li>
<li><p>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能风险。</p></li>
</ol>
<p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。
乐观锁就是：每次不加锁而是假设没有并发冲突去操作同一变量，如果有并发冲突导致失败，则重试直至成功。</p>
<blockquote>
<p><strong>乐观锁：</strong></p>
</blockquote>
<p><strong>乐观锁（ Optimistic Locking
）</strong>在上文已经说过了，其实就是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会产生并发冲突，所以在数据进行提交更新的时候，才会正式对数据是否产生并发冲突进行检测，如果发现并发冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<p>上面提到的乐观锁的概念中其实已经阐述了它的具体实现细节：主要就是两个步骤：<strong>冲突检测和数据更新</strong>。其实现方式有一种比较典型的就是
<strong>Compare and Swap ( CAS )</strong>。</p>
<p>乐观锁的一种典型实现机制（CAS）:</p>
<p>乐观锁主要就是两个步骤：冲突检测和数据更新。当多个线程尝试使用CAS同时更新同一个变量时，只有一个线程可以更新变量的值，其他的线程都会失败，失败的线程并不会挂起，而是告知这次竞争中失败了，并可以再次尝试。</p>
<p><strong>CAS操作包括三个操作数：需要读写的内存位置(V)、预期原值(A)、新值(B)。</strong>如果内存位置与预期原值的A相匹配，那么将内存位置的值更新为新值B。如果内存位置与预期原值的值不匹配，那么处理器不会做任何操作。无论哪种情况，它都会在
CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS
是否成功，而不提取当前值。）CAS其实就是一个：我认为位置 V 应该包含值
A；如果包含该值，则将 B
放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。这其实和乐观锁的冲突检测+数据更新的原理是一样的。</p>
<p>乐观锁是一种思想，CAS只是这种思想的一种实现方式。</p>
<p>JAVA对CAS的支持：</p>
<p>在JDK1.5新增的<strong>java.util.concurrent(JUC
java并发工具包)就是建立在CAS之上的</strong>。相比于<code>synchronized</code>这种堵塞算法，CAS是非堵塞算法的一种常见实现。所以JUC在性能上有了很大的提升。</p>
<p>下面通过看下并发包中的原子操作类<code>AtomicInteger</code>来看下，如何在不使用锁的情况下保证线程安全，主要看下getAndIncrement方法，相当于i++的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();  </span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line">                <span class="keyword">return</span> current;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>value</code>使用了<code>volatile</code>修饰，这就保证了他的可见性与有序性，<code>getAndIncrement</code>采用CAS操作，每次从内存中读取数据然后将数据进行+1操作，然后对原数据，+1后的结果进行CAS操作，成功的话返回结果，否则重试直到成功为止。其中调用了<code>compareAndSet</code>利用JNI（java
navite Interface
navite修饰的方法，都是java调用其他语言的方法来实现的）来完成CPU的操作。其中<code>compareAndSwapInt</code>类似如下逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == expect) &#123;</span><br><span class="line">     <span class="built_in">this</span> = update</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程的状态及转移">线程的状态及转移</h1>
<h2 id="状态转移图">状态转移图</h2>
<p><strong>初始，就绪，运行，阻塞，终止</strong>。
其中可运行态包括就绪态和运行中。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/70Ec5D"><img
src="https://s4.ax1x.com/2022/01/18/70Ec5D.md.png"
alt="70Ec5D.md.png" /></a></p>
<h2 id="新建态到就绪态">新建态到就绪态</h2>
<ol type="1">
<li><strong>新建态</strong>：一个线程被创建出来时候所处的状态 ；</li>
<li><strong>就绪态</strong>：线程调用start()方法后，便处于可以被操作系统调度的状态，即就绪态。该状态可以由三处转化而来，新建态执行了start、线程阻塞结束、锁池等待队列中的线程获得了锁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;hello : &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// t1执行start()之后，处于就绪态，操作系统此时可以分配时间片给该线程，让该线程执行run方法体中的内容</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>
<ul>
<li>该状态对应状态图中的第0步，比较简单，不再赘述</li>
</ul>
<h2 id="就绪态到运行态">就绪态到运行态</h2>
<ol type="1">
<li><strong>运行态</strong>：表示当前线程被操作系统调度，分配了时间片，执行线程中的run方法时的状态。运行态只可以由就绪态的线程转化而来，如果多个线程都处在就绪态，就等待操作系统分配。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 : running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 : running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：可以看到t1和t2两个线程都运行start()方法后，控制台会随机交叉打印两个线程的输出信息，这种随机，是操作系统随机分配时间片的调度决定的</li>
</ul>
<h2 id="运行态到就绪态">运行态到就绪态</h2>
<h3 id="时间片用完">时间片用完</h3>
<ul>
<li>我们知道，操作系统为了公平，不可能从就绪态里面选择一个，一直执行完，而是随机切换到另外的线程去执行，每个线程分配的执行时间结束，操作系统去调用别的线程，当前刚执行结束的线程便由运行态重新回到就绪态，等待操作系统的再次分配。参考上一个代码例子，t1的线程执行体方法中循环打印100次，t2也是，但是会看到控制台是交叉打印的，说明了这一点。</li>
</ul>
<h3 id="t1.yield-thread.yield">t1.yield() 、Thread.yield();</h3>
<ul>
<li>概念：在t1线程体中调用t1.yield()
和Thread.yield();本质上一样，Thread.yield()表示当前线程让渡。线程调用yield()方法，会让该线程重新回到就绪队列，但是yield()让当前线程回到就绪队列后，并不能保证操作系统再次调用不会选择该线程，所以yield()方法不能用来控制线程的执行顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程1</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 : running &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// 线程2</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 : running &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：这个程序我故意把线程让步yield()方法写在线程体刚运行的时候，也就是说，每次操作系统分配给t1线程时间片时候，t1都会让步。但这次的让步不代表t1接下来的方法不会执行，也就是我让步之后，大家再一起抢，t1又抢到了时间片，那么t1本次时间片内便执行接下来的方法，等时间片结束，再次分配t1时间片，t1还会让，再接着抢，抢到和抢不到都有可能。</li>
</ul>
<h2 id="运行态到阻塞态">运行态到阻塞态</h2>
<p>阻塞态表示当前线程被由于某种原因，被挂起，也就是被阻塞，正在运行的线程被阻塞后，即使结束阻塞状态也回不去运行态，只能回到就绪态，等待os分配cpu资源去调度。</p>
<h3 id="thread.sleep">Thread.sleep()</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;hello : &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// t1执行start()之后，处于就绪态，操作系统此时可以分配时间片给该线程</span></span><br><span class="line">    t1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意:让当前线程睡眠，该线程被阻塞，睡眠时间结束，该线程接着运行</li>
</ul>
<h3 id="t2.join">t2.join()</h3>
<ul>
<li>当在t1中调用t2.join()。那么t1会阻塞，一直等待t2执行完毕，才结束阻塞回到就绪态</li>
<li>直接看代码：这里我把t1和t2抽出来当做全局静态变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">50</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t2.join();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 : running &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 : running &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解释：这个程序的运行结果是，首先t1，t2挣抢时间片，按系统调度，首先控制台t1和t2都有打印自身的输出信息，当t1执行到i=50的时候，调用了t2.join()。此时控制台会全部打印t2的信息，一直等待t2的循环结束，执行体的run方法结束，再去打印t1剩下的没运行完的循环</li>
<li>所以join的流程可以抽象为下面这张图片</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/70n2jJ"><img
src="https://s4.ax1x.com/2022/01/18/70n2jJ.md.png"
alt="70n2jJ.md.png" /></a></p>
<h3 id="t1等待用户输入等待键盘响应">t1等待用户输入，等待键盘响应</h3>
<p>这个很好理解，比如你就执行一个main函数的主线程，等待输入时，该线程是不会结束的，就是处于阻塞状态。</p>
<h2 id="阻塞态到就绪态">阻塞态到就绪态</h2>
<ul>
<li>1.3中所有阻塞态结束，比如sleep结束，join后t2执行结束，用户输入了信息回车等。t1会结束阻塞态，但是都是回到就绪态，无法再立即回到运行态</li>
</ul>
<h2 id="运行态到等待队列">运行态到等待队列</h2>
<blockquote>
<p>这里牵扯到对象锁的概念</p>
</blockquote>
<ul>
<li>两个线程竞争锁，其中t1释放锁，也就是把所占有的对象锁让出。那么如果不主动唤醒，该线程一直处在等待队列中，得不到操作系统OS的调度</li>
<li>概念：等待队列，就是当前线程占有锁之后，主动把锁让出，使自身进入等待队列。此种wait加notify可以保证线程执行的先后顺序。notify()是通知一个等待队列的线程回到锁池队列。notifyAll()是通知所有处在等待队列的线程，都回到锁池队列。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 准备上锁的对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 线程1</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">                        <span class="comment">// 当i=5的时候，让出对象锁，t1进入等待队列</span></span><br><span class="line">                        <span class="comment">// 如果没人通知，t1一直等待，程序不会结束</span></span><br><span class="line">                        o.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 : running &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// 线程2</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 : running &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里t2得到锁，执行完线程方法之后一定要通知t1停止等待。</span></span><br><span class="line">            <span class="comment">// 不然t1结束不了，处在一直等待通知的状态</span></span><br><span class="line">            o.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行态到锁池队列">运行态到锁池队列</h3>
<ul>
<li>参考1.5的程序，在i=5之前，t1占有该对象锁，t2即使start()也得不到运行，原因是该对象锁被t1占有，t2拿不到，所以就进入锁池队列</li>
</ul>
<h2 id="等待队列到锁池队列">等待队列到锁池队列</h2>
<ul>
<li>参考1.5的程序，当t1wait之后，让出对象锁，t1进入了等待队列，t2拿到锁，运行完之后，调用notify()让等待队列中的t1进入锁池队列。</li>
</ul>
<h2 id="锁池队列到就绪态">锁池队列到就绪态</h2>
<ul>
<li>参考1.5的程序，当t2结束后，通知t1进入锁池队列，t2由于运行结束，处在锁池队列中的t1可以拿到对象锁，进入就绪态，等待操作系统的调度，从而进入运行态</li>
</ul>
<h2 id="运行态到死亡态">运行态到死亡态</h2>
<blockquote>
<p>死亡态不可逆，一旦线程进入死亡态，就再也回不到其他状态</p>
</blockquote>
<ul>
<li>死亡态只能由运行态进入，运行态中的线程。例如通过操作系统的不停调度，t1直到把整个run方法中的循环体执行完毕，该线程完成了它的使命，便进入死亡态</li>
</ul>
<h1
id="java中如何保证线程安全性多线程三大特性">Java中如何保证线程安全性（多线程三大特性）</h1>
<blockquote>
<p><strong>线程安全在三个方面体现</strong></p>
</blockquote>
<ol type="1">
<li><p><strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</p></li>
<li><p><strong>可见性</strong>：一个线程<strong>对主内存的修改</strong>可以及时地被其他线程看到，（synchronized,volatile）；</p></li>
<li><p><strong>有序性</strong>：一个线程观察其他线程中的<strong>指令执行顺序</strong>，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p></li>
</ol>
<h1 id="sleep和wait有什么区别">sleep和wait有什么区别</h1>
<blockquote>
<p>对时间的指定:</p>
</blockquote>
<ol type="1">
<li><strong>sleep</strong>方法必须指定时间</li>
<li><strong>wait</strong>方法有重载形式，可以指定时间，也可以不指定时间</li>
</ol>
<blockquote>
<p>对于执行权和锁的操作.：</p>
</blockquote>
<ol type="1">
<li><strong>sleep()</strong>:
释放执行权，不释放锁，因为肯定能醒，肯定可以恢复到临时阻塞状态。</li>
<li><strong>wait()</strong>：释放执行权，释放锁，因为wait不释放锁，如果没有时间指定，那么其他线程都进行不了同步中，无法将其唤醒。</li>
</ol>
<p>同步中可以有多个存活的线程，但是只能有一个执行同步的代码。因为只有一个线程会持有同步的锁。</p>
<p>只有当该线程释放了锁，其他线程才会有机会获取到锁，而且只能用一个线程获取到锁，继续执行。</p>
<blockquote>
<p>补充：</p>
</blockquote>
<ol type="1">
<li><p>这两个方法来自不同的类分别是Thread和Object</p></li>
<li><p>最主要是sleep方法没有释放锁，而 wait
方法释放了锁，使得其他线程可以使用同步控制块或者方法。</p></li>
<li><p><strong>wait</strong>，notify和notifyAll只能在<strong>同步控制方法</strong>或者<strong>同步控制块</strong>里面使用，而sleep可以在任何地方使用（使用范围）。</p></li>
<li><p>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。</p></li>
</ol>
<h1 id="synchronized锁升级的策略">Synchronized锁升级的策略</h1>
<h2 id="锁升级原理">锁升级原理</h2>
<p><strong>synchronized</strong>锁的是对象，而锁优化过后，默认是无锁，再到偏向锁，轻量级锁，重量级锁，那么这是一个过程，而且这个过程是<strong>用户态</strong>进行的，没有到内核态进行，那么synchronized是如何实现的，因为锁的是对象，那么就是在对象的对象头中实现的，关于对象在内存中的布局在jvm的笔记中已经详细记录，我这里就简单来说,synchronized是通过对象头的markword来进行。</p>
<h2 id="无锁升级为偏向锁">无锁升级为偏向锁</h2>
<p>在JDK1.6过后，默认是开启了偏向锁的，偏向锁的性能较低，偏向锁适用于单线程的环境下，所以要根据具体的业务情况来使用，如果synchronized在第一个线程进入的情况下，默认修改为偏向锁，将当前线程的ID更新到对象头的markword的线程ID中，增加偏向锁的时间戳以及偏向锁的标志修改为1。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/701fDe"><img
src="https://s4.ax1x.com/2022/01/18/701fDe.md.png"
alt="701fDe.md.png" /></a></p>
<p>比如有几个线程同时访问同步代码块，那么只有一个线程可以进入，那么初始的object
markword肯定是无锁的，也就是上图的无锁对象头，那么这个时候线程1把当前线程的ID通过CAS修改到markword中，这个过程中的CAS肯定是能成功的，不成功就不是无锁升级为偏向锁了，还是其他锁升级的过程了；这个时候其他线程是在线程1未退出同步代码块的时候是没有办法进入同步代码块，也就是没有办法获取锁，那么其他获取cpu执行权限的线程会通过CAS修改线程ID为当前线程，但是如果线程1没有退出同步代码块，而后续线程通过CAS进行修改是不能成功的，那么这个时候后续的线程就将synchronized升级为轻量级锁，也就是下一个锁升级过程。</p>
<h2 id="偏向锁升级为轻量级锁">偏向锁升级为轻量级锁</h2>
<p>偏向锁升级为轻量级锁是在线程有竞争的情况下，线程1迟迟没有退出同步代码块，而线程2又要竞争这把锁，而线程2通过CAS自适应自旋一直没有成功，这个时候它就升级为轻量级锁，如果在CAS的过程中，线程1退出了同步代码块，那么这个时候线程2CAS成功，是不会升级为轻量级锁，所以偏向锁适用于单线程的环境下</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/703uP1"><img
src="https://s4.ax1x.com/2022/01/18/703uP1.md.png"
alt="703uP1.md.png" /></a></p>
<p>轻量级锁是在线程有一定的竞争的时候想要进入同步代码块，而如果这个时候之前运行在synchronized的线程退出了，那么不会升级为轻量级锁，还是偏向锁，如果线程2cas结束过后，线程1还没有退出就会进行锁升级，偏向锁升级为轻量级锁，这个升级过程非常消耗性能，所以有很多公司都是禁止出现偏向锁的，因为偏向锁升级为轻量级锁的时候，是需要撤销偏向锁的，<strong>撤销偏向锁</strong>的过程如下：</p>
<ol type="1">
<li>在一个安全点停止所有拥有锁的线程；</li>
<li>遍历线程栈，如果存在锁记录，需要修复锁记录和MarkWord，使其变成无锁的状态；</li>
<li>唤醒当前线程，将当前锁升级为轻量级锁；
所以这个过程是非常消耗性能的，所以不适合在多线程的环境下使用偏向锁。</li>
</ol>
<h2 id="轻量级锁升级为重量级锁">轻量级锁升级为重量级锁</h2>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/708GlV"><img
src="https://s4.ax1x.com/2022/01/18/708GlV.md.png"
alt="708GlV.md.png" /></a></p>
<p><strong>重量级锁</strong>在并发非常高的情况下启用，就是锁的竞争非常激励，比如线程1首先将在线程栈上开辟一定的空间来存储mark
word，并且相互指向，然后开始执行同步代码，而这个时候很多线程都过来了，那么这些线程也要拷贝markword到线程栈中，然后cas修改lock
record与mark
word的相互指向，这个时候只有一个线程能够成功，其他线程都需要cas，如果线程1没有同步代码块没有指向完成，其他线程是没有办法自旋成功，那么就就那些锁膨胀，升级为重量级锁，重量级锁升级过后线程的阻塞是由内核进行处理的，所以性能较低。</p>
<h2 id="gc标志">GC标志</h2>
<p>我们知道GC在每次进行的时候其实就是对对象的操作，对象的对象头中的markword进行操作，如果这个对象可以被GC了，那么GC会在在markword的锁状态设置为11，表示新一轮的gc开始了，而对象的age是最大15次，每次gc，age+1，如果达到了15次还存活就移植到老年代；所以这里有个问题就是如果我们的object对象升级为重量级锁了，那么是不是一直是重量级锁呢？我们知道锁的升级是不能降级的，也就是说轻量级锁不能降级为偏向锁，偏向锁不能降级为无锁，那如果说我们的锁升级为重量级锁了，过了很久都没有线程来访问，下一次线程来访问的时候还是重量级锁吗？不是的，JVM没有这么的傻，也就是说在很久没有线程访问的情况下会进行降级，但是降级是直接降级为无锁状态。</p>
<h2 id="降级的目的和过程">降级的目的和过程</h2>
<p>因为基本对象锁的实现优先于重量级锁的使用，JVM会尝试在SWT的停顿中堆处于空闲状态重量级锁进行降级操作，这个降级过程是如何实现的呢？我们知道在STW时，所有的JAVA线程都将暂停在安全点SafePoint，此时VMThread通过对所有Monitor的遍历，或者通过对所有依赖于MonitorInUseLists值得当前正在使用中的Monitor子序列进行遍历从而得到哪些是未被使用的Monitor作为降级对象。
可以降级的Monitor对象
重量级锁的降级过程发生在STW阶段，降级对象就是哪些仅仅能被VMThread访问而没有被其他JavaThread访问的Monitor对象。</p>
<h1 id="如何设置线程池参数">如何设置线程池参数</h1>
<p><a
target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>
<h1 id="java中线程同步的方式有哪些">Java中线程同步的方式有哪些</h1>
<h2 id="synchronized关键字">synchronized关键字</h2>
<p>Synchronized修饰整个方法</p>
<p>java的每个对象都有一个内置锁，当用此关键字修饰方法时，
内置锁会保护整个方法。synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</p>
<p>synchronized修饰具体的代码块</p>
<p>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</p>
<h2 id="重入锁">重入锁</h2>
<p><strong>ReentrantLock类</strong>是可重入、互斥、实现了Lock接口的锁，它与使用
synchronized
方法和块具有相同的基本行为和语义，并且扩展了其能力。.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码
。如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁
。</p>
<p>ReentrantLock() : 创建一个ReentrantLock实例</p>
<p>lock() : 获得锁</p>
<p>unlock() : 释放锁</p>
<h2 id="volatile关键字">volatile关键字</h2>
<p>1.volatile 是变量修饰符，其修饰的变量具有可见性。</p>
<p>可见性就是说一旦某个线程修改了被 volatile
修饰的变量，它会保证修改的值会立即被更新到主存，当有其他线程需要读取的时候，可以立即获取修改之后的值。</p>
<p>在Java中为了加快程序的运行效率，对一些变量的操作通常是在该线程的寄存器或CPU缓存上进行的，之后才会同步到主存中，而加了
volatile 修饰符的变量则是直接读写主存。</p>
<ol start="2" type="1">
<li>volatile可以禁止指令重排</li>
</ol>
<p>指令重排是指编译器或者CPU为了提高程序的运行效率，可能会对输入的代码进行优化，它不保证各个语句的执行顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码中的执行结果是一致的，应用条件是单线程条件，对于并发多线程的场景下，指令重排会产生不确定的结果。</p>
<p>volatile不会提供任何原子操作，它也不能用来修饰 final 类型的变量</p>
<h2 id="使用局部变量实现线程同步">使用局部变量实现线程同步</h2>
<p>如果使用<strong>ThreadLocal</strong>管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p>ThreadLocal() : 创建一个线程本地变量</p>
<p>get() : 返回此线程局部变量的当前线程副本中的值</p>
<p>initialValue() : 返回此线程局部变量的当前线程的"初始值"</p>
<p>set(T value) : 将此线程局部变量的当前线程副本中的值设置为value</p>
<h1 id="线程池的实现原理">线程池的实现原理</h1>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/70rlbn"><img
src="https://s4.ax1x.com/2022/01/18/70rlbn.md.png"
alt="70rlbn.md.png" /></a></p>
<p>其实<strong>java线程池的实现原理</strong>很简单，说白了就是一个<strong>线程集合workerSet</strong>和一个<strong>阻塞队列workQueue</strong>。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p>
<h2 id="线程池的几个主要参数的作用">线程池的几个主要参数的作用</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>corePoolSize: 规定线程池有几个线程(worker)在运行。</li>
<li>maximumPoolSize:
当workQueue满了,不能添加任务的时候，这个参数才会生效。规定线程池最多只能有多少个线程(worker)在执行。</li>
<li>keepAliveTime:
超出corePoolSize大小的那些线程的生存时间,这些线程如果长时间没有执行任务并且超过了keepAliveTime设定的时间，就会消亡。</li>
<li>unit: 生存时间对于的单位</li>
<li>workQueue: 存放任务的队列</li>
<li>threadFactory: 创建线程的工厂</li>
<li>handler:
当workQueue已经满了，并且线程池线程数已经达到maximumPoolSize，将执行拒绝策略。</li>
</ol>
<h2 id="任务提交后的流程分析">任务提交后的流程分析</h2>
<p>用户通过submit提交一个任务。线程池会执行如下流程:</p>
<ol type="1">
<li>判断当前运行的worker数量是否超过corePoolSize,如果不超过corePoolSize。就创建一个worker直接执行该任务。——
线程池最开始是没有worker在运行的</li>
<li>如果正在运行的worker数量超过或者等于corePoolSize,那么就将该任务加入到workQueue队列中去。</li>
<li>如果workQueue队列满了,也就是offer方法返回false的话，就检查当前运行的worker数量是否小于maximumPoolSize,如果小于就创建一个worker直接执行该任务。</li>
<li>如果当前运行的worker数量是否大于等于maximumPoolSize，那么就执行RejectedExecutionHandler来拒绝这个任务的提交。</li>
</ol>
<h1 id="synchronized可以锁的内容">synchronized可以锁的内容</h1>
<p>锁住的是<strong>当前对象的当前方法</strong>，会使得其他线程访问该对象的synchronized方法或者代码块阻塞，但并不会阻塞非synchronized方法。</p>
<h1 id="countdownlatch原理">CountDownLatch原理</h1>
<p><strong>CountDownLatch</strong>在多线程并发编程中<strong>充当一个计时器的功能</strong>，并且维护一个count的变量，并且其操作都是原子操作，该类主要通过<code>countDown()</code>和<code>await()</code>两个方法实现功能的，首先通过建立CountDownLatch对象，并且传入参数即为count初始值。如果一个线程调用了await()方法，那么这个线程便进入阻塞状态，并进入阻塞队列。</p>
<p>如果一个线程调用了countDown()方法，则会使count-1；当count的值为0时，这时候阻塞队列中调用await()方法的线程便会逐个被唤醒，从而进入后续的操作。</p>
<p>比如下面的例子就是有两个操作，一个是读操作一个是写操作，现在规定必须进行完写操作才能进行读操作。所以当最开始调用读操作时，需要用await()方法使其阻塞，当写操作结束时，则需要使count等于0。因此count的初始值可以定为写操作的记录数，这样便可以使得进行完写操作，然后进行读操作。</p>
<ol type="1">
<li>首先是创建实例 CountDownLatch countDown = new CountDownLatch(2)</li>
<li>需要同步的线程执行完之后，计数-1； countDown.countDown()</li>
<li>需要等待其他线程执行完毕之后，再运行的线程，调用
countDown.await()实现阻塞同步</li>
</ol>
<h1 id="为什么要用线程池线程池优点">为什么要用线程池(线程池优点)</h1>
<p>为了减少创建和销毁线程的次数，让每个线程可以多次使用,可根据系统情况<strong>调整执行</strong>的线程数量，防止消耗过多内存,所以我们可以使用线程池。</p>
<ol type="1">
<li>降低资源消耗。
通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。
当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。
线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h1
id="arraylist线程安全吗多线程环境下怎么使用arraylist">ArrayList线程安全吗？多线程环境下怎么使用ArrayList？</h1>
<h2 id="线程不安全的两种体现">线程不安全的两种体现</h2>
<h3 id="数组越界异常-arrayindexoutofboundsexception">数组越界异常
<code>ArrayIndexOutOfBoundsException</code></h3>
<p>由于ArrayList添加元素是如上面分两步进行，可以看出第一个不安全的隐患，在多个线程进行add操作时可能会导致elementData数组越界。</p>
<p>具体逻辑如下：</p>
<ol type="1">
<li>列表大小为9，即size=9</li>
<li>线程A开始进入add方法，这时它获取到size的值为9，调用ensureCapacityInternal方法进行容量判断。</li>
<li>线程B此时也进入add方法，它获取到size的值也为9，也开始调用ensureCapacityInternal方法。</li>
<li>线程A发现需求大小为10，而elementData的大小就为10，可以容纳。于是它不再扩容，返回。</li>
<li>线程B也发现需求大小为10，也可以容纳，返回。</li>
<li>线程A开始进行设置值操作， elementData[size++] = e
操作。此时size变为10。</li>
<li>线程B也开始进行设置值操作，它尝试设置elementData[10] =
e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常<code>ArrayIndexOutOfBoundsException</code>.</li>
</ol>
<h3 id="元素值覆盖和为空问题">元素值覆盖和为空问题</h3>
<p><code>elementData[size++] = e</code>
设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elementData[size] = e;</span><br><span class="line">size = size + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>在单线程执行这两条代码时没有任何问题，但是当多线程环境下执行时，可能就会发生一个线程的值覆盖另一个线程添加的值，具体逻辑如下：</p>
<ol type="1">
<li>列表大小为0，即size=0</li>
<li>线程A开始添加一个元素，值为A。此时它执行第一条操作，将A放在了elementData下标为0的位置上。</li>
<li>接着线程B刚好也要开始添加一个值为B的元素，且走到了第一步操作。此时线程B获取到size的值依然为0，于是它将B也放在了elementData下标为0的位置上。</li>
<li>线程A开始将size的值增加为1</li>
<li>线程B开始将size的值增加为2</li>
</ol>
<p>这样线程AB执行完毕后，理想中情况为size为2，elementData下标0的位置为A，下标1的位置为B。而实际情况变成了size为2，elementData下标为0的位置变成了B，下标1的位置上什么都没有。并且后续除非使用set方法修改此位置的值，否则将一直为null，因为size为2，添加元素时会从下标为2的位置上开始。</p>
<h2 id="arraylist线程安全处理">ArrayList线程安全处理</h2>
<h3 id="collections.synchronizedlist">Collections.synchronizedList</h3>
<p>最常用的方法是<strong>通过 Collections 的 synchronizedList
方法</strong>将 ArrayList 转换成线程安全的容器后再使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list =Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;);</span><br></pre></td></tr></table></figure>
<h3 id="为list.add方法加锁">为list.add()方法加锁</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(list.get()) &#123;</span><br><span class="line">list.get().add(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="copyonwritearraylist">CopyOnWriteArrayList</h3>
<p>使用线程安全的 <code>CopyOnWriteArrayList</code> 代替线程不安全的
ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;Object&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="使用threadlocal">使用ThreadLocal</h3>
<p>使用ThreadLocal变量确保线程封闭性(封闭线程往往是比较安全的，
但由于使用ThreadLocal封装变量，相当于把变量丢进执行线程中去，每new一个新的线程，变量也会new一次，一定程度上会造成性能[内存]损耗，但其执行完毕就销毁的机制使得ThreadLocal变成比较优化的并发解决方案)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;List&lt;Object&gt;&gt; threadList = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">protected</span> List&lt;Object&gt; <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="java自带的4种线程池">java自带的4种线程池</h1>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">ExecutorService</th>
<th style="text-align: center;">真正的线程池接口。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ScheduledExecutorService</td>
<td
style="text-align: center;">能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td>
</tr>
<tr class="even">
<td style="text-align: center;">ThreadPoolExecutor</td>
<td style="text-align: center;">ExecutorService的默认实现。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ScheduledThreadPoolExecutor</td>
<td
style="text-align: center;">继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td>
</tr>
</tbody>
</table>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<ol type="1">
<li><strong>newSingleThreadExecutor</strong></li>
</ol>
<ul>
<li>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
</ul>
<ol start="2" type="1">
<li><strong>newFixedThreadPool</strong></li>
</ol>
<ul>
<li>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
</ul>
<p><strong>3. newCachedThreadPool</strong></p>
<ul>
<li><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，</p></li>
<li><p>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p></li>
</ul>
<ol start="4" type="1">
<li><strong>newScheduledThreadPool</strong></li>
</ol>
<ul>
<li>创建一个定长线程池，支持定时及周期性任务执行。</li>
</ul>
<h1 id="线程的私有资源与共享资源">线程的私有资源与共享资源</h1>
<p><strong>线程共享的环境</strong>包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
<p>进程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括：</p>
<ol type="1">
<li><strong>线程ID</strong>
<ul>
<li>每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。</li>
</ul></li>
<li><strong>寄存器组的值</strong>
<ul>
<li>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。</li>
</ul></li>
<li><strong>线程的栈</strong>
<ul>
<li>栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。</li>
</ul></li>
<li><strong>错误返回码</strong>
<ul>
<li>由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。</li>
</ul></li>
<li><strong>线程的信号屏蔽码</strong>
<ul>
<li>由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。</li>
</ul></li>
<li><strong>线程的优先级</strong>
<ul>
<li>由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。</li>
</ul></li>
</ol>
<h1 id="atomicinteger底层实现">AtomicInteger底层实现</h1>
<p><strong>AtomicInteger</strong>位于<code>java.util.concurrent.atomic</code>包下，是对int的封装，提供原子性的访问和更新操作，其原子性操作的实现是基于CAS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从 AtomicInteger 的内部属性可以看出，它依赖于Unsafe
提供的一些底层能力，进行底层操作；如根据valueOffset代表的该变量值在内存中的偏移地址，从而获取数据的。</li>
<li>变量value用volatile修饰，保证了多线程之间的内存可见性。</li>
</ul>
<h1
id="线程池里线程报的异常如何抓取在线程池外捕获">线程池里线程报的异常如何抓取，在线程池外捕获</h1>
<p>当线程池中线程执行任务的时候，任务出现未被捕获的异常的情况下，线程池会将允许该任务的线程从池中移除并销毁，且同时会创建一个新的线程加入到线程池中；可以通过ThreadFactory自定义线程并捕获线程内抛出的异常，也就是说甭管我们是否去捕获和处理线程池中工作线程抛出的异常，这个线程都会从线程池中被移除。</p>
<h1 id="阻塞队列的性能对比">阻塞队列的性能对比</h1>
<p>主要是比较offer跟poll两个方法的性能，开N个线程，每个线程往队列里写或者取500个整数。</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">线程数</th>
<th style="text-align: center;">20</th>
<th style="text-align: center;">50</th>
<th style="text-align: center;">100</th>
<th style="text-align: center;">200</th>
<th style="text-align: center;">500</th>
<th style="text-align: center;">1000</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">LinkedBlockingQueue</td>
<td style="text-align: center;">15,0</td>
<td style="text-align: center;">31,15</td>
<td style="text-align: center;">32,16</td>
<td style="text-align: center;">63,32</td>
<td style="text-align: center;">203,47</td>
<td style="text-align: center;">563,110</td>
</tr>
<tr class="even">
<td style="text-align: center;">ArrayBlockingQueue</td>
<td style="text-align: center;">15,0</td>
<td style="text-align: center;">16,15</td>
<td style="text-align: center;">31,15</td>
<td style="text-align: center;">47,16</td>
<td style="text-align: center;">125,47</td>
<td style="text-align: center;">364,68</td>
</tr>
<tr class="odd">
<td style="text-align: center;">PriorityBlockingQueue</td>
<td style="text-align: center;">78,78</td>
<td style="text-align: center;">172,188</td>
<td style="text-align: center;">360,422</td>
<td style="text-align: center;">813,969</td>
<td style="text-align: center;">3094,2641</td>
<td style="text-align: center;">6547,5453</td>
</tr>
</tbody>
</table>
<p>逗号前的数字是offer测试花费的时间，逗号后的数字是poll测试花费的时间，单位毫秒。
结论：</p>
<ol type="1">
<li><strong>ArrayBlockingQueue</strong>性能优于<strong>LinkedBlockingQueue</strong>,但是<strong>LinkedBlockingQueue</strong>是无界的。</li>
<li><strong>ArrayBlockingQueue</strong>和<strong>LinkedBlockingQueue</strong>的poll方法总是比offer方法快，并发越高，差距越大。</li>
<li><strong>ArrayBlockingQueue</strong>和<strong>LinkedBlockingQueue</strong>的性能远高于<strong>PriorityBlockingQueue</strong>，显然优先队列在比较优先级上的操作上耗费太多</li>
<li><strong>PriorityBlockingQueue</strong>的offer方法与poll方法的性能差距很小，基本维持在近似1：1</li>
</ol>
<h1
id="为什么wait和notify属于object类">为什么wait()和notify()属于Object类</h1>
<p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是<strong>JAVA提供的锁是对象级的而不是线程级的</strong>，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就没有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，<strong>由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</strong></p>
<h1 id="多线程中的-start-和-run">多线程中的 start() 和 run()</h1>
<ol type="1">
<li><strong>start</strong>():</li>
</ol>
<p>先来看看Java API中对于该方法的介绍：</p>
<p>使该线程开始执行；Java 虚拟机调用该线程的 <code>run</code> 方法。</p>
<p>结果是两个线程并发地运行；当前线程（从调用返回给 <code>start</code>
方法）和另一个线程（执行其 <code>run</code> 方法）。</p>
<p>多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</p>
<ul>
<li>用<strong>start方法</strong>来启动线程，真正实现了多线程运行，这时无需等待run方法体中的代码执行完毕而直接继续执行后续的代码。通过调用Thread类的
start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里的run()方法
称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。</li>
</ul>
<ol start="2" type="1">
<li><strong>run</strong>():</li>
</ol>
<p>同样先看看Java API中对该方法的介绍：</p>
<p>如果该线程是使用独立的 <code>Runnable</code> 运行对象构造的，则调用该
<code>Runnable</code> 对象的 <code>run</code>
方法；否则，该方法不执行任何操作并返回。</p>
<p><code>Thread</code> 的子类应该重写该方法。</p>
<ul>
<li>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</li>
</ul>
<ol start="3" type="1">
<li><strong>总结</strong>：</li>
</ol>
<p><strong>调用start方法方可启动线程，而run方法只是thread类中的一个普通方法调用，还是在主线程里执行。</strong></p>
<h1 id="cas-有哪些参数">CAS 有哪些参数</h1>
<p>在CAS中有三个参数：<strong>内存值V、旧的预期值A、要更新的值B</strong>。当且仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。</p>
<h1 id="最大核心线程数怎么定">最大核心线程数怎么定</h1>
<p>IO密集型（某大厂实践经验）： 核心线程数 = CPU核数 / （1-阻塞系数）
或者 CPU密集型：核心线程数 = CPU核数 + 1 IO密集型：核心线程数 = CPU核数
* 2</p>
<blockquote>
<p>不同种类的线程池都适用什么场景呢？</p>
</blockquote>
<p>选择的关键点是：</p>
<ol type="1">
<li>尽量减少线程切换和管理的开支</li>
<li>最大化利用cpu</li>
</ol>
<ul>
<li>并发比较高，耗时比较短的任务
<ul>
<li>这种场景适合线程尽量少，因为如果线程太多，任务执行时间段很快就执行完了，有可能出现线程切换和管理多耗费的时间，大于任务执行的时间，这样效率就低了。线程池线程数可以设置为CPU核数+1</li>
</ul></li>
<li>并发比较低，耗时比较长的任务
<ul>
<li><ol type="a">
<li>IO密集型：假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以可以加大线程池中的线程数目，这样一个io任务可能会执行很长时间，所以在执行io操作时它的cpu可以让出来去执行别的任务，让CPU处理更多的业务。线程池线程数可以设置为**CPU核数*2**</li>
</ol></li>
<li><ol start="2" type="a">
<li>计算密集型:
假如是业务时间长集中在计算操作上，也就是计算密集型任务,这个操作也需要使用cpu的，如果线程太多并且每个任务又特别耗时不但会影响其他业务，严重时还会导致cpu飙升100%，所以线程数不宜太多</li>
</ol></li>
</ul></li>
<li>并发高，耗时长的任务
<ul>
<li>解决这种类型任务的关键不在于线程池而在于整体架构的设计</li>
<li>首先第一步：看看这些业务里面某些数据是否能做缓存</li>
<li>第二步：看看能否把这些高并发，耗时长的任务能不能拆分成。高并发，低耗时，或者低并发，高耗时的场景</li>
<li>第三步：增加服务器数量，增加计算单元。</li>
</ul></li>
</ul>
<h1 id="多读少写的场景-如何提高性能">多读少写的场景 如何提高性能</h1>
<p>大家可以设想一下现在我们的内存里有一个ArrayList，这个ArrayList默认情况下肯定是线程不安全的，要是多个线程并发读和写这个ArrayList可能会有问题。</p>
<p>好，问题来了，我们应该<strong>怎么让这个ArrayList变成线程安全的呢</strong>？</p>
<p>有一个非常简单的办法，<strong>对这个ArrayList的访问都加上线程同步的控制</strong>。</p>
<p>比如说一定要在synchronized代码段来对这个ArrayList进行访问，这样的话，就能同一时间就让一个线程来操作它了，或者是用<code>ReadWriteLock读写锁</code>的方式来控制，都可以。</p>
<p>我们假设就是用<code>ReadWriteLock读写锁</code>的方式来控制对这个ArrayList的访问。</p>
<p>这样多个读请求可以同时执行从ArrayList里读取数据，但是读请求和写请求之间互斥，写请求和写请求也是互斥的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object  <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="comment">// 对ArrayList读取</span></span><br><span class="line">    lock.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="comment">// 对ArrayList写</span></span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最大的问题，其实就在于写锁和读锁的互斥</strong>。假设写操作频率很低，读操作频率很高，是写少读多的场景。</p>
<p>那么偶尔执行一个写操作的时候，是不是会加上写锁，此时大量的读操作过来是不是就会被阻塞住，无法执行？</p>
<p>这个就是读写锁可能遇到的最大的问题。</p>
<h2 id="引入-copyonwrite-思想解决问题">引入 CopyOnWrite
思想解决问题</h2>
<p>这个时候就要引入<strong>CopyOnWrite思想</strong>来解决问题了。</p>
<p>他的思想就是，不用加什么读写锁，锁统统给我去掉，有锁就有问题，有锁就有互斥，有锁就可能导致性能低下，你阻塞我的请求，导致我的请求都卡着不能执行。</p>
<p>那么他怎么保证多线程并发的安全性呢？</p>
<p>很简单，顾名思义，利用“<strong>CopyOnWrite</strong>”的方式，这个英语翻译成中文，大概就是“<strong>写数据的时候利用拷贝的副本来执行</strong>”。</p>
<p>你在读数据的时候，其实不加锁也没关系，大家左右都是一个读罢了，互相没影响。</p>
<p>问题主要是在写的时候，写的时候你既然不能加锁了，那么就得采用一个策略。</p>
<p>假如说你的ArrayList底层是一个数组来存放你的列表数据，那么这时比如你要修改这个数组里的数据，你就必须先拷贝这个数组的一个副本。</p>
<p>然后你可以在这个数组的副本里写入你要修改的数据，但是在这个过程中实际上你都是在操作一个副本而已。</p>
<p>这样的话，读操作是不是可以同时正常的执行？这个写操作对读操作是没有任何的影响的吧！</p>
<p>关键问题来了，那那个写线程现在把副本数组给修改完了，现在怎么才能让读线程感知到这个变化呢？</p>
<p>关键点来了，划重点！这里要配合上<strong>volatile关键字</strong>的使用。</p>
<p>笔者之前写过文章，给大家解释过volatile关键字的使用，核心就是让一个变量被写线程给修改之后，立马让其他线程可以读到这个变量引用的最近的值，这就是volatile最核心的作用。</p>
<p>所以一旦写线程搞定了副本数组的修改之后，那么就可以用volatile写的方式，把这个副本数组赋值给volatile修饰的那个数组的引用变量了。</p>
<p>只要一赋值给那个volatile修饰的变量，立马就会对读线程可见，大家都能看到最新的数组了。</p>
<p>下面是JDK里的 CopyOnWriteArrayList 的源码。</p>
<p>大家看看写数据的时候，他是怎么拷贝一个数组副本，然后修改副本，接着通过volatile变量赋值的方式，把修改好的数组副本给更新回去，立马让其他线程可见的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个数组是核心的，因为用volatile修饰了</span></span><br><span class="line"><span class="comment">// 只要把最新的数组对他赋值，其他线程立马可以看到最新的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">// 对数组拷贝一个副本出来</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对副本数组进行修改，比如在里面加入一个元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 然后把副本数组赋值给volatile修饰的变量</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后大家想，因为是通过副本来进行更新的，<strong>万一要是多个线程都要同时更新呢？</strong>那搞出来多个副本会不会有问题？</p>
<p>当然不能多个线程同时更新了，这个时候就是看上面源码里，加入了<strong>lock锁</strong>的机制，也就是同一时间只有一个线程可以更新。</p>
<p>那么更新的时候，会对读操作有任何的影响吗？</p>
<p>绝对不会，因为读操作就是非常简单的对那个数组进行读而已，不涉及任何的锁。而且只要他更新完毕对volatile修饰的变量赋值，那么读线程立马可以看到最新修改后的数组，这是volatile保证的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">      <span class="comment">// 最简单的对数组进行读取</span></span><br><span class="line">      <span class="keyword">return</span> (E) a[index];</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>
<p>这样就完美解决了我们之前说的读多写少的问题。</p>
<p>如果用读写锁互斥的话，会导致写锁阻塞大量读操作，影响并发性能。</p>
<p>但是如果用了<strong>CopyOnWriteArrayList</strong>，就是用空间换时间，更新的时候基于副本更新，避免锁，然后最后用<strong>volatile变量</strong>来赋值保证可见性，更新的时候对读线程没有任何的影响！</p>
<h1 id="简述happen-before-原则">简述Happen before 原则</h1>
<p>JMM可以通过happens-before关系向程序员提供<strong>跨线程的内存可见性保证</strong>（<strong>如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见</strong>）。</p>
<blockquote>
<p><strong>具体的定义为：</strong></p>
</blockquote>
<ol type="1">
<li><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p></li>
<li><p>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</p></li>
</ol>
<blockquote>
<p><strong>具体的规则：</strong></p>
</blockquote>
<ol type="1">
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before
C，那么A happens-before C。</li>
<li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li><strong>Join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li><strong>程序中断规则</strong>：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>
<li><strong>对象finalize规则</strong>：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>
</ol>
<h1 id="cas操作原理与实现">CAS操作原理与实现</h1>
<p><strong>CAS</strong>
是<strong>乐观锁</strong>的一种实现方式，他采用的是<strong>自旋锁</strong>(一直尝试,直到成功)的思想，是一种轻量级的锁机制。</p>
<p>CAS(Compare And
Swap)指<strong>比较并交换</strong>。CAS算法CAS(V,E,N)包含三个参数,<strong>V</strong>表示要更新的变量,<strong>E</strong>表示预期的值,<strong>N</strong>表示新值。仅在V值等于E值,才会将V值设为N,如果V值和E值不同,表示有其他线程进行更新,当前线程什么都不做,不会被挂起,允许再次尝试,直到成功。</p>
<p>CAS是采用了乐观锁的思想,总是认为自己可以成功完成操作。有多个线程同时使用CAS操作同一个变量时只有一个会成功更新,其余均会失败。</p>
<p>在Java中可以通过<strong>Unsafe类</strong>实现CAS操作，而Unsafe类最终调用的是<strong>native方法</strong>，即具体实现是由JVM中的方法实现的。而JVM中通过C++调用处理器的指令<code>cmpxchg</code>来实现的。</p>
<h1 id="线程间的通信方式">线程间的通信方式</h1>
<h2
id="锁机制包括互斥锁条件变量读写锁">锁机制：包括互斥锁、条件变量、读写锁</h2>
<p>互斥锁提供了以排他方式防止数据结构被并发修改的方法。
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p>
<p>wait/notify 等待</p>
<p>Volatile 内存共享</p>
<p>CountDownLatch 并发工具</p>
<p>CyclicBarrier 并发工具</p>
<h2 id="信号量机制semaphore">信号量机制(Semaphore)</h2>
<p>包括无名线程信号量和命名线程信号量。</p>
<h2 id="信号机制signal">信号机制(Signal)</h2>
<p>类似进程间的信号处理。</p>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<h2 id="waitnotify-等待">wait/notify 等待</h2>
<p>等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。</p>
<p><strong>为什么要必须获取锁？</strong>
因为调用wait方法时，必须要先释放锁，如果没有持有锁将会抛出异常。</p>
<p>wait:
使当前线程放弃同步锁并进入等待，直到其他线程进入此同步锁，并调用notify()方法，或notifyAll()方法唤醒该线程为止。</p>
<p>notify(): 唤醒此同步锁上等待的第一个调用wait()方法的线程。</p>
<p>notifyAll(): 唤醒同步锁上调用wait()方法的所有线程。</p>
<h2 id="volatile-内存共享">Volatile 内存共享</h2>
<p>volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。</p>
<p>volatile语义保证线程可见性有两个原则保证</p>
<p>所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存
所有volatile修饰的变量在使用之前必须重新读取主内存的值</p>
<p>工作内存2能够感知到工作内存1更新a值是靠的总线，工作内存1在将值刷新的主内存时必须经过总线，总线就能告知其他线程有值被改变，那么其他线程就会主动读取主内存的值来更新。</p>
<p>CountDownLatch 并发工具</p>
<p>CyclicBarrier 并发工具</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8FconcurrentHashMap/" rel="prev" title="concurrentHashMap详解">
      <i class="fa fa-chevron-left"></i> concurrentHashMap详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8Fjava%E5%9F%BA%E7%A1%80/" rel="next" title="Java基础">
      Java基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E5%9B%BE%E8%A7%A3aqs%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">深入图解AQS实现原理和源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cas%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">CAS底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%81%8F%E7%A7%BB%E9%87%8F%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">段地址、偏移量和逻辑地址关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unsafe%E4%B8%ADcas%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.2.</span> <span class="nav-text">Unsafe中CAS实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aqs%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">AQS实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aqs%E7%9A%84%E7%8B%AC%E5%8D%A0%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">AQS的独占锁和共享锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aqs%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">AQS内部实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">线程之间为什么是不可见的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%81%87%E5%88%B0%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="nav-number">3.</span> <span class="nav-text">在项目开发中的遇到的并发问题是怎么解决的</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">相关概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">核心问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C"><span class="nav-number">4.</span> <span class="nav-text">实现多线程的方式，两个线程交替执行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">线程的三种创建方式和他们的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">线程的三种创建方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">5.2.</span> <span class="nav-text">三种创建方式优缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Ejava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">关于JAVA线程池关键参数，拒绝策略，调度方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">线程池核心参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">线程池调度方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">6.3.</span> <span class="nav-text">线程池中的拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E4%BB%A5%E5%8F%8A%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">7.</span> <span class="nav-text">Java的内存模型JMM以及共享变量的可见性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">volatile变量的作用及特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile%E5%8E%9F%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">volatile原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">volatile与synchronized的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized%E5%92%8Creentrantlock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">11.</span> <span class="nav-text">synchronized和ReentrantLock实现原理和区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cas%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">12.</span> <span class="nav-text">CAS原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-cascompare-and-swap"><span class="nav-number">12.1.</span> <span class="nav-text">乐观锁的实现方式-CAS（Compare
and Swap）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E7%A7%BB"><span class="nav-number">13.</span> <span class="nav-text">线程的状态及转移</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE"><span class="nav-number">13.1.</span> <span class="nav-text">状态转移图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E6%80%81%E5%88%B0%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="nav-number">13.2.</span> <span class="nav-text">新建态到就绪态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E6%80%81%E5%88%B0%E8%BF%90%E8%A1%8C%E6%80%81"><span class="nav-number">13.3.</span> <span class="nav-text">就绪态到运行态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%80%81%E5%88%B0%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="nav-number">13.4.</span> <span class="nav-text">运行态到就绪态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E7%94%A8%E5%AE%8C"><span class="nav-number">13.4.1.</span> <span class="nav-text">时间片用完</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t1.yield-thread.yield"><span class="nav-number">13.4.2.</span> <span class="nav-text">t1.yield() 、Thread.yield();</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%80%81%E5%88%B0%E9%98%BB%E5%A1%9E%E6%80%81"><span class="nav-number">13.5.</span> <span class="nav-text">运行态到阻塞态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#thread.sleep"><span class="nav-number">13.5.1.</span> <span class="nav-text">Thread.sleep()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t2.join"><span class="nav-number">13.5.2.</span> <span class="nav-text">t2.join()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t1%E7%AD%89%E5%BE%85%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%AD%89%E5%BE%85%E9%94%AE%E7%9B%98%E5%93%8D%E5%BA%94"><span class="nav-number">13.5.3.</span> <span class="nav-text">t1等待用户输入，等待键盘响应</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E6%80%81%E5%88%B0%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="nav-number">13.6.</span> <span class="nav-text">阻塞态到就绪态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%80%81%E5%88%B0%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">13.7.</span> <span class="nav-text">运行态到等待队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%80%81%E5%88%B0%E9%94%81%E6%B1%A0%E9%98%9F%E5%88%97"><span class="nav-number">13.7.1.</span> <span class="nav-text">运行态到锁池队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E5%88%B0%E9%94%81%E6%B1%A0%E9%98%9F%E5%88%97"><span class="nav-number">13.8.</span> <span class="nav-text">等待队列到锁池队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E6%B1%A0%E9%98%9F%E5%88%97%E5%88%B0%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="nav-number">13.9.</span> <span class="nav-text">锁池队列到就绪态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%80%81%E5%88%B0%E6%AD%BB%E4%BA%A1%E6%80%81"><span class="nav-number">13.10.</span> <span class="nav-text">运行态到死亡态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">14.</span> <span class="nav-text">Java中如何保证线程安全性（多线程三大特性）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sleep%E5%92%8Cwait%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">15.</span> <span class="nav-text">sleep和wait有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E7%AD%96%E7%95%A5"><span class="nav-number">16.</span> <span class="nav-text">Synchronized锁升级的策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E5%8E%9F%E7%90%86"><span class="nav-number">16.1.</span> <span class="nav-text">锁升级原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">16.2.</span> <span class="nav-text">无锁升级为偏向锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">16.3.</span> <span class="nav-text">偏向锁升级为轻量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">16.4.</span> <span class="nav-text">轻量级锁升级为重量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gc%E6%A0%87%E5%BF%97"><span class="nav-number">16.5.</span> <span class="nav-text">GC标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%8D%E7%BA%A7%E7%9A%84%E7%9B%AE%E7%9A%84%E5%92%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">16.6.</span> <span class="nav-text">降级的目的和过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0"><span class="nav-number">17.</span> <span class="nav-text">如何设置线程池参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">18.</span> <span class="nav-text">Java中线程同步的方式有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">18.1.</span> <span class="nav-text">synchronized关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">18.2.</span> <span class="nav-text">重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">18.3.</span> <span class="nav-text">volatile关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">18.4.</span> <span class="nav-text">使用局部变量实现线程同步</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">19.</span> <span class="nav-text">线程池的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">19.1.</span> <span class="nav-text">线程池的几个主要参数的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">19.2.</span> <span class="nav-text">任务提交后的流程分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized%E5%8F%AF%E4%BB%A5%E9%94%81%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">20.</span> <span class="nav-text">synchronized可以锁的内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#countdownlatch%E5%8E%9F%E7%90%86"><span class="nav-number">21.</span> <span class="nav-text">CountDownLatch原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E7%82%B9"><span class="nav-number">22.</span> <span class="nav-text">为什么要用线程池(线程池优点)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#arraylist%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8arraylist"><span class="nav-number">23.</span> <span class="nav-text">ArrayList线程安全吗？多线程环境下怎么使用ArrayList？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%93%E7%8E%B0"><span class="nav-number">23.1.</span> <span class="nav-text">线程不安全的两种体现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8-arrayindexoutofboundsexception"><span class="nav-number">23.1.1.</span> <span class="nav-text">数组越界异常
ArrayIndexOutOfBoundsException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%80%BC%E8%A6%86%E7%9B%96%E5%92%8C%E4%B8%BA%E7%A9%BA%E9%97%AE%E9%A2%98"><span class="nav-number">23.1.2.</span> <span class="nav-text">元素值覆盖和为空问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arraylist%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86"><span class="nav-number">23.2.</span> <span class="nav-text">ArrayList线程安全处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#collections.synchronizedlist"><span class="nav-number">23.2.1.</span> <span class="nav-text">Collections.synchronizedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BAlist.add%E6%96%B9%E6%B3%95%E5%8A%A0%E9%94%81"><span class="nav-number">23.2.2.</span> <span class="nav-text">为list.add()方法加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copyonwritearraylist"><span class="nav-number">23.2.3.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8threadlocal"><span class="nav-number">23.2.4.</span> <span class="nav-text">使用ThreadLocal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E8%87%AA%E5%B8%A6%E7%9A%844%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">24.</span> <span class="nav-text">java自带的4种线程池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A7%81%E6%9C%89%E8%B5%84%E6%BA%90%E4%B8%8E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">25.</span> <span class="nav-text">线程的私有资源与共享资源</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#atomicinteger%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">26.</span> <span class="nav-text">AtomicInteger底层实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E7%BA%BF%E7%A8%8B%E6%8A%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E6%8A%93%E5%8F%96%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%96%E6%8D%95%E8%8E%B7"><span class="nav-number">27.</span> <span class="nav-text">线程池里线程报的异常如何抓取，在线程池外捕获</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-number">28.</span> <span class="nav-text">阻塞队列的性能对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E5%B1%9E%E4%BA%8Eobject%E7%B1%BB"><span class="nav-number">29.</span> <span class="nav-text">为什么wait()和notify()属于Object类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84-start-%E5%92%8C-run"><span class="nav-number">30.</span> <span class="nav-text">多线程中的 start() 和 run()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cas-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0"><span class="nav-number">31.</span> <span class="nav-text">CAS 有哪些参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%80%8E%E4%B9%88%E5%AE%9A"><span class="nav-number">32.</span> <span class="nav-text">最大核心线程数怎么定</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E8%AF%BB%E5%B0%91%E5%86%99%E7%9A%84%E5%9C%BA%E6%99%AF-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD"><span class="nav-number">33.</span> <span class="nav-text">多读少写的场景 如何提高性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-copyonwrite-%E6%80%9D%E6%83%B3%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-number">33.1.</span> <span class="nav-text">引入 CopyOnWrite
思想解决问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0happen-before-%E5%8E%9F%E5%88%99"><span class="nav-number">34.</span> <span class="nav-text">简述Happen before 原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cas%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">35.</span> <span class="nav-text">CAS操作原理与实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">36.</span> <span class="nav-text">线程间的通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6%E5%8C%85%E6%8B%AC%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">36.1.</span> <span class="nav-text">锁机制：包括互斥锁、条件变量、读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6semaphore"><span class="nav-number">36.2.</span> <span class="nav-text">信号量机制(Semaphore)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6signal"><span class="nav-number">36.3.</span> <span class="nav-text">信号机制(Signal)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#waitnotify-%E7%AD%89%E5%BE%85"><span class="nav-number">36.4.</span> <span class="nav-text">wait&#x2F;notify 等待</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB"><span class="nav-number">36.5.</span> <span class="nav-text">Volatile 内存共享</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

