<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="作一些可以约定的约定 就抱紧以后每一天">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FMySQL/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="作一些可以约定的约定 就抱紧以后每一天">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3lq6e.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o33328.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3GrB4.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3J9Ej.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3Jtqe.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3JBGt.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3Jrxf.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3JRaj.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3Uh0U.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3Uq6x.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3aEB8.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3aN4J.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3wyfH.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o38VJ0.md.gif">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3rxM9.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o360v4.md.gif">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3cMIx.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3g0B9.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/30/o3gb38.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/22/T1Gq2Q.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/22/T1DmX8.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/22/T1D3hn.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/22/T1DhAH.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/22/T1D7gP.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/22/T1ydHS.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/22/T1y0Ag.md.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjx1mu02wbj31160kk0vj.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjx1muypwdj31420jg41q.jpg">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/25/7H8TVx.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/25/7H8zqI.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/25/7HGNe1.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/25/7HG2wt.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/25/7HJi01.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/25/7HJY9S.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/25/7HJXDA.md.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5684201-36cbbd349ba47f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/283/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5684201-27874232c0422cd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/254/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5684201-d5da170d4922524c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/485/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5684201-deb2a90d72846e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/481/format/webp">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111138450-546456756.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111159462-561854332.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111220152-587480759.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111239548-1039643011.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111302657-1219381120.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111321745-614563546.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111524049-1397592588.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111536369-2106547600.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111546864-2006295667.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111557047-915156981.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15729314-5c745ddee0791a6b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/628/format/webp">
<meta property="article:published_time" content="2022-03-04T12:46:25.465Z">
<meta property="article:modified_time" content="2022-03-04T05:17:41.352Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/11/30/o3lq6e.md.png">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FMySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FMySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-04 20:46:25 / 修改时间：13:17:41" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <div class="post-description"><blockquote class="blockquote-center">作一些可以约定的约定 就抱紧以后每一天</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="什么是MySQL？"><a href="#什么是MySQL？" class="headerlink" title="什么是MySQL？"></a>什么是MySQL？</h1><p><strong>MySQL</strong>是一种开放源代码的<code>关系型数据库管理系统</code>（RDBMS），使用最常用的数据库管理语言–<code>结构化查询语言（SQL）</code>进行数据库管理。MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。</p>
<h1 id="MySQL的数据类型有哪些"><a href="#MySQL的数据类型有哪些" class="headerlink" title="MySQL的数据类型有哪些"></a>MySQL的数据类型有哪些</h1><ul>
<li><p><strong>整数</strong></p>
<ul>
<li>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT分别占用8、16、24、32、64位存储空间。值得注意的是，INT(10)中的10只是表示显示字符的个数，并无实际意义。一般和UNSIGNED ZEROFILL配合使用才有实际意义，例如，数据类型INT(3)，属性为UNSIGNED ZEROFILL，如果插入的数据为3的话，实际存储的数据为003。</li>
</ul>
</li>
<li><p><strong>浮点数</strong></p>
<ul>
<li>FLOAT、DOUBLE及DECIMAL为浮点数类型，DECIMAL是利用字符串进行处理的，能存储精确的小数。相比于FLOAT和DOUBLE，DECIMAL的效率更低些。FLOAT、DOUBLE及DECIMAL都可以指定列宽，例如FLOAT(5,2)表示一共5位，两位存储小数部分，三位存储整数部分。</li>
</ul>
</li>
<li><p><strong>字符串</strong></p>
<ul>
<li>字符串常用的主要有CHAR和VARCHAR，VARCHAR主要用于存储可变长字符串，相比于定长的CHAR更节省空间。CHAR是定长的，根据定义的字符串长度分配空间。</li>
<li><code>应用场景</code>：对于经常变更的数据使用CHAR更好，CHAR不容易产生碎片。对于非常短的列也是使用CHAR更好些，CHAR相比于VARCHAR在效率上更高些。一般避免使用TEXT&#x2F;BLOB等类型，因为查询时会使用临时表，造成严重的性能开销。</li>
</ul>
</li>
<li><p><strong>日期</strong></p>
<ul>
<li>比较常用的有year、time、date、datetime、timestamp等，datetime保存从1000年到9999年的时间，精度位秒，使用8字节的存储空间，与时区无关。timestamp和UNIX的时间戳相同，保存从1970年1月1日午夜到2038年的时间，精度到秒，使用四个字节的存储空间，并且与时区相关。</li>
<li><code>应用场景</code>：尽量使用timestamp，相比于datetime它有着更高的空间效率。</li>
</ul>
</li>
</ul>
<h1 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h1><p><strong>索引</strong>是对数据库表的一列或者多列的值进行排序一种结构，使用索引可以快速访问数据表中的特定信息。</p>
<h1 id="MySQL索引有什么优缺点"><a href="#MySQL索引有什么优缺点" class="headerlink" title="MySQL索引有什么优缺点"></a>MySQL索引有什么优缺点</h1><blockquote>
<p><strong>索引的优点</strong></p>
</blockquote>
<ol>
<li><p>创建<strong>唯一性索引</strong>，保证数据库表中每一行数据的唯一性；</p>
</li>
<li><p>大大<strong>加快数据的检索速度</strong>，这也是<code>创建索引的最主要原因</code>；</p>
</li>
<li><p><strong>加速表和表之间的连接</strong>，特别是在实现数据的参考完整性方面特别有意义；</p>
</li>
<li><p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</p>
</li>
<li><p>通过使用索引，可以<code>在查询的过程中使用优化隐藏器</code>，提高系统性能。</p>
</li>
</ol>
<blockquote>
<p><strong>索引的缺点</strong></p>
</blockquote>
<ol>
<li><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加；</p>
</li>
<li><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大；</p>
</li>
<li><p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。</p>
</li>
</ol>
<h1 id="MySQL索引底层：B-树"><a href="#MySQL索引底层：B-树" class="headerlink" title="MySQL索引底层：B+树"></a>MySQL索引底层：B+树</h1><p><strong>索引底层</strong>是用的<strong>B+tree</strong>数据结构，这种结构可以大幅度提升查询性能，因为<strong>B+tree底层是由叶子节点组成的单向列表</strong> ，塑造出它的稳定性,尤其是范围内的数据检索。B树遍历需要繁琐的中序遍历，B+树就不需要，直接读取单链表就可以获取到范围内数据，由于B+tree相比较于B树，其树的的高度会相比较低,所以在遍历时会少很多遍历的时间,在时间复杂度上就已经很低。所以B+tree是目前为止性能最高的索引结构。索引之所快也就是将传统的顺序遍历改为<strong>二分查找</strong> ，可以使得要遍历的次数很大程度上减少。</p>
<ol>
<li><p>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
</li>
<li><p>所有的叶子结点中包含了<strong>全部元素的信息</strong>，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
</li>
<li><p>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p>
</li>
</ol>
<h2 id="树的简介"><a href="#树的简介" class="headerlink" title="树的简介"></a>树的简介</h2><p>树跟数组、链表、堆栈一样，是一种数据结构。它由有限个节点，组成具有层次关系的集合。因为它看起来像一棵树，所以得其名。</p>
<p>树是包含n(n为整数，大于0)个结点， n-1条边的有穷集，它有以下特点：</p>
<ul>
<li>每个结点或者无子结点或者只有有限个子结点;</li>
<li>有一个特殊的结点,它没有父结点，称为根结点;</li>
<li>每一个非根节点有且只有一个父节点;</li>
<li>树里面没有环路</li>
</ul>
<p>一些有关于树的概念：</p>
<ul>
<li><p><strong>结点的度</strong>：一个结点含有的子结点个数称为该结点的度;</p>
</li>
<li><p><strong>树的度</strong>：一棵树中，最大结点的度称为树的度;</p>
</li>
<li><p><strong>父结点</strong>：若一个结点含有子结点，则这个结点称为其子结点的父结点;</p>
</li>
<li><p><strong>深度</strong>：对于任意结点n,n的深度为从根到n的唯一路径长，根结点的深度为0;</p>
</li>
<li><p><strong>高度</strong>：对于任意结点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0</p>
</li>
</ul>
<h2 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h2><p>按照<strong>有序性</strong> ，可以分为有序树和无序树：</p>
<ul>
<li><strong>无序树</strong>：树中任意节点的子结点之间没有顺序关系</li>
<li><strong>有序树</strong>：树中任意节点的子结点之间有顺序关系</li>
</ul>
<p>按照<strong>节点包含子树个数</strong> ，可以分为B树和二叉树，二叉树可以分为以下几种：</p>
<ul>
<li><p><strong>二叉树</strong>：每个节点最多含有两个子树的树称为二叉树;</p>
</li>
<li><p><strong>二叉查找树</strong>：首先它是一颗二叉树，若左子树不空，则左子树上所有结点的值均小于它的根结点的值;若右子树不空，则右子树上所有结点的值均大于它的根结点的值;左、右子树也分别为二叉排序树;</p>
<ul>
<li><strong>红黑树</strong> ：红黑树是一颗特殊的二叉查找树，每个节点都是黑色或者红色，根节点、叶子节点是黑色。如果一个节点是红色的，则它的子节点必须是黑色的;</li>
</ul>
</li>
<li><p><strong>满二叉树</strong>：叶节点除外的所有节点均含有两个子树的树被称为满二叉树;</p>
</li>
<li><p><strong>完全二叉树</strong>：如果一颗二叉树除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布;</p>
</li>
<li><p><strong>霍夫曼树</strong>：带权路径最短的二叉树;</p>
</li>
<li><p><strong>平衡二叉树(AVL)</strong> ：一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p>
</li>
</ul>
<h2 id="B-树、B-树简介"><a href="#B-树、B-树简介" class="headerlink" title="B-树、B+树简介"></a>B-树、B+树简介</h2><h3 id="B-树简介"><a href="#B-树简介" class="headerlink" title="B-树简介"></a>B-树简介</h3><p><strong>B-树</strong>，也称为B树，是一种平衡的多叉树(可以对比一下平衡二叉查找树)，它比较适用于对外查找。看下这几个概念：</p>
<ul>
<li><strong>阶数</strong>：一个节点最多有多少个孩子节点。(一般用字母m表示)</li>
<li><strong>关键字</strong>：节点上的数值就是关键字</li>
<li><strong>度</strong>：一个节点拥有的子节点的数量。</li>
</ul>
<p>一颗<code>m阶的B-树</code>，有以下特征：</p>
<ul>
<li>根结点至少有两个子女;</li>
<li>每个非根节点所包含的关键字个数 j 满足：⌈m&#x2F;2⌉ - 1 &lt;&#x3D; j &lt;&#x3D; m - 1.(⌈⌉表示向上取整)</li>
<li>有k个关键字(关键字按递增次序排列)的非叶结点恰好有k+1个孩子。</li>
<li>所有的叶子结点都位于同一层。</li>
</ul>
<p>一棵简单的B-树如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3lq6e"><img src="https://z3.ax1x.com/2021/11/30/o3lq6e.md.png" alt="o3lq6e.md.png"></a></p>
<h3 id="B-树简介-1"><a href="#B-树简介-1" class="headerlink" title="B+树简介"></a>B+树简介</h3><p>B+树是B-树的变体，也是一颗多路搜索树。一棵<strong>m阶的B+树</strong>主要有这些特点：</p>
<ul>
<li><p>每个结点至多有m个子女;</p>
</li>
<li><p>非根节点关键值个数范围：⌈m&#x2F;2⌉ - 1 &lt;&#x3D; k &lt;&#x3D; m-1</p>
</li>
<li><p>相邻叶子节点是通过指针连起来的，并且是关键字大小排序的。</p>
</li>
</ul>
<p>一颗<code>3阶的B+树</code>如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o33328"><img src="https://z3.ax1x.com/2021/11/30/o33328.md.png" alt="o33328.md.png"></a></p>
<h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>B+树插入要记住这几个步骤：</p>
<ol>
<li>B+树插入都是在叶子结点进行的，就是插入前，需要先找到要插入的叶子结点。</li>
<li>如果被插入关键字的叶子节点，当前含有的关键字数量是小于阶数m，则直接插入。</li>
<li>如果插入关键字后，叶子节点当前含有的关键字数目等于阶数m，则插，该节点开始「分裂」为两个新的节点，一个节点包含⌊m&#x2F;2⌋ 个关键字，另外一个关键字包含⌈m&#x2F;2⌉个关键值。(⌊m&#x2F;2⌋表示向下取整，⌈m&#x2F;2⌉表示向上取整，如⌈3&#x2F;2⌉&#x3D;2)。</li>
<li>分裂后，需要将第⌈m&#x2F;2⌉的关键字上移到父结点。如果这时候父结点中包含的关键字个数小于m，则插入操作完成。</li>
<li>分裂后，需要将⌈m&#x2F;2⌉的关键字上移到父结点。如果父结点中包含的关键字个数等于m，则继续分裂父结点。</li>
</ol>
<p>以一颗4阶的B+树为例子吧，4阶的话，关键值最多3(m-1)个。假设插入以下数据43,48，36，32,37,49,28.</p>
<ol>
<li><p>在空树中插入43</p>
<ul>
<li>这时候根结点就一个关键值，此时它是根结点也是叶子结点。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3GrB4"><img src="https://z3.ax1x.com/2021/11/30/o3GrB4.md.png" alt="o3GrB4.md.png"></a></p>
<ol start="2">
<li><p>依次插入48，36</p>
<ul>
<li>这时候跟节点拥有3个关键字，已经满了</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3J9Ej"><img src="https://z3.ax1x.com/2021/11/30/o3J9Ej.md.png" alt="o3J9Ej.md.png"></a></p>
<ol start="3">
<li>继续插入 32，发现当前节点关键字已经不小于阶数4了，于是分裂 第⌈4&#x2F;2⌉&#x3D;2(下标0,1,2)个，也即43上移到父节点</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3Jtqe"><img src="https://z3.ax1x.com/2021/11/30/o3Jtqe.md.png" alt="o3Jtqe.md.png"></a></p>
<ol start="4">
<li>继续插入37，49，前节点关键字都是还没满的，直接插入，如下：</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3JBGt"><img src="https://z3.ax1x.com/2021/11/30/o3JBGt.md.png" alt="o3JBGt.md.png"></a></p>
<ol start="5">
<li>最后插入28，发现当前节点关键字也是不小于阶数4了，于是分裂，于是分裂， 第 ⌈4&#x2F;2⌉&#x3D;2个，也就是36上移到父节点，因父子节点只有2个关键值，还是小于4的，所以不用继续分裂，插入完成</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3Jrxf"><img src="https://z3.ax1x.com/2021/11/30/o3Jrxf.md.png" alt="o3Jrxf.md.png"></a></p>
<h3 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B+树的查找"></a>B+树的查找</h3><p>因为B+树的数据都是在叶子节点上的，内部节点只是指针索引的作用，因此，查找过程需要搜索到叶子节点上。还是以这颗B+树为例吧：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3JRaj"><img src="https://z3.ax1x.com/2021/11/30/o3JRaj.md.png" alt="o3JRaj.md.png"></a></p>
<h4 id="B-树单值查询"><a href="#B-树单值查询" class="headerlink" title="B+ 树单值查询"></a>B+ 树单值查询</h4><p>假设我们要查的值为32.</p>
<p>第一次磁盘 I&#x2F;O，查找磁盘块1，即根节点(36,43),因为32小于36，因此访问根节点的左边第一个孩子节点。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3Uh0U"><img src="https://z3.ax1x.com/2021/11/30/o3Uh0U.md.png" alt="o3Uh0U.md.png"></a></p>
<p>第二次磁盘 I&#x2F;O, 查找磁盘块2，即根节点的第一个孩子节点，获得区间(28,32),遍历即可得32.</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3Uq6x"><img src="https://z3.ax1x.com/2021/11/30/o3Uq6x.md.png" alt="o3Uq6x.md.png"></a></p>
<h4 id="B-树范围查询"><a href="#B-树范围查询" class="headerlink" title="B+ 树范围查询"></a>B+ 树范围查询</h4><p>假设我们要查找区间 [32,40]区间的值.</p>
<p>第一步先访问根节点，发现区间的左端点32小于36,则访问根节点的第一个左子树(28,32);</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3aEB8"><img src="https://z3.ax1x.com/2021/11/30/o3aEB8.md.png" alt="o3aEB8.md.png"></a></p>
<p>第二步访问节点(28,32)，找到32，于是开始遍历链表，把[32,40]区间值找出来，这也是B+树比B-树高效的地方。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3aN4J"><img src="https://z3.ax1x.com/2021/11/30/o3aN4J.md.png" alt="o3aN4J.md.png"></a></p>
<h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>B+树删除关键字，分这几种情况</p>
<ul>
<li>找到包含关键值的结点，如果关键字个数大于⌈m&#x2F;2⌉-1，直接删除即可;</li>
<li>找到包含关键值的结点,如果关键字个数大于⌈m&#x2F;2⌉-1，并且关键值是当前节点的最大(小)值，并且该关键值存在父子节点中，那么删除该关键字，同时需要相应调整父节点的值。</li>
<li>找到包含关键值的结点，如果删除该关键字后，关键字个数小于⌈m&#x2F;2⌉，并且其兄弟结点有多余的关键字，则从其兄弟结点借用关键字。</li>
<li>找到包含关键值的结点，如果删除该关键字后，关键字个数小于⌈m&#x2F;2⌉，并且其兄弟结点没有多余的关键字，则与兄弟结点合并。</li>
</ul>
<p><strong>如果关键字个数大于⌈m&#x2F;2⌉，直接删除即可;</strong></p>
<p>假设当前有这么一颗5阶的B+树</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3wyfH"><img src="https://z3.ax1x.com/2021/11/30/o3wyfH.md.png" alt="o3wyfH.md.png"></a></p>
<p>如果删除22，因为关键字个数为3 &gt; ⌈5&#x2F;2⌉-1&#x3D;2， 直接删除(⌈⌉表示向上取整的意思)</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o38VJ0"><img src="https://z3.ax1x.com/2021/11/30/o38VJ0.md.gif" alt="o38VJ0.md.gif"></a></p>
<p><strong>如果关键字个数大于⌈m&#x2F;2⌉-1，并且删除的关键字存在于父子节点中，那么需要相应调整父子节点的值。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3rxM9"><img src="https://z3.ax1x.com/2021/11/30/o3rxM9.md.png" alt="o3rxM9.md.png"></a></p>
<p>如果删除20，因为关键字个数为3 &gt; ⌈5&#x2F;2⌉-1&#x3D;2，并且20是当前节点的边界值，且存在父子节点中，所以删除后，其父子节点也要响应调整。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o360v4"><img src="https://z3.ax1x.com/2021/11/30/o360v4.md.gif" alt="o360v4.md.gif"></a></p>
<p><strong>如果删除该关键字后，关键字个数小于⌈m&#x2F;2⌉-1，兄弟节点可以借用。</strong></p>
<p>以下这颗5阶的B+树，</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3cMIx"><img src="https://z3.ax1x.com/2021/11/30/o3cMIx.md.png" alt="o3cMIx.md.png"></a></p>
<p>如果删除15,删除关键字的结点只剩1个关键字，小于⌈5&#x2F;2⌉-1&#x3D;2，不满足B+树特点，但是其兄弟节点拥有3个元素(7,8,9)，可以借用9过来。</p>
<p><strong>在删除关键字后，如果导致其结点中关键字个数不足，并且兄弟结点没有得借用的话，需要合并兄弟结点。</strong></p>
<h2 id="B-树经典面试题"><a href="#B-树经典面试题" class="headerlink" title="B+树经典面试题"></a>B+树经典面试题</h2><h3 id="InnoDB一棵B-树可以存放多少行数据"><a href="#InnoDB一棵B-树可以存放多少行数据" class="headerlink" title="InnoDB一棵B+树可以存放多少行数据?"></a>InnoDB一棵B+树可以存放多少行数据?</h3><p>这个问题的简单回答是：约2千万行。</p>
<ul>
<li>在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节。</li>
<li>文件系统中，最小单位是块，一个块大小就是4k;</li>
<li>InnoDB存储引擎最小储存单元是页，一页大小就是16k。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3g0B9"><img src="https://z3.ax1x.com/2021/11/30/o3g0B9.md.png" alt="o3g0B9.md.png"></a></p>
<p>因为B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据;</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3gb38"><img src="https://z3.ax1x.com/2021/11/30/o3gb38.md.png" alt="o3gb38.md.png"></a></p>
<p>假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为&#x3D;根结点指针数*单个叶子节点记录行数。</p>
<ul>
<li>如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 &#x3D;16k&#x2F;1k &#x3D;16.</li>
<li>非叶子节点内存放多少指针呢?我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，所以就是8+6&#x3D;14字节，16k&#x2F;14B &#x3D;16*1024B&#x2F;14B &#x3D; 1170</li>
</ul>
<p>因此，一棵高度为2的B+树，能存放1170 * 16&#x3D;18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 &#x3D;21902400，也就是说，可以存放两千万左右的记录。B+树高度一般为1-3层，已经满足千万级别的数据存储。</p>
<h3 id="B-Tree索引和Hash索引区别"><a href="#B-Tree索引和Hash索引区别" class="headerlink" title="B+ Tree索引和Hash索引区别"></a>B+ Tree索引和Hash索引区别</h3><ul>
<li><p><strong>哈希索引</strong>适合等值查询，但是无法进行范围查询；</p>
</li>
<li><p><strong>哈希索引</strong>没办法利用索引完成排序；</p>
</li>
<li><p><strong>哈希索引</strong>不支持多列联合索引的最左匹配规则 ；</p>
</li>
<li><p>如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
</li>
</ul>
<h3 id="为什么索引结构默认使用B-树，而不是B-Tree，Hash哈希，二叉树，红黑树"><a href="#为什么索引结构默认使用B-树，而不是B-Tree，Hash哈希，二叉树，红黑树" class="headerlink" title="为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树?"></a>为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树?</h3><p>简单版回答如下：</p>
<ul>
<li><p><code>Hash哈希</code></p>
<ul>
<li>虽然可以快速定位，但没有顺序，IO复杂度高</li>
<li>基于hash表实现，只有memory存储引擎显式支持哈希索引</li>
<li>适合等值查询，不支持范围查询，hash索引在查询等值时非常快</li>
<li>因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序</li>
<li>hash索引始终索引所有列的全部内容，索引不支持部分索引列的匹配查找</li>
<li>如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</li>
</ul>
</li>
<li><p><code>一般二叉树</code>，可能会特殊化为一个链表，相当于全表扫描。</p>
</li>
<li><p><code>红黑树</code>，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。</p>
</li>
<li><p><code>B-Tree</code>，叶子节点和非叶子节点都保存数据，相同的数据量，B+树更矮壮，也是就说，<strong>相同的数据量，B+树数据结构，查询磁盘的次数会更少。</strong></p>
</li>
</ul>
<h3 id="Hash比B-树更快，为啥mysql还用B-树来存索引？"><a href="#Hash比B-树更快，为啥mysql还用B-树来存索引？" class="headerlink" title="Hash比B+树更快，为啥mysql还用B+树来存索引？"></a>Hash比B+树更快，为啥mysql还用B+树来存索引？</h3><p>和具体的业务场景有关，如果只选一个数据，那确实hash更快。但是数据库中经常会选择多条，这时B+树索引就更快了。</p>
<p>而且数据库中索引一般放在磁盘中，数据量大的情况，无法一次装入内存，B+数的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。</p>
<h3 id="MySQL为什么使用B-树作为索引？"><a href="#MySQL为什么使用B-树作为索引？" class="headerlink" title="MySQL为什么使用B+树作为索引？"></a>MySQL为什么使用B+树作为索引？</h3><ol>
<li><p><strong>B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
</li>
<li><p><strong>B+树的查询效率更加稳定</strong>：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
<li><p><strong>B+树更便于遍历</strong>：由于<strong>B+树的数据都存储在叶子结点中</strong>，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。B+叶子节点依据关键字的大小从小到大顺序链接，形成一个有序链表。</p>
</li>
<li><p><strong>B+树更适合基于范围的查询</strong>：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p>
</li>
</ol>
<h3 id="B-树和B-树的区别"><a href="#B-树和B-树的区别" class="headerlink" title="B-树和B+树的区别"></a>B-树和B+树的区别</h3><ul>
<li>B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。</li>
<li>B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。</li>
<li>查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束。</li>
<li>B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。</li>
</ul>
<p>比起B树，B+树：</p>
<ol>
<li>IO次数更少 </li>
<li>查询性能很稳定 </li>
<li>范围查询更简便</li>
</ol>
<h1 id="MySQL常用的存储引擎有什么？"><a href="#MySQL常用的存储引擎有什么？" class="headerlink" title="MySQL常用的存储引擎有什么？"></a>MySQL常用的存储引擎有什么？</h1><ul>
<li><p><strong>InnoDB</strong></p>
<ul>
<li>InnoDB是MySQL的默认存储引擎，支持事务、<strong>行锁</strong>和外键等操作。</li>
</ul>
</li>
<li><p><strong>MyISAM</strong></p>
<ul>
<li>MyISAM是MySQL5.1版本前的默认存储引擎，<code>MyISAM的并发性比较差</code>，不支持事务和外键等操作，默认的锁的粒度为<strong>表级锁</strong>。</li>
</ul>
</li>
</ul>
<h1 id="InnoDB-和-MyISAM-的区别"><a href="#InnoDB-和-MyISAM-的区别" class="headerlink" title="InnoDB 和 MyISAM 的区别"></a>InnoDB 和 MyISAM 的区别</h1><p><strong>区别：</strong> </p>
<ol>
<li><strong>InnoDB</strong> 支持事务，<strong>MyISAM</strong> 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li><strong>InnoDB</strong> 支持外键，而 <strong>MyISAM</strong> 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </li>
<li><strong>InnoDB</strong> 是聚簇索引，<strong>MyISAM</strong> 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </li>
<li><strong>InnoDB</strong> 不保存表的具体行数，执行 select count(<em>) from table 时需要全表扫描。而*<em>MyISAM</em></em> 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li><strong>InnoDB</strong> 最小的锁粒度是<strong>行锁</strong>，<strong>MyISAM</strong> 最小的锁粒度是<strong>表锁</strong>。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
<p><strong>如何选择</strong>：</p>
<ol>
<li>是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读,写也挺频繁，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB； </li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</li>
</ol>
<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><p><code>MySQL索引</code>使⽤的数据结构主要有<code>B+树索引</code>和<code>哈希索引</code>。对于哈希索引来说，底层的数据结构就是哈希表，因此在<strong>绝大多数需求为单条记录查询</strong>的时候，可以选择<code>哈希索引，查询性能最快</code>；其余⼤部分场景，建议选择B+树索引。MySQL的BTree索引使⽤的是B树中的B+Tree，但对于主要的两种存储引擎的实现⽅式是不同的。</p>
<p><strong>MyISAM</strong>: B+树叶节点的data域存放的是数据记录的地址。在索引检索的时候，⾸先按照B+树搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引</strong>”。</p>
<p><strong>InnoDB</strong>：其数据⽂件本身就是索引⽂件。相⽐MyISAM，索引⽂件和数据⽂件是分离的，其表数据⽂件本身就是按B+Tree组织的⼀个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据⽂件本身就是主索引。这被称为“<strong>聚簇索引</strong>（或聚集索引）”。⽽其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值⽽不是地址，这也是和MyISAM不同的地⽅。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再⾛⼀遍主索引。 因此，在设计表的时候，不建议使⽤过⻓的字段作为主键，也不建议使⽤⾮单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p><strong>B+tree索引</strong>是目前大多数Mysql默认索引方式，<code>索引又分为聚簇索引和非聚簇索引</code>。聚簇索引是一个记录着数据的索引节点，非聚簇索引是存着主键id，再由id去寻找真实数据。</p>
<p><strong>哈希索引</strong>：哈希索引是查找速度极快的一种索引，其时间复杂度能到O(1),但是由于是hash策略实现。所以不支持排序和分组，只支持精确查找，不支持范围查找和范围查找。</p>
<p><strong>全文索引</strong>:innodb不支持全文索引，MyISAM支持全文索引，记录着关键字到文献的映射。</p>
<p><strong>空间数据索引</strong>：支持空间维度上的索引机制,GIS相关。</p>
<h1 id="索引的种类有哪些？"><a href="#索引的种类有哪些？" class="headerlink" title="索引的种类有哪些？"></a>索引的种类有哪些？</h1><ol>
<li><strong>主键索引</strong>：数据列不允许重复，不能为NULL，一个表只能有一个主键索引 。</li>
<li><strong>组合索引</strong>：由多个列值组成的索引。 </li>
<li><strong>唯一索引</strong>：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。 </li>
<li><strong>全文索引</strong>：对文本的内容进行搜索。 </li>
<li><strong>普通索引</strong>：基本的索引类型，可以为NULL。</li>
</ol>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><ol>
<li><p>索引的优化实质上就是尽可能的利用到索引，索引在查询过程中既不能是函数一部分也不能是表达式一部分，不然会导致索引失效的问题。</p>
</li>
<li><p>尽可能的使用多列索引，多列索引会让限制条件更加严格，让索引发挥更大的作用。</p>
</li>
<li><p>索引列的顺序有时候也会影响查询效率。</p>
</li>
<li><p>对于Blob，text，varchar类型的数据使用前缀索引再好不过，可以只索引前部分的数据，可以节省时间。</p>
</li>
<li><p>覆盖索引</p>
</li>
</ol>
<h1 id="MySQL怎么判断要不要加索引？"><a href="#MySQL怎么判断要不要加索引？" class="headerlink" title="MySQL怎么判断要不要加索引？"></a>MySQL怎么判断要不要加索引？</h1><ol>
<li><p>当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。</p>
</li>
<li><p>在频繁进行排序或分组（即进行 group by 或 order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。</p>
</li>
</ol>
<h1 id="所有的字段都适合建索引吗？"><a href="#所有的字段都适合建索引吗？" class="headerlink" title="所有的字段都适合建索引吗？"></a>所有的字段都适合建索引吗？</h1><p>不是</p>
<p>下列几种情况，是不适合创建索引的：</p>
<ol>
<li><p>频繁更新的字段不适合建立索引；</p>
</li>
<li><p>where条件中用不到的字段不适合建立索引；</p>
</li>
<li><p>数据比较少的表不需要建索引；</p>
</li>
<li><p>数据重复且分布比较均匀的字段不适合建索引，例如性别、真假值；</p>
</li>
<li><p>参与列计算的列不适合建索引。</p>
</li>
</ol>
<h1 id="如何评估一个索引创建的是否合理？"><a href="#如何评估一个索引创建的是否合理？" class="headerlink" title="如何评估一个索引创建的是否合理？"></a>如何评估一个索引创建的是否合理？</h1><p>建议按照如下的原则来设计索引：</p>
<ol>
<li><p>避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。应该经常用于查询的字段创建索引，但要避免添加不必要的字段。</p>
</li>
<li><p>数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p>
</li>
<li><p>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引，如果建立索引不但不会提高查询效率，反而会严重降低数据更新速度。</p>
</li>
<li><p>当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。</p>
</li>
<li><p>在频繁进行排序或分组（即进行 group by或 order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。</p>
</li>
</ol>
<h1 id="索引失效的几种场景"><a href="#索引失效的几种场景" class="headerlink" title="索引失效的几种场景"></a>索引失效的几种场景</h1><ol>
<li><p>列类型是字符串，查询条件未加引号。</p>
<p>card_code列是身份证号，数据类型是varchar,在没有将证件号码用引号括起时不会使用索引，此时索引失效。</p>
</li>
<li><p>使用like时通配符在前</p>
<p>我们可以看到通配符在后面时效率不受影响，说明此时索引未失效，通配符在前时索引失效。</p>
</li>
<li><p>在查询条件中使用OR</p>
<p>查询条件中使用or会使索引失效，要想是索引生效，需要将or中的每个列都加上索引。</p>
</li>
<li><p>对索引列进行函数运算</p>
</li>
<li><p>未使用该列作为查询条件</p>
</li>
<li><p>联合索引ABC问题</p>
</li>
</ol>
<h1 id="如何避免索引失效？"><a href="#如何避免索引失效？" class="headerlink" title="如何避免索引失效？"></a>如何避免索引失效？</h1><p>可以采用以下几种方式，来避免索引失效：</p>
<ol>
<li><p>使用组合索引时，需要遵循“最左前缀”原则；</p>
</li>
<li><p>不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描；</p>
</li>
<li><p>尽量使用覆盖索引（之访问索引列的查询，减少<code>select *</code>覆盖索引能减少回表次数；</p>
</li>
<li><p>MySQL在使用不等于（!&#x3D;或者&lt;&gt;）的时候无法使用索引会导致全表扫描；</p>
</li>
<li><p>LIKE以通配符开头（%abc）MySQL索引会失效变成全表扫描的操作；</p>
</li>
<li><p>字符串不加单引号会导致索引失效（可能发生了索引列的隐式转换）；</p>
</li>
<li><p>少用or，用它来连接时会索引失效。</p>
</li>
</ol>
<h1 id="如何判断数据库的索引有没有生效？"><a href="#如何判断数据库的索引有没有生效？" class="headerlink" title="如何判断数据库的索引有没有生效？"></a>如何判断数据库的索引有没有生效？</h1><p>可以使用EXPLAIN语句查看索引是否正在使用。</p>
<p>举例，假设已经创建了book表，并已经在其year_publication字段上建立了普通索引。执行如下语句</p>
<p><code>EXPLAIN SELECT * FROM book WHERE year_publication=1990;</code></p>
<p>EXPLAIN语句将为我们输出详细的SQL执行信息，其中：</p>
<ul>
<li><p>possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。</p>
</li>
<li><p>key行是MySQL实际选用的索引。</p>
</li>
</ul>
<p>如果possible_keys行和key行都包含possible_publication字段，则说明在查询时使用了该索引。</p>
<h1 id="聚簇索引和非聚簇索引的区别？"><a href="#聚簇索引和非聚簇索引的区别？" class="headerlink" title="聚簇索引和非聚簇索引的区别？"></a>聚簇索引和非聚簇索引的区别？</h1><p>在InnoDB存储引擎中，可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引)。无论是何种索引，每个页的大小都为16KB，且不能更改。</p>
<p><strong>聚簇索引</strong>是根据<strong>主键</strong>创建的一棵B+树，聚簇索引的叶子结点存放了表中的所有记录。<strong>辅助索引</strong>是根据<strong>索引键</strong>创建的一棵B+树，与聚簇索引不同的是，其叶子结点<code>仅存放索引键值，以及该索引键值指向的主键</code>。也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚簇索引。</p>
<h1 id="主键索引查询只会查一次，而非主键索引需要回表查询多次。是所有情况都是这样的吗？非主键索引一定会查询多次吗？"><a href="#主键索引查询只会查一次，而非主键索引需要回表查询多次。是所有情况都是这样的吗？非主键索引一定会查询多次吗？" class="headerlink" title="主键索引查询只会查一次，而非主键索引需要回表查询多次。是所有情况都是这样的吗？非主键索引一定会查询多次吗？"></a>主键索引查询只会查一次，而非主键索引需要回表查询多次。是所有情况都是这样的吗？非主键索引一定会查询多次吗？</h1><p>通过<strong>覆盖索引</strong>也可以只查询一次。</p>
<p><strong>覆盖索引（covering index）</strong>指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 <strong>当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I&#x2F;O提高效率。</strong> 如，表<code>covering_index_sample</code>中有一个普通索引 <code>idx_key1_key2(key1,key2)</code>。当我们通过SQL语句：<code>select key2 from covering_index_sample where key1 = ‘keytest’;</code>的时候，就可以通过覆盖索引查询，无需回表。</p>
<h1 id="简述索引覆盖与回表查询"><a href="#简述索引覆盖与回表查询" class="headerlink" title="简述索引覆盖与回表查询"></a>简述索引覆盖与回表查询</h1><h2 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h2><p>先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。</p>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</p>
<blockquote>
<p>例如：select id,age from user where age &#x3D; 10;</p>
</blockquote>
<h1 id="什么是联合索引？"><a href="#什么是联合索引？" class="headerlink" title="什么是联合索引？"></a>什么是联合索引？</h1><p><strong>联合索引</strong>是指对表上的多个列进行索引，联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2，参考下图。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，<strong>所以使用联合索引时遵循最左前缀匹配原则。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T1Gq2Q"><img src="https://s4.ax1x.com/2021/12/22/T1Gq2Q.md.png" alt="T1Gq2Q.md.png"></a></p>
<h1 id="联合索引的建立规则？"><a href="#联合索引的建立规则？" class="headerlink" title="联合索引的建立规则？"></a>联合索引的建立规则？</h1><ul>
<li><p>将<strong>查询需求频繁</strong>或者<strong>字段选择性高</strong>的列放在前面</p>
</li>
<li><p>索引的<strong>复用</strong>，可以少维护一些索引(a)-&gt;(a,b)</p>
</li>
<li><ul>
<li>如果既有联合查询，又有基于a、b各自的查询呢？：考虑的原则就是空间，将小的单独建索引。</li>
</ul>
</li>
</ul>
<h1 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h1><p><strong>最左优先</strong>，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。<br>例如：b &#x3D; 2 如果建立(a,b)顺序的索引，是匹配不到(a,b)索引的；但是如果查询条件是a &#x3D; 1 and b &#x3D; 2或者a&#x3D;1(又或者是b &#x3D; 2 and a&#x3D; 1)就可以，因为优化器会自动调整a,b的顺序。再比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。</p>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><p>一般地，在进行数据库设计时，应遵循三大原则，也就是我们通常说的<strong>三大范式</strong>，</p>
<p>即<strong>第一范式</strong>要求确保表中每列的原子性，也就是不可拆分；</p>
<p><strong>第二范式</strong>要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循<strong>完全函数依赖关系</strong>，也就是<strong>完全依赖</strong>；</p>
<p><strong>第三范式</strong>确保主键列之间没有传递函数依赖关系，也就是消除<code>传递依赖</code>（确保每列都和主键列直接相关而不是间接相关）。</p>
<h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><blockquote>
<p><strong>例子引入</strong></p>
</blockquote>
<p>第一种表设计</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T1DmX8"><img src="https://s4.ax1x.com/2021/12/22/T1DmX8.md.png" alt="T1DmX8.md.png"></a></p>
<p>第二种表设计</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T1D3hn"><img src="https://s4.ax1x.com/2021/12/22/T1D3hn.md.png" alt="T1D3hn.md.png"></a></p>
<p>分析</p>
<p>第一种表设计不满足第一范式，为什么不满足第一范式？因为region列不具有原子性，能拆分成省份、市和具体地址。</p>
<h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><blockquote>
<p><strong>例子引入</strong></p>
</blockquote>
<p><strong>需求描述</strong>：设计一个订单信息表，订单有多种商品，将订单编号和商品编号作为联合主键。</p>
<p>第一种表设计</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T1DhAH"><img src="https://s4.ax1x.com/2021/12/22/T1DhAH.md.png" alt="T1DhAH.md.png"></a></p>
<p>第二种表设计</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T1D7gP"><img src="https://s4.ax1x.com/2021/12/22/T1D7gP.png" alt="T1D7gP.png"></a></p>
<p>分析</p>
<p>第一种表设计不满足第二范式，订单编号和商品编号作为联合主键，由于商品名称，单位，价格这几列只与商品编号有关，与订单编号无关，因此与主键（联合主键）无关，违反范式第二原则；</p>
<p>第二种表设计满足第二范式，把第一种设计表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中。</p>
<h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><blockquote>
<p><strong>例子引入</strong></p>
</blockquote>
<p><strong>需求描述</strong>:</p>
<ol>
<li>需要在数据库中存储如下信息：</li>
<li>学生编号；学生卡号；用户ID号；操作员级别；操作日期；操作时间；</li>
</ol>
<p>第一种表设计</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T1ydHS"><img src="https://s4.ax1x.com/2021/12/22/T1ydHS.md.png" alt="T1ydHS.md.png"></a></p>
<p>第二种表设计</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T1y0Ag"><img src="https://s4.ax1x.com/2021/12/22/T1y0Ag.md.png" alt="T1y0Ag.md.png"></a></p>
<p>分析</p>
<p>第一种表设计不满足第三范式，在表中，一个UserID能确定一个UserLevel。这样，UserID依赖于StudentNo和CardNo，而UserLevel又依赖于UserID，这就导致了传递依赖，3NF就是消除这种依赖。</p>
<p>第二种表设计满足第三范式，将第一种表格拆分成成两个表格。</p>
<h1 id="mysql怎么实现主从复制"><a href="#mysql怎么实现主从复制" class="headerlink" title="mysql怎么实现主从复制"></a>mysql怎么实现主从复制</h1><h2 id="MySQL-基于-Binlog-主从复制的模式介绍"><a href="#MySQL-基于-Binlog-主从复制的模式介绍" class="headerlink" title="MySQL 基于 Binlog 主从复制的模式介绍"></a>MySQL 基于 Binlog 主从复制的模式介绍</h2><p>MySQL 主从复制默认是 <strong>异步的模式</strong>。MySQL增删改操作会全部记录在 Binlog 中，当 <code>slave</code> 节点连接 <code>master</code> 时，会主动从 master 处获取最新的 Binlog 文件。并把 Binlog 存储到本地的 <code>relay log</code> 中，然后去执行 <code>relay log</code> 的更新内容。</p>
<h3 id="异步模式-async-mode"><a href="#异步模式-async-mode" class="headerlink" title="异步模式 (async-mode)"></a>异步模式 (async-mode)</h3><p>异步模式如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjx1mu02wbj31160kk0vj.jpg" alt="6"></p>
<p>这种模式下，主节点不会主动推送数据到从节点，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主节点如果崩溃掉了，此时主节点上已经提交的事务可能并没有传到从节点上，如果此时，强行将从提升为主，可能导致新主节点上的数据不完整。</p>
<h3 id="半同步模式-semi-sync"><a href="#半同步模式-semi-sync" class="headerlink" title="半同步模式(semi-sync)"></a>半同步模式(semi-sync)</h3><p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relay log 中才返回成功信息给客户端（只能保证主库的 Binlog 至少传输到了一个从节点上），否则需要等待直到超时时间然后切换成异步模式再提交。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjx1muypwdj31420jg41q.jpg" alt="7"></p>
<p>相对于异步复制，半同步复制提高了数据的安全性，一定程度的保证了数据能成功备份到从库，同时它也造成了一定程度的延迟，但是比全同步模式延迟要低，这个延迟最少是一个 TCP&#x2F;IP 往返的时间。所以，半同步复制最好在低延时的网络中使用。</p>
<p>半同步模式不是 MySQL 内置的，从 MySQL 5.5 开始集成，需要 master 和 slave 安装插件开启半同步模式。</p>
<h3 id="全同步模式"><a href="#全同步模式" class="headerlink" title="全同步模式"></a>全同步模式</h3><p>指当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响。</p>
<h1 id="如何防止sql注入"><a href="#如何防止sql注入" class="headerlink" title="如何防止sql注入"></a>如何防止sql注入</h1><ol>
<li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li>
<li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li>
<li>对进入数据库的特殊字符进行转义处理，或编码转换</li>
<li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li>
<li>发布前，利用工具进行 SQL 注入检测</li>
<li>报错信息不要包含 SQL 信息输出到 Web 页面</li>
</ol>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>下边以电商系统中的例子来说明，下图是电商系统卖家模块的表结构：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7H8TVx"><img src="https://s4.ax1x.com/2022/01/25/7H8TVx.png" alt="7H8TVx.png"></a></p>
<p>通过以下SQL能够获取到商品相关的店铺信息、地理区域信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.<span class="operator">*</span>,r.[地理区域名称],s.[店铺名称],s.[信誉]</span><br><span class="line"><span class="keyword">FROM</span> [商品信息] p </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [地理区域] r <span class="keyword">ON</span> p.[产地] <span class="operator">=</span> r.[地理区域编码]</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [店铺信息] s <span class="keyword">ON</span> s.id <span class="operator">=</span> p.[所属店铺]</span><br><span class="line"><span class="keyword">WHERE</span> p.id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>


<p>随着公司业务快速发展，数据库中的数据量猛增，访问性能也变慢了，优化迫在眉睫。分析一下问题出现在哪儿呢？ 关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。</p>
<p>方案1：</p>
<p>通过提升服务器硬件能力来提高数据处理能力，比如增加存储容量 、CPU等，这种方案成本很高，并且如果瓶颈在MySQL本身那么提高硬件也是有很的。</p>
<p><strong>方案2：</strong></p>
<p>把数据分散在不同的数据库中，使得单一数据库的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的，如下图：将电商数据库拆分为若干独立的数据库，并且对于大表也拆分为若干小表，通过这种数据库拆分的方法来解决数据库的性能问题。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7H8zqI"><img src="https://s4.ax1x.com/2022/01/25/7H8zqI.png" alt="7H8zqI.png"></a></p>
<p><strong>分库分表</strong>就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</p>
<p><strong>分库分表包括分库和分表两个部分，在生产中通常包括：垂直分库、水平分库、垂直分表、水平分表四种方式。</strong></p>
<h2 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h2><p>通常在商品列表中是不显示商品详情信息的，如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HGNe1"><img src="https://s4.ax1x.com/2022/01/25/7HGNe1.md.png" alt="7HGNe1.md.png"></a></p>
<p>用户在浏览商品列表时，只有对某商品感兴趣时才会查看该商品的详细描述。因此，商品信息中商品描述字段访问频次较低，且该字段存储占用空间较大，访问单个数据IO时间较长；商品信息中商品名称、商品图片、商品价格等其他字段数据访问频次较高。</p>
<p>由于这两种数据的特性不一样，因此他考虑将商品信息表拆分如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HG2wt"><img src="https://s4.ax1x.com/2022/01/25/7HG2wt.png" alt="7HG2wt.png"></a></p>
<p>将访问频次低的商品描述信息单独存放在一张表中，访问频次较高的商品基本信息单独放在一张表中。</p>
<p>商品列表可采用以下sql：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.<span class="operator">*</span>,r.[地理区域名称],s.[店铺名称],s.[信誉]</span><br><span class="line"><span class="keyword">FROM</span> [商品信息] p </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [地理区域] r <span class="keyword">ON</span> p.[产地] <span class="operator">=</span> r.[地理区域编码]</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [店铺信息] s <span class="keyword">ON</span> s.id <span class="operator">=</span> p.[所属店铺]</span><br><span class="line">WHERE...ORDER BY...LIMIT...</span><br></pre></td></tr></table></figure>

<p>需要获取商品描述时，再通过以下sql获取：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> [商品描述] </span><br><span class="line"><span class="keyword">WHERE</span> [商品ID] <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>


<p><strong>垂直分表定义</strong>：将一个表按照字段分成多表，每个表存储其中一部分字段。</p>
<blockquote>
<p>它带来的提升是：</p>
</blockquote>
<ol>
<li><p>为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响</p>
</li>
<li><p>充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累。</p>
</li>
</ol>
<blockquote>
<p>为什么大字段IO效率低：第一是由于数据量本身大，需要更长的读取时间；第二是跨页，页是数据库存储单位，很多查找及定位操作都是以页为单位，单页内的数据行越多数据库整体性能越好，而大字段占用空间大，单页内存储行数少，因此IO效率较低。第三，数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。</p>
</blockquote>
<p>一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的商品描述。所以，当表数据量很大时，可以将表按字段切开，将热门字段、冷门字段分开放置在不同库中，这些库可以放在不同的存储设备上，避免IO争抢。垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。</p>
<p><strong>通常我们按以下原则进行垂直拆分:</strong></p>
<ol>
<li>把不常用的字段单独放在一张表;</li>
<li>把text，blob等大字段拆分出来放在附表中;</li>
<li>经常组合查询的列放在一张表中;</li>
</ol>
<h2 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h2><p>通过垂直分表性能得到了一定程度的提升，但是还没有达到要求，并且磁盘空间也快不够了，因为数据还是始终限制在一台服务器，库内垂直分表只解决了单一表数据量过大的问题，但没有将表分布到不同的服务器上，因此每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。</p>
<p>经过思考，他把原有的SELLER_DB(卖家库)，分为了PRODUCT_DB(商品库)和STORE_DB(店铺库)，并把这两个库分散到不同服务器，如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HJi01"><img src="https://s4.ax1x.com/2022/01/25/7HJi01.md.png" alt="7HJi01.md.png"></a></p>
<p>由于商品信息与商品描述业务耦合度较高，因此一起被存放在PRODUCT_DB(商品库)；而店铺信息相对独立，因此单独被存放在STORE_DB(店铺库)。</p>
<p><strong>垂直分库</strong>是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。</p>
<blockquote>
<p>它带来的提升是：</p>
</blockquote>
<ol>
<li>解决业务层面的耦合，业务清晰</li>
<li>能对不同业务的数据进行分级管理、维护、监控、扩展等</li>
<li>高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈</li>
</ol>
<p>垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题。</p>
<h2 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h2><p>经过垂直分库后，数据库性能问题得到一定程度的解决，但是随着业务量的增长，PRODUCT_DB(商品库)单库存储数据已经超出预估。粗略估计，目前有8w店铺，每个店铺平均150个不同规格的商品，再算上增长，那商品数量得往1500w+上预估，并且PRODUCT_DB(商品库)属于访问非常频繁的资源，单台服务器已经无法支撑。此时该如何优化？</p>
<p>再次分库？但是从业务角度分析，目前情况已经无法再次垂直分库。</p>
<p>尝试水平分库，将店铺ID为单数的和店铺ID为双数的商品信息分别放在两个库中。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HJY9S"><img src="https://s4.ax1x.com/2022/01/25/7HJY9S.md.png" alt="7HJY9S.md.png"></a></p>
<p>也就是说，要操作某条数据，先分析这条数据所属的店铺ID。如果店铺ID为双数，将此操作映射至RRODUCT_DB1(商品库1)；如果店铺ID为单数，将操作映射至RRODUCT_DB2(商品库2)。此操作要访问数据库名称的表达式为RRODUCT_DB[店铺ID%2 + 1] 。</p>
<p><strong>水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。</strong></p>
<p>垂直分库是把不同表拆到不同数据库中，它是对数据行的拆分，不影响表结构</p>
<blockquote>
<p>它带来的提升是：</p>
</blockquote>
<ol>
<li>解决了单库大数据，高并发的性能瓶颈。</li>
<li>提高了系统的稳定性及可用性。<ul>
<li><strong>稳定性</strong>体现在IO冲突减少，锁定减少，<strong>可用性</strong>指某个库出问题，部分可用</li>
</ul>
</li>
</ol>
<p>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平分库了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度。</p>
<h2 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h2><p>按照水平分库的思路对他把PRODUCT_DB_X(商品库)内的表也可以进行水平拆分，其目的也是为解决单表数据量大的问题，如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7HJXDA"><img src="https://s4.ax1x.com/2022/01/25/7HJXDA.md.png" alt="7HJXDA.md.png"></a></p>
<p>与水平分库的思路类似，不过这次操作的目标是表，商品信息及商品描述被分成了两套表。如果商品ID为双数，将此操作映射至商品信息1表；如果商品ID为单数，将操作映射至商品信息2表。此操作要访问表名称的表达式为商品信息[商品ID%2 + 1] 。</p>
<p><strong>水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</strong></p>
<blockquote>
<p>它带来的提升是：</p>
</blockquote>
<ol>
<li>优化单一表数据量过大而产生的性能问题</li>
<li>避免IO争抢并减少锁表的几率</li>
</ol>
<p>库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，从而使得单个表的数据量变小，提高检索性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>垂直分表</strong>：可以把一个宽表的字段按访问频次、是否是大字段的原则拆分为多个表，这样既能使业务清晰，还能提升部分性能。拆分后，尽量从业务角度避免联查，否则性能方面将得不偿失。</p>
<p><strong>垂直分库</strong>：可以把多个表按业务耦合松紧归类，分别存放在不同的库，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能，同时能提高整体架构的业务清晰度，不同的业务库可根据自身情况定制优化方案。但是它需要解决跨库带来的所有复杂问题。</p>
<p><strong>水平分库</strong>：可以把一个表的数据(按数据行)分到多个不同的库，每个库只有这个表的部分数据，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能。它不仅需要解决跨库带来的所有复杂问题，还要解决数据路由的问题(数据路由问题后边介绍)。</p>
<p><strong>水平分表</strong>：可以把一个表的数据(按数据行)分到多个同一个数据库的多张表中，每个表只有这个表的部分数据，这样做能小幅提升性能，它仅仅作为水平分库的一个补充优化。</p>
<p>一般来说，在系统设计阶段就应该根据业务耦合松紧来确定垂直分库，垂直分表方案，在数据量及访问压力不是特别大的情况，首先考虑缓存、读写分离、索引技术等方案。若数据量极大，且持续增长，再考虑水平分库水平分表方案。</p>
<h1 id="关系型数据库与非关系型数据库区别"><a href="#关系型数据库与非关系型数据库区别" class="headerlink" title="关系型数据库与非关系型数据库区别"></a>关系型数据库与非关系型数据库区别</h1><h2 id="关系型数据库（Mysql和Oracle）"><a href="#关系型数据库（Mysql和Oracle）" class="headerlink" title="关系型数据库（Mysql和Oracle）"></a><strong>关系型数据库（Mysql和Oracle）</strong></h2><p>表和表、表和字段、数据和数据存在着关系</p>
<p><strong>优点</strong>:</p>
<ol>
<li>数据之间有关系，进行数据的增删改查的时候是非常方便的。</li>
<li>关系型数据库是有事务操作的，保证数据的完整性和一致性。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>因为数据和数据是有关系的，底层是运行了大量的算法，大量算法会降低系统的效率，会降低性能</li>
<li>面对海量数据的增删改查的时候会显的无能为力</li>
<li>海量数据对数据进行维护变得非常的无力</li>
</ol>
<p><strong>常见应用:</strong></p>
<ul>
<li>适合处理一般量级的数据（银行转账和钱）</li>
</ul>
<h2 id="非关系型数据库（redis和MangDB）"><a href="#非关系型数据库（redis和MangDB）" class="headerlink" title="非关系型数据库（redis和MangDB）"></a>非关系型数据库（redis和MangDB）</h2><p>为了处理海量数据，非关系数据库设计之初就是为了替代关系型数据库的关系</p>
<p><strong>优点</strong>：</p>
<ol>
<li>海量数据的增删改查是可以的</li>
<li>海量数据的维护和处理非常轻松</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>数据和数据没有关系，他们之间就是单独存在的</li>
<li>非关系数据库没有关系，没有强大的事务关系，没有保证数据的完整性和安全性（微博数据）</li>
</ol>
<h1 id="drop、truncate和delete的区别"><a href="#drop、truncate和delete的区别" class="headerlink" title="drop、truncate和delete的区别"></a>drop、truncate和delete的区别</h1><ol>
<li><p><strong>DELETE语句</strong>执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p>
<p><strong>TRUNCATE TABLE</strong> 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
</li>
<li><p>表和索引所占空间。</p>
</li>
</ol>
<ul>
<li>当表被<strong>TRUNCATE</strong> 后，这个表和索引所占用的空间会恢复到初始大小，</li>
<li><strong>DELETE</strong>操作不会减少表或索引所占用的空间。</li>
<li><strong>drop</strong>语句将表所占用的空间全释放掉。</li>
</ul>
<ol start="3">
<li><p>一般而言，drop &gt; truncate &gt; delete</p>
</li>
<li><p>应用范围</p>
</li>
</ol>
<ul>
<li><strong>TRUNCATE</strong> 只能对TABLE；</li>
<li><strong>DELETE</strong>可以是table和view</li>
</ul>
<ol start="5">
<li><p><strong>TRUNCATE</strong> 和<strong>DELETE</strong>只删除数据， <strong>DROP</strong>则删除整个表（结构和数据）。</p>
</li>
<li><p><strong>truncate</strong>与<strong>不带where的delete</strong> ：只删除数据，而不删除表的结构（定义）</p>
<p><strong>drop语句</strong>将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程&#x2F;函数将被保留，但其状态会变为：invalid。</p>
</li>
<li><p><strong>delete</strong>语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p>
<p><strong>truncate、drop</strong>是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚</p>
</li>
<li><p>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p>
</li>
<li><p><strong>Truncate table 表名</strong> 速度快,而且效率高,因为:<br>   truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 </p>
</li>
<li><p><strong>TRUNCATE TABLE</strong> 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 </p>
</li>
<li><p>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p>
</li>
</ol>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><ol>
<li><p>delete是DML，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，但要注意表空间要足够大，需要手动提交（commit）操作才能生效，可以通过rollback撤消操作。</p>
</li>
<li><p>delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。</p>
</li>
<li><p>delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不变。</p>
</li>
</ol>
<h2 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h2><ol>
<li><p>truncate是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
</li>
<li><p>truncate会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到minextents个extent，除非使用reuse storage，。不会记录日志，所以执行速度很快，但不能通过rollback撤消操作（如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复）。</p>
</li>
<li><p>对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。</p>
</li>
<li><p>truncatetable不能用于参与了索引视图的表。</p>
</li>
</ol>
<h2 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h2><ol>
<li><p>drop是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
</li>
<li><p>drop语句删除表结构及所有数据，并将表所占用的空间全部释放。</p>
</li>
<li><p>drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程&#x2F;函数将保留,但是变为invalid状态。</p>
</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>在速度上，一般来说，drop&gt; truncate &gt; delete。</p>
</li>
<li><p>在使用drop和truncate时一定要注意，虽然可以恢复，但为了减少麻烦，还是要慎重。</p>
</li>
<li><p>如果想删除部分数据用delete，注意带上where子句，回滚段要足够大；</p>
</li>
</ol>
<p>  如果想删除表，当然用drop； </p>
<p>  如果想保留表而将所有数据删除，如果和事务无关，用truncate即可；</p>
<p>  如果和事务有关，或者想触发trigger，还是用delete；</p>
<p>  如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入&#x2F;插入数据。</p>
<h1 id="left-join、right-join、inner-join的区别"><a href="#left-join、right-join、inner-join的区别" class="headerlink" title="left join、right join、inner join的区别"></a>left join、right join、inner join的区别</h1><p>三个join的含义：</p>
<ul>
<li><strong>left join（左联接）</strong>：返回左表中的所有记录以及和右表中的<strong>联接字段相等</strong>的记录。</li>
<li><strong>right join（右联接）</strong>：返回右表中的所有记录以及和左表中的联接字段相等的记录。</li>
<li><strong>inner join（等值联接）</strong>：只返回两个表中联接字段相等的记录。</li>
</ul>
<p>下面将以atable、btable为例进行讲解。<br> atable：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5684201-36cbbd349ba47f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/283/format/webp" alt="img"></p>
<p>btable：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5684201-27874232c0422cd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/254/format/webp" alt="img"></p>
<h2 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> atable <span class="keyword">as</span> a</span><br><span class="line">left <span class="keyword">join</span> btable <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">on</span> a.name = b.name;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5684201-d5da170d4922524c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/485/format/webp" alt="img"></p>
<p> 可以看到，tableA join tableB的结果中，既有tableA中的所有记录，同时还包括了与右表中联接字段相等的记录，所以返回的记录总数一定是<strong>大于或等于</strong>tableA的记录总数。</p>
<p><strong>right join</strong>的就不赘述了。</p>
<h2 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> atable <span class="keyword">as</span> a</span><br><span class="line">inner <span class="keyword">join</span> btable <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">on</span> a.name = b.name;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5684201-deb2a90d72846e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/481/format/webp" alt="img"></p>
<p>可以看到，tableA inner join tableB的结果中，只包含了tableA与tableB联接字段相等的记录。可以看作是tableA和tableB的交集。</p>
<h1 id="MySQL事务及特性"><a href="#MySQL事务及特性" class="headerlink" title="MySQL事务及特性"></a>MySQL事务及特性</h1><p><strong>事务就是一组原子性的SQL查询</strong>，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据应用该组查询的全部语句，那么就执行该组查询。如果其中任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<blockquote>
<p><strong>事务的四大特性（ACID）：</strong></p>
</blockquote>
<ol>
<li><p><strong>原子性</strong>（atomicity）：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
</li>
<li><p><strong>一致性</strong>（consistency）：数据库总数从一个一致性的状态转换到另一个一致性的状态。</p>
</li>
<li><p><strong>隔离性</strong>（isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p>
</li>
<li><p><strong>持久性</strong>（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>
</li>
</ol>
<h1 id="Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理"><a href="#Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理" class="headerlink" title="Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理"></a>Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理</h1><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><p>本文所说的 MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。</p>
<p>数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败，什么都不做，其实不是没做，是可能做了一部分但是只要有一步失败，就要回滚所有操作，有点一不做二不休的意思。</p>
<p>假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧，这问题就大了。</p>
<p>事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）四个特性，简称 ACID，缺一不可。今天要说的就是<strong>隔离性</strong>。</p>
<h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>以下几个概念是事务隔离级别要实际解决的问题，所以需要搞清楚都是什么意思。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并不一定最终存在的数据，这就是脏读。</p>
<h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据<strong>更新（UPDATE）</strong>操作。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读是针对数据<strong>插入（INSERT）</strong>操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p>
<ol>
<li>读未提交（READ UNCOMMITTED）</li>
<li>读提交 （READ COMMITTED）</li>
<li>可重复读 （REPEATABLE READ）</li>
<li>串行化 （SERIALIZABLE）</li>
</ol>
<p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<strong>可重复读</strong>是 MySQL 的默认级别。</p>
<p>事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读提交</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>串行化</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p>只有串行化的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷。</p>
<h2 id="一探究竟"><a href="#一探究竟" class="headerlink" title="一探究竟"></a>一探究竟</h2><p>下面，我们来一一分析这 4 种隔离级别到底是怎么个意思。</p>
<h3 id="如何设置隔离级别"><a href="#如何设置隔离级别" class="headerlink" title="如何设置隔离级别"></a>如何设置隔离级别</h3><p>我们可以通过以下语句查看当前数据库的隔离级别，通过下面语句可以看出我使用的 MySQL 的隔离级别是 REPEATABLE-READ，也就是可重复读，这也是 MySQL 的默认级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看事务隔离级别 <span class="number">5.7</span><span class="number">.20</span> 之后</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation</span><br><span class="line"></span><br><span class="line"># <span class="number">5.7</span><span class="number">.20</span> 之后</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> tx_isolation  <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br></pre></td></tr></table></figure>

<p>稍后，我们要修改数据库的隔离级别，所以先了解一下具体的修改方式。</p>
<p>修改隔离级别的语句是：set [作用域] transaction isolation level [事务隔离级别]，<br>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}。</p>
<p>其中作用于可以是 SESSION 或者 GLOBAL，GLOBAL 是全局的，而 SESSION 只针对当前回话窗口。隔离级别是 {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} 这四种，不区分大小写。</p>
<p>比如下面这个语句的意思是设置全局隔离级别为读提交级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed; </span><br></pre></td></tr></table></figure>

<h3 id="MySQL-中执行事务"><a href="#MySQL-中执行事务" class="headerlink" title="MySQL 中执行事务"></a>MySQL 中执行事务</h3><p>事务的执行过程如下，以 begin 或者 start transaction 开始，然后执行一系列操作，最后要执行 commit 操作，事务才算结束。当然，如果进行回滚操作(rollback)，事务也会结束。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111138450-546456756.png" alt="img"></p>
<p>需要注意的是，begin 命令并不代表事务的开始，事务开始于 begin 命令之后的第一条语句执行的时候。例如下面示例中，select * from xxx 才是事务的开始，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx; </span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 或者 rollback;</span></span><br></pre></td></tr></table></figure>

<p>另外，通过以下语句可以查询当前有多少事务正在运行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx;</span><br></pre></td></tr></table></figure>

<p><strong>好了，重点来了，开始分析这几个隔离级别了。</strong></p>
<p>接下来我会用一张表来做一下验证，表结构简单如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<p>初始只有一条记录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">SELECT * FROM user;</span></span><br><span class="line">+----+-----------------+------+</span><br><span class="line">| id | name            | age  |</span><br><span class="line">+----+-----------------+------+</span><br><span class="line">|  1 | 古时的风筝        |    1 |</span><br><span class="line">+----+-----------------+------+</span><br></pre></td></tr></table></figure>

<h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。</p>
<p>任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。</p>
<p>下面来做个简单实验验证一下，首先设置全局隔离级别为读未提交。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>

<p>设置完成后，只对之后新起的 session 才起作用，对已经启动 session 无效。如果用 shell 客户端那就要重新连接 MySQL，如果用 Navicat 那就要创建新的查询窗口。</p>
<p>启动两个事务，分别为事务A和事务B，在事务A中使用 update 语句，修改 age 的值为10，初始是1 ，在执行完 update 语句之后，在事务B中查询 user 表，会看到 age 的值已经是 10 了，这时候事务A还没有提交，而此时事务B有可能拿着已经修改过的 age&#x3D;10 去进行其他操作了。在事务B进行操作的过程中，很有可能事务A由于某些原因，进行了事务回滚操作，那其实事务B得到的就是脏数据了，拿着脏数据去进行其他的计算，那结果肯定也是有问题的。</p>
<p>顺着时间轴往表示两事务中操作的执行顺序，重点看图中 age 字段的值。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111159462-561854332.png" alt="img"></p>
<p>读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了，想都不要想。</p>
<h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>既然读未提交没办法解决脏数据问题，那么就有了读提交。读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。</p>
<p>读提交事务隔离级别是大多数流行数据库的默认事务隔离界别，比如 Oracle，但是不是 MySQL 的默认隔离界别。</p>
<p>我们继续来做一下验证，首先把事务隔离级别改为读提交级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br></pre></td></tr></table></figure>

<p>之后需要重新打开新的 session 窗口，也就是新的 shell 窗口才可以。</p>
<p>同样开启事务A和事务B两个事务，在事务A中使用 update 语句将 id&#x3D;1 的记录行 age 字段改为 10。此时，在事务B中使用 select 语句进行查询，我们发现在事务A提交之前，事务B中查询到的记录 age 一直是1，直到事务A提交，此时在事务B中 select 查询，发现 age 的值已经是 10 了。</p>
<p>这就出现了一个问题，在同一事务中(本例中的事务B)，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果，这就是不可重复读，也就是读提交隔离级别。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111220152-587480759.png" alt="img"></p>
<p>每个 select 语句都有自己的一份快照，而不是一个事务一份，所以在不同的时刻，查询出来的数据可能是不一致的。</p>
<p>读提交解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。</p>
<h3 id="可重复读-1"><a href="#可重复读-1" class="headerlink" title="可重复读"></a>可重复读</h3><p>可重复是对比不可重复而言的，上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。</p>
<p>同样的，需改全局隔离级别为可重复读级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure>

<p>在这个隔离级别下，启动两个事务，两个事务同时开启。</p>
<p>首先看一下可重复读的效果，事务A启动后修改了数据，并且在事务B之前提交，事务B在事务开始和事务A提交之后两个时间节点都读取的数据相同，已经可以看出可重复读的效果。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111239548-1039643011.png" alt="img"></p>
<p>可重复读做到了，这只是针对已有行的更改操作有效，但是对于新插入的行记录，就没这么幸运了，幻读就这么产生了。我们看一下这个过程：</p>
<p>事务A开始后，执行 update 操作，将 age &#x3D; 1 的记录的 name 改为“风筝2号”；</p>
<p>事务B开始后，在事务执行完 update 后，执行 insert 操作，插入记录 age &#x3D;1，name &#x3D; 古时的风筝，这和事务A修改的那条记录值相同，然后提交。</p>
<p>事务B提交后，事务A中执行 select，查询 age&#x3D;1 的数据，这时，会发现多了一行，并且发现还有一条 name &#x3D; 古时的风筝，age &#x3D; 1 的记录，这其实就是事务B刚刚插入的，这就是幻读。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111302657-1219381120.png" alt="img"></p>
<p><strong>要说明的是，当你在 MySQL 中测试幻读的时候，并不会出现上图的结果，幻读并没有发生，MySQL 的可重复读隔离级别其实解决了幻读问题，这会在后面的内容说明</strong></p>
<h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。</p>
<h2 id="MySQL-中是如何实现事务隔离的"><a href="#MySQL-中是如何实现事务隔离的" class="headerlink" title="MySQL 中是如何实现事务隔离的"></a>MySQL 中是如何实现事务隔离的</h2><p>首先说读未提交，它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。</p>
<p>再来说串行化。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。</p>
<p>最后说读提交和可重复读。这两种隔离级别是比较复杂的，既要允许一定的并发，又想要兼顾的解决问题。</p>
<h3 id="实现可重复读"><a href="#实现可重复读" class="headerlink" title="实现可重复读"></a>实现可重复读</h3><p>为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVCC (多版本并发控制) 的方式。</p>
<p>我们在数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，而这个字段就是使其产生的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111321745-614563546.png" alt="img"></p>
<p>按照上面这张图理解，一行记录现在有 3 个版本，每一个版本都记录这使其产生的事务 ID，比如事务A的transaction id 是100，那么版本1的row trx_id 就是 100，同理版本2和版本3。</p>
<p>在上面介绍读提交和可重复读的时候都提到了一个词，叫做快照，学名叫做一致性视图，这也是可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。</p>
<p>对于一个快照来说，它能够读到那些版本数据，要遵循以下规则：</p>
<ol>
<li>当前事务内的更新，可以读到；</li>
<li>版本未提交，不能读到；</li>
<li>版本已提交，但是却在快照创建后提交的，不能读到；</li>
<li>版本已提交，且是在快照创建前提交的，可以读到；</li>
</ol>
<p>利用上面的规则，再返回去套用到读提交和可重复读的那两张图上就很清晰了。还是要强调，两者主要的区别就是在快照的创建上，可重复读仅在事务开始是创建一次，而读提交每次执行语句的时候都要重新创建一次。</p>
<h3 id="并发写问题"><a href="#并发写问题" class="headerlink" title="并发写问题"></a>并发写问题</h3><p>存在这的情况，两个事务，对同一条数据做修改。最后结果应该是哪个事务的结果呢，肯定要是时间靠后的那个对不对。并且更新之前要先读数据，这里所说的读和上面说到的读不一样，更新之前的读叫做“当前读”，总是当前版本的数据，也就是多版本中最新一次提交的那版。</p>
<p>假设事务A执行 update 操作， update 的时候要对所修改的行加行锁，这个行锁会在提交之后才释放。而在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行，如果事务A的时间太长，那么事务B很有可能出现超时异常。如下图所示。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111524049-1397592588.png" alt="img"></p>
<p>加锁的过程要分有索引和无索引两种情况，比如下面这条语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age<span class="operator">=</span><span class="number">11</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>id 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。</p>
<p>而下面这条语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age<span class="operator">=</span><span class="number">11</span> <span class="keyword">where</span> age<span class="operator">=</span><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>表中并没有为 age 字段设置索引，所以， MySQL 无法直接定位到这行数据。那怎么办呢，当然也不是加表锁了。MySQL 会为这张表中所有行加行锁，没错，是所有行。但是呢，在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。虽然最终只为符合条件的行加了锁，但是这一锁一释放的过程对性能也是影响极大的。所以，如果是大表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。</p>
<h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><p>上面介绍可重复读的时候，那张图里标示着出现幻读的地方实际上在 MySQL 中并不会出现，MySQL 已经在可重复读隔离级别下解决了幻读的问题。</p>
<p>前面刚说了并发写问题的解决方式就是行锁，而解决幻读用的也是锁，叫做间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。</p>
<p>假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111536369-2106547600.png" alt="img"></p>
<p>此时，在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111546864-2006295667.png" alt="img"></p>
<p>如图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁的。</p>
<p>之后，我用下面的两个事务演示一下加锁过程。</p>
<p><img src="https://img2020.cnblogs.com/blog/273364/202003/273364-20200324111557047-915156981.png" alt="img"></p>
<p>在事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。当事务A执行<code>update user set name=&#39;风筝2号’ where age = 10;</code> 的时候，由于条件 where age &#x3D; 10 ，数据库不仅在 age &#x3D;10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。不仅插入 age &#x3D; 10 的记录需要等待事务A提交，age&lt;10、10&lt;age&lt;30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。</p>
<p>这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>MySQL 的 InnoDB 引擎才支持事务，其中可重复读是默认的隔离级别。</p>
<p>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。</p>
<p>读提交解决了脏读问题，行锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p>
<h1 id="Mvcc实现机制-RC和RR隔离级别下的区别"><a href="#Mvcc实现机制-RC和RR隔离级别下的区别" class="headerlink" title="Mvcc实现机制(RC和RR隔离级别下的区别)"></a>Mvcc实现机制(RC和RR隔离级别下的区别)</h1><p><strong>MVCC</strong>即<strong>多版本并发控制</strong>，能够保证多个读请求之间不会进行阻塞，根据事务隔离级别和事务id来确定当前事务能够查询到的数据的版本。对于每行记录来说，可能会存在多个版本，而这些版本会使用链表进行关联起来，从而控制一个事务能够查询到的数据的版本。</p>
<p>在RC（读已提交）和RR（可重复读）级别下，MVCC都会生效，那么为什么RC不可以解决幻读，而RR可以解决幻读？</p>
<p>原因： 两种隔离界别下的核心处理逻辑就是判断所有版本中哪个版本是当前事务可见的处理。针对这个问题InnoDB在设计上增加了ReadView的设计，ReadView中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为m_ids。</p>
<p>以上内容是对于 RR 级别来说，而对于 RC 级别，其实整个过程几乎一样，唯一不同的是生成 ReadView 的时机，RR 级别只在事务开始时生成一次，之后一直使用该 ReadView。而 RC 级别则在每次 select 时，都会生成一个 ReadView。</p>
<h1 id="sql优化，慢Sql如何排查"><a href="#sql优化，慢Sql如何排查" class="headerlink" title="sql优化，慢Sql如何排查"></a>sql优化，慢Sql如何排查</h1><h2 id="是否是SQL语句本身导致的慢SQL"><a href="#是否是SQL语句本身导致的慢SQL" class="headerlink" title="是否是SQL语句本身导致的慢SQL"></a>是否是SQL语句本身导致的慢SQL</h2><ul>
<li><p>SQL语句是否走了索引。此条可以用<code>explain命令</code>查看</p>
</li>
<li><p>SQL语句是不是<code>select</code>的数据量非常非常的大。比如是一个长长的<strong>json串</strong>，在网络传输的过程中会非常的耗时</p>
</li>
</ul>
<h2 id="SQL慢查询是否是其他外在因素导致的"><a href="#SQL慢查询是否是其他外在因素导致的" class="headerlink" title="SQL慢查询是否是其他外在因素导致的"></a>SQL慢查询是否是其他外在因素导致的</h2><ul>
<li>如果SQL语句本身没有问题，大概率就是偶尔出现，其他因素影响的。</li>
<li>慢SQL这段时间，请求量是否很大，MySQL是否能支撑住此刻的访问量</li>
<li>此刻时间，是否有定时任务在大量操作数据库，造成锁表等？</li>
<li>是不是其他组执行了一条很长的操作，影响了你们的SQL</li>
</ul>
<h2 id="SQL慢查询是否只在一个机房出现"><a href="#SQL慢查询是否只在一个机房出现" class="headerlink" title="SQL慢查询是否只在一个机房出现"></a>SQL慢查询是否只在一个机房出现</h2><ul>
<li><p>比如应用部署在了A, B两个机房。当时数据库在A机房。</p>
</li>
<li><p>此时A机房的应用请求数据库，明显会比B机房的应用，跨机房请求A机房的数据库要效果好。</p>
</li>
<li><p>此刻时间，是否只有跨机房才会出现慢SQL。同机房不会出现</p>
</li>
</ul>
<h2 id="SQL慢查询是否由于网络原因"><a href="#SQL慢查询是否由于网络原因" class="headerlink" title="SQL慢查询是否由于网络原因"></a>SQL慢查询是否由于网络原因</h2><ul>
<li><p>比如应用到数据库并不是直连的。应用 –&gt;  中间件A  –&gt;  中间件B  –&gt;  数据库实例</p>
</li>
<li><p>应用到中间件A。此段网络是否正常，中间件A 到B是否正常，中间件B到数据数据库是否正常等等</p>
</li>
<li><p>可以用tcpdump抓包看看。是否出现了重传的现象，是否某一刻网络出现了问题等等</p>
</li>
</ul>
<h1 id="Mysql索引设计与优化原则"><a href="#Mysql索引设计与优化原则" class="headerlink" title="Mysql索引设计与优化原则"></a>Mysql索引设计与优化原则</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li><strong>搜索条件、排序、分组和联合操作字段：</strong> 出现在<code>where</code>关键词后面的字段适合设置为索引列，或者<code>连接子句</code>中指定的列也是可以设置为索引列；</li>
<li><strong>唯一性字段（字段值基数越小）：</strong> 对于<code>唯一性的列</code>，设置索引效果是最佳的；而对于<code>具有多个重复值</code>的列，其索引效果是最差的。 因此设置索引时，大家需要考虑该列中值的分布情况；（大家注意：此处说的字段值的基数越小【即<strong>接近于</strong>除自身之外无其他重复值】，越适合做索引列，但这里不是指唯一性索引，不要陷入深深的误解哦~） <strong>扩展点</strong>：<code>区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1；</code> 简单举例说明： 如果将存放年龄字段列设置为索引列，由于各个年龄的值不同，值的<code>区分度较高</code>，可以考虑作为索引列； 而对于性别列而言：即男，女，未知；数据量基本上没有很大差别，便不适合作为索引列；</li>
<li><strong>短索引原则：</strong> 对于长字符串字段列设置索引，最好遵循短索引原则即指定前缀长度，节省大量索引空间。 例如： <code>备注</code>列字段VARCHAR(200),如果该列设置为索引列，查询效率不很高，因为索引字段长度过大，索引节点树高增加，I&#x2F;O次数也会增加。因此，对于长子字符考虑使用前缀索引。将<code>备注</code>字段值得前10个字符设置为索引，就会节省索引空间，提高效率。</li>
<li><strong>适度设置索引列:</strong>  设置索引时要考虑设置合适的列，不要造成“过多的索引列”。因为每个索引需要额外的磁盘空间，并降低写操作的性能。并且在修改表内容的时候，索引会进行更新，更有甚至需要重构，索引列越多，所花费的时间就会越长。所以只保持需要的索引有利于查询即可。如果想要给已存在索引列的表再添加索引，则需要考虑一下要增加的索引是否能够使用现有多列索引的最左索引，如果是，则无须增加该索引。<code>对于长时间不再使用或者很少使用的索引要进行删除操作。</code></li>
</ol>
<h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><p>上面说完索引的设计原则，那么我们下面探讨一下索引的优化原则吧！</p>
<ol>
<li><strong>联合索引，遵循最左前缀匹配原则</strong>： 另外需要注意大家特别容易误解的点：<code>最左匹配原则并不是指查询条件的顺序，而是指查询条件中是否包含索引最左列字段；</code></li>
<li><strong>隐式转换</strong>： 数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。</li>
<li><strong>索引列不能参与计算</strong>，保持列“干净”： 比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’)；</li>
<li><strong>范围条件存在多个索引时，查询可以命中索引</strong>： 范围条件有：&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、between等。 <ul>
<li>范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，并且索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引；</li>
<li>如果是范围查询和等值查询同时存在，优先匹配等值查询列的索引；</li>
</ul>
</li>
<li><strong>利用覆盖索引进行查询，避免回表</strong>： 被查询的列，数据能从索引中取得，而不用通过行定位符row-locator再到row上获取，即“被查询列要被所建的索引覆盖”，这能够加速查询速度。就是平时我们谈论是否select *</li>
</ol>
<h1 id="B-树与B树的区别"><a href="#B-树与B树的区别" class="headerlink" title="B+树与B树的区别"></a>B+树与B树的区别</h1><ol>
<li>B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 <strong>log n</strong>。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为**O(1)**。</li>
<li>B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</li>
<li>B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</li>
</ol>
<h1 id="Mysql有哪几种锁"><a href="#Mysql有哪几种锁" class="headerlink" title="Mysql有哪几种锁"></a>Mysql有哪几种锁</h1><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ul>
<li>表级锁是MySQL中锁定粒度最大的一种锁，表示<strong>对当前操作的整张表加锁</strong>，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。<strong>表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）</strong>。</li>
<li>特点<ul>
<li><strong>开销小，加锁快</strong>；</li>
<li>不会出现死锁；</li>
<li>锁定粒度大，<strong>发生锁冲突的概率最高，并发度最低</strong>。</li>
</ul>
</li>
</ul>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ul>
<li>行级锁是Mysql中锁定粒度最细的一种锁，表示<strong>只针对当前操作的行进行加锁</strong>。</li>
<li>行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但<strong>加锁的开销也最大</strong>。行级锁分为 共享锁 和 排他锁。</li>
<li>特点<ul>
<li>开销大，加锁慢；</li>
<li>会出现死锁；</li>
<li>锁定粒度最小，<strong>发生锁冲突的概率最低，并发度也最高</strong>。</li>
</ul>
</li>
</ul>
<h2 id="页面锁"><a href="#页面锁" class="headerlink" title="页面锁"></a>页面锁</h2><ul>
<li>页级锁是MySQL中<strong>锁定粒度介于行级锁和表级锁中间的一种锁</strong>。</li>
<li>表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，<strong>一次锁定相邻的一组记录</strong>。</li>
<li>特点<ul>
<li>开销和加锁时间界于表锁和行锁之间；</li>
<li>会出现死锁；</li>
<li>锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
</li>
</ul>
<p>封锁粒度小：</p>
<ul>
<li>好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高；</li>
<li>坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）</li>
</ul>
<h2 id="MySQL常见的锁类型？"><a href="#MySQL常见的锁类型？" class="headerlink" title="MySQL常见的锁类型？"></a>MySQL常见的锁类型？</h2><h3 id="排它锁（Exclusive-Lock）-x2F-X锁"><a href="#排它锁（Exclusive-Lock）-x2F-X锁" class="headerlink" title="排它锁（Exclusive Lock）&#x2F; X锁"></a>排它锁（Exclusive Lock）&#x2F; X锁</h3><ul>
<li>排他锁又叫做写锁。 <strong>当用户要进行数据的写入时，对数据加上排他锁</strong>。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li>
<li>事务对数据加上X锁时，只允许此事务读取和修改此数据，并且<strong>其它事务不能对该数据加任何锁</strong>；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE；   <span class="comment"># 排它锁</span></span><br></pre></td></tr></table></figure>

<h3 id="共享锁（Shared-Lock）-x2F-S锁"><a href="#共享锁（Shared-Lock）-x2F-S锁" class="headerlink" title="共享锁（Shared Lock）&#x2F; S锁"></a>共享锁（Shared Lock）&#x2F; S锁</h3><ul>
<li>共享锁又叫做读锁。 <strong>当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</strong></li>
<li>加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁</li>
<li>场景：相当于对于同一把门，它拥有多个钥匙一样。</li>
<li>在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE;  <span class="comment"># 共享锁</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/15729314-5c745ddee0791a6b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/628/format/webp" alt="img"></p>
<h3 id="意向锁（Intention-Locks）"><a href="#意向锁（Intention-Locks）" class="headerlink" title="意向锁（Intention Locks）"></a>意向锁（Intention Locks）</h3><blockquote>
<p><strong>意向锁都是表锁。</strong>意向锁的存在是为了允许事务在行级上的锁和表级上的锁同时存在。</p>
</blockquote>
<ul>
<li>意向共享锁（IS Lock）事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁。</li>
<li>意向排他锁（IX Lock）事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁。</li>
</ul>
<p>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁（因为意向锁是表锁）其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下所示</p>
<table>
<thead>
<tr>
<th>是否兼容当前锁模式</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<ul>
<li>IS&#x2F;IX 锁之间都是兼容的；</li>
<li>好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX&#x2F;IS&#x2F;X&#x2F;S锁就行了</li>
</ul>
<h4 id="意向锁到底有什么作用"><a href="#意向锁到底有什么作用" class="headerlink" title="意向锁到底有什么作用"></a>意向锁到底有什么作用</h4><ul>
<li>innodb的<strong>意向锁主要用于解决多粒度的锁并存的情况</strong>。</li>
<li>比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。</li>
<li>如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。</li>
<li>为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。</li>
<li>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。</li>
<li><strong>主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”</strong></li>
</ul>
<h1 id="唯一索引与主键索引的区别"><a href="#唯一索引与主键索引的区别" class="headerlink" title="唯一索引与主键索引的区别"></a>唯一索引与主键索引的区别</h1><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p><strong>唯一索引不允许两行具有相同的索引值。</strong></p>
<p>如果现有数据中存在重复的键值，则大多数数据库都不允许将新创建的唯一索引与表一起保存。当新数据将使表中的键值重复时，数据库也拒绝接受此数据。例如，如果在 employee 表中的职员姓氏(lname) 列上创建了唯一索引，则所有职员不能同姓。</p>
<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p><strong>主键索引是唯一索引的特殊类型</strong>，其唯一索引名为Primary Key（PK）</p>
<p>表的主键，数据库表通常有一列或多列组合，其值用来唯一标识表中的每一行，且行不重复，不为空。</p>
<p>在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。</p>
<p>主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据。</p>
<h2 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h2><p>主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键</p>
<ol>
<li>对于主键&#x2F;unique constraint ， oracle&#x2F;sql server&#x2F;mysql等都会自动建立唯一索引；</li>
<li>主键不一定只包含一个字段，所以在主键的其中一个字段建唯一索引还是必要的；</li>
<li>主键可作外键，唯一索引不可；</li>
<li>主键不可为空，唯一索引可；</li>
<li>主键也可是多个<strong>字段</strong>的组合；</li>
<li>在Oracle RBO模式下，主键的执行计划优先级要高于唯一索引；</li>
</ol>
<p><strong>主键严格于唯一索引体现：</strong></p>
<p>a. 主键有不重复、非空属性 not null</p>
<p>b. 主键在每个表只能有一个</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8FLinux/" rel="prev" title="Linux">
      <i class="fa fa-chevron-left"></i> Linux
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8FRedis/" rel="next" title="Redis">
      Redis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMySQL%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是MySQL？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.</span> <span class="nav-text">MySQL的数据类型有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">什么是索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">MySQL索引有什么优缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%EF%BC%9AB-%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">MySQL索引底层：B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-number">5.1.</span> <span class="nav-text">树的简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">5.2.</span> <span class="nav-text">树的种类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%AE%80%E4%BB%8B"><span class="nav-number">5.3.</span> <span class="nav-text">B-树、B+树简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E7%AE%80%E4%BB%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">B-树简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E7%AE%80%E4%BB%8B-1"><span class="nav-number">5.3.2.</span> <span class="nav-text">B+树简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-number">5.3.3.</span> <span class="nav-text">B+树的插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">5.3.4.</span> <span class="nav-text">B+树的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E5%8D%95%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">B+ 树单值查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">B+ 树范围查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">5.3.5.</span> <span class="nav-text">B+树的删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">5.4.</span> <span class="nav-text">B+树经典面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E4%B8%80%E6%A3%B5B-%E6%A0%91%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="nav-number">5.4.1.</span> <span class="nav-text">InnoDB一棵B+树可以存放多少行数据?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree%E7%B4%A2%E5%BC%95%E5%92%8CHash%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="nav-number">5.4.2.</span> <span class="nav-text">B+ Tree索引和Hash索引区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB-Tree%EF%BC%8CHash%E5%93%88%E5%B8%8C%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">5.4.3.</span> <span class="nav-text">为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash%E6%AF%94B-%E6%A0%91%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E5%95%A5mysql%E8%BF%98%E7%94%A8B-%E6%A0%91%E6%9D%A5%E5%AD%98%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">5.4.4.</span> <span class="nav-text">Hash比B+树更快，为啥mysql还用B+树来存索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">5.4.5.</span> <span class="nav-text">MySQL为什么使用B+树作为索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.4.6.</span> <span class="nav-text">B-树和B+树的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">MySQL常用的存储引擎有什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#InnoDB-%E5%92%8C-MyISAM-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">InnoDB 和 MyISAM 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql%E7%B4%A2%E5%BC%95"><span class="nav-number">8.</span> <span class="nav-text">Mysql索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">索引的种类有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">索引优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E8%A6%81%E4%B8%8D%E8%A6%81%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">MySQL怎么判断要不要加索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%97%E6%AE%B5%E9%83%BD%E9%80%82%E5%90%88%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">所有的字段都适合建索引吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%9A%84%E6%98%AF%E5%90%A6%E5%90%88%E7%90%86%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">如何评估一个索引创建的是否合理？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF"><span class="nav-number">14.</span> <span class="nav-text">索引失效的几种场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">如何避免索引失效？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">如何判断数据库的索引有没有生效？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">聚簇索引和非聚簇索引的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E5%8F%AA%E4%BC%9A%E6%9F%A5%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%80%8C%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%A4%9A%E6%AC%A1%E3%80%82%E6%98%AF%E6%89%80%E6%9C%89%E6%83%85%E5%86%B5%E9%83%BD%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%90%97%EF%BC%9F%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%9A%E6%AC%A1%E5%90%97%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">主键索引查询只会查一次，而非主键索引需要回表查询多次。是所有情况都是这样的吗？非主键索引一定会查询多次吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E4%B8%8E%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">19.</span> <span class="nav-text">简述索引覆盖与回表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">19.1.</span> <span class="nav-text">回表查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="nav-number">19.2.</span> <span class="nav-text">索引覆盖</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">什么是联合索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%A7%84%E5%88%99%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">联合索引的建立规则？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">22.</span> <span class="nav-text">最左匹配原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">23.</span> <span class="nav-text">数据库三大范式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="nav-number">23.1.</span> <span class="nav-text">第一范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="nav-number">23.2.</span> <span class="nav-text">第二范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="nav-number">23.3.</span> <span class="nav-text">第三范式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">24.</span> <span class="nav-text">mysql怎么实现主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E5%9F%BA%E4%BA%8E-Binlog-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">24.1.</span> <span class="nav-text">MySQL 基于 Binlog 主从复制的模式介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F-async-mode"><span class="nav-number">24.1.1.</span> <span class="nav-text">异步模式 (async-mode)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F-semi-sync"><span class="nav-number">24.1.2.</span> <span class="nav-text">半同步模式(semi-sync)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">24.1.3.</span> <span class="nav-text">全同步模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5"><span class="nav-number">25.</span> <span class="nav-text">如何防止sql注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">26.</span> <span class="nav-text">分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8"><span class="nav-number">26.1.</span> <span class="nav-text">垂直分表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93"><span class="nav-number">26.2.</span> <span class="nav-text">垂直分库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93"><span class="nav-number">26.3.</span> <span class="nav-text">水平分库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8"><span class="nav-number">26.4.</span> <span class="nav-text">水平分表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">26.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB"><span class="nav-number">27.</span> <span class="nav-text">关系型数据库与非关系型数据库区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Mysql%E5%92%8COracle%EF%BC%89"><span class="nav-number">27.1.</span> <span class="nav-text">关系型数据库（Mysql和Oracle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88redis%E5%92%8CMangDB%EF%BC%89"><span class="nav-number">27.2.</span> <span class="nav-text">非关系型数据库（redis和MangDB）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#drop%E3%80%81truncate%E5%92%8Cdelete%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">28.</span> <span class="nav-text">drop、truncate和delete的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#delete"><span class="nav-number">28.1.</span> <span class="nav-text">delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#truncate"><span class="nav-number">28.2.</span> <span class="nav-text">truncate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#drop"><span class="nav-number">28.3.</span> <span class="nav-text">drop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">28.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#left-join%E3%80%81right-join%E3%80%81inner-join%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">left join、right join、inner join的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#left-join"><span class="nav-number">29.1.</span> <span class="nav-text">left join</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inner-join"><span class="nav-number">29.2.</span> <span class="nav-text">inner join</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="nav-number">30.</span> <span class="nav-text">MySQL事务及特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81%E4%B8%8D%E5%90%8C%E7%AD%89%E7%BA%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">31.</span> <span class="nav-text">Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%BA%8B%E5%8A%A1"><span class="nav-number">31.1.</span> <span class="nav-text">MySQL 事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E"><span class="nav-number">31.2.</span> <span class="nav-text">概念说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB"><span class="nav-number">31.2.1.</span> <span class="nav-text">脏读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">31.2.2.</span> <span class="nav-text">可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">31.2.3.</span> <span class="nav-text">不可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BB%E8%AF%BB"><span class="nav-number">31.2.4.</span> <span class="nav-text">幻读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">31.3.</span> <span class="nav-text">事务隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F"><span class="nav-number">31.4.</span> <span class="nav-text">一探究竟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">31.4.1.</span> <span class="nav-text">如何设置隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1"><span class="nav-number">31.4.2.</span> <span class="nav-text">MySQL 中执行事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="nav-number">31.4.3.</span> <span class="nav-text">读未提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E6%8F%90%E4%BA%A4"><span class="nav-number">31.4.4.</span> <span class="nav-text">读提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-1"><span class="nav-number">31.4.5.</span> <span class="nav-text">可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">31.4.6.</span> <span class="nav-text">串行化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84"><span class="nav-number">31.5.</span> <span class="nav-text">MySQL 中是如何实现事务隔离的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">31.5.1.</span> <span class="nav-text">实现可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%86%99%E9%97%AE%E9%A2%98"><span class="nav-number">31.5.2.</span> <span class="nav-text">并发写问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="nav-number">31.5.3.</span> <span class="nav-text">解决幻读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">31.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mvcc%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6-RC%E5%92%8CRR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">32.</span> <span class="nav-text">Mvcc实现机制(RC和RR隔离级别下的区别)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sql%E4%BC%98%E5%8C%96%EF%BC%8C%E6%85%A2Sql%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="nav-number">33.</span> <span class="nav-text">sql优化，慢Sql如何排查</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E6%98%AFSQL%E8%AF%AD%E5%8F%A5%E6%9C%AC%E8%BA%AB%E5%AF%BC%E8%87%B4%E7%9A%84%E6%85%A2SQL"><span class="nav-number">33.1.</span> <span class="nav-text">是否是SQL语句本身导致的慢SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%90%A6%E6%98%AF%E5%85%B6%E4%BB%96%E5%A4%96%E5%9C%A8%E5%9B%A0%E7%B4%A0%E5%AF%BC%E8%87%B4%E7%9A%84"><span class="nav-number">33.2.</span> <span class="nav-text">SQL慢查询是否是其他外在因素导致的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%90%A6%E5%8F%AA%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9C%BA%E6%88%BF%E5%87%BA%E7%8E%B0"><span class="nav-number">33.3.</span> <span class="nav-text">SQL慢查询是否只在一个机房出现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%90%A6%E7%94%B1%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0"><span class="nav-number">33.4.</span> <span class="nav-text">SQL慢查询是否由于网络原因</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="nav-number">34.</span> <span class="nav-text">Mysql索引设计与优化原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">34.1.</span> <span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="nav-number">34.2.</span> <span class="nav-text">优化原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E4%B8%8EB%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">35.</span> <span class="nav-text">B+树与B树的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81"><span class="nav-number">36.</span> <span class="nav-text">Mysql有哪几种锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">36.1.</span> <span class="nav-text">表级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-number">36.2.</span> <span class="nav-text">行级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E9%94%81"><span class="nav-number">36.3.</span> <span class="nav-text">页面锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">36.4.</span> <span class="nav-text">MySQL常见的锁类型？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%AE%83%E9%94%81%EF%BC%88Exclusive-Lock%EF%BC%89-x2F-X%E9%94%81"><span class="nav-number">36.4.1.</span> <span class="nav-text">排它锁（Exclusive Lock）&#x2F; X锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%88Shared-Lock%EF%BC%89-x2F-S%E9%94%81"><span class="nav-number">36.4.2.</span> <span class="nav-text">共享锁（Shared Lock）&#x2F; S锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Intention-Locks%EF%BC%89"><span class="nav-number">36.4.3.</span> <span class="nav-text">意向锁（Intention Locks）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">36.4.3.1.</span> <span class="nav-text">意向锁到底有什么作用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">37.</span> <span class="nav-text">唯一索引与主键索引的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">37.1.</span> <span class="nav-text">唯一索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">37.2.</span> <span class="nav-text">主键索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%80%85%E6%AF%94%E8%BE%83"><span class="nav-number">37.3.</span> <span class="nav-text">二者比较</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

