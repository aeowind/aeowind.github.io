<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="谈论连场大雨你窗台漏水不得了 从来未爱你绵绵">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记（一）">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="谈论连场大雨你窗台漏水不得了 从来未爱你绵绵">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.413Z">
<meta property="article:modified_time" content="2021-07-05T01:57:59.203Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM学习笔记（一） | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM学习笔记（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-05 09:57:59" itemprop="dateModified" datetime="2021-07-05T09:57:59+08:00">2021-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">谈论连场大雨你窗台漏水不得了 从来未爱你绵绵</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="jvm-内存结构">JVM 内存结构</h1>
<p><strong>Java 虚拟机的内存空间</strong>分为 5 个部分：</p>
<ul>
<li>程序计数器</li>
<li>Java 虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2RqkQg"><img
src="https://z3.ax1x.com/2021/06/10/2RqkQg.jpg"
alt="2RqkQg.jpg" /></a></p>
<p><code>JDK 1.8</code> 同 <code>JDK 1.7</code>
比，最大的<strong>差别</strong>就是：<strong>元数据区取代了永久代</strong>。元空间的本质和永久代类似，都是对
JVM
规范中方法区的实现。不过<code>元空间与永久代之间最大的区别</code>在于：<strong>元数据空间并不在虚拟机中，而是使用本地内存</strong>。</p>
<h2 id="程序计数器pc-寄存器">程序计数器（PC 寄存器）</h2>
<h3 id="程序计数器的定义">程序计数器的定义</h3>
<p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p>
<h3 id="程序计数器的作用">程序计数器的作用</h3>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li>
<li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li>
</ul>
<h3 id="程序计数器的特点">程序计数器的特点</h3>
<ul>
<li>是一块较小的内存空间。</li>
<li>线程私有，每条线程都有自己的程序计数器。</li>
<li><code>生命周期</code>：随着线程的创建而创建，随着线程的结束而销毁。</li>
<li>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</li>
</ul>
<h2 id="java-虚拟机栈java-栈">Java 虚拟机栈（Java 栈）</h2>
<h3 id="java-虚拟机栈的定义">Java 虚拟机栈的定义</h3>
<p><code>Java 虚拟机栈</code>是描述 <strong>Java
方法运行过程的内存模型</strong>。</p>
<p>Java 虚拟机栈会为每一个即将运行的 Java
方法创建一块叫做“<strong>栈帧</strong>”的区域，用于存放该方法运行过程中的一些信息，如：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口信息</li>
<li>......</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2WmIvF"><img
src="https://z3.ax1x.com/2021/06/11/2WmIvF.jpg"
alt="2WmIvF.jpg" /></a></p>
<h3 id="压栈出栈过程">压栈出栈过程</h3>
<p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p>
<p>Java
虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC
寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p>
<p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p>
<blockquote>
<p>由于 Java
虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</p>
</blockquote>
<h3 id="java-虚拟机栈的特点">Java 虚拟机栈的特点</h3>
<ul>
<li><code>局部变量表</code>随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li>
<li>Java 虚拟机栈会出现两种异常：<strong>StackOverFlowError</strong> 和
<strong>OutOfMemoryError</strong>。
<ul>
<li><code>StackOverFlowError</code> 若 Java
虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java
虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li>
<li><code>OutOfMemoryError</code>
若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出
OutOfMemoryError 异常。</li>
</ul></li>
<li><code>Java 虚拟机栈</code>也是<strong>线程私有</strong>，随着线程创建而创建，随着线程的结束而销毁。</li>
</ul>
<blockquote>
<p>出现 StackOverFlowError 时，内存空间可能还有很多。</p>
</blockquote>
<h2 id="本地方法栈c-栈">本地方法栈（C 栈）</h2>
<h3 id="本地方法栈的定义">本地方法栈的定义</h3>
<p><strong>本地方法栈</strong>是为 JVM 运行 Native
方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫
C 栈。它与 Java
虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>
<h3 id="栈帧变化过程">栈帧变化过程</h3>
<p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p>
<p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出
StackOverFlowError 和 OutOfMemoryError 异常。</p>
<blockquote>
<p>如果 Java 虚拟机本身不支持 Native
方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p>
</blockquote>
<h2 id="堆">堆</h2>
<h3 id="堆的定义">堆的定义</h3>
<p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。</p>
<h3 id="堆的特点">堆的特点</h3>
<ul>
<li>线程共享，整个 Java
虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java
虚拟机栈、本地方法栈都是一个线程对应一个。</li>
<li>在虚拟机启动时创建。</li>
<li>是垃圾回收的主要场所。</li>
<li>进一步可分为：新生代（Eden
区：<code>From Survior</code>，<code>To Survivor</code>）、老年代。</li>
</ul>
<p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p>
<p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出
OutOfMemoryError 异常。</p>
<blockquote>
<p>Java
堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p>
</blockquote>
<h2 id="方法区">方法区</h2>
<h3 id="方法区的定义">方法区的定义</h3>
<p>Java
虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：</p>
<ul>
<li>已经被虚拟机加载的类信息</li>
<li>常量</li>
<li>静态变量</li>
<li>即时编译器编译后的代码</li>
</ul>
<h3 id="方法区的特点">方法区的特点</h3>
<ul>
<li><code>线程共享</code>。
方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li>
<li><code>永久代</code>。
方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li>
<li><code>内存回收效率低</code>。
方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li>
<li>Java 虚拟机规范对方法区的要求比较宽松。
和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。</li>
</ul>
<h3 id="运行时常量池">运行时常量池</h3>
<p>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</p>
<p>当类被 Java 虚拟机加载后， .class
文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如
String 类的 <code>intern()</code>
方法就能在运行期间向常量池中添加字符串常量。</p>
<h2 id="直接内存堆外内存">直接内存（堆外内存）</h2>
<p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p>
<h3 id="操作直接内存">操作直接内存</h3>
<p>在 NIO 中引入了一种基于通道和缓冲的 IO
方式。它可以通过调用本地方法直接分配 Java
虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p>
<p>直接内存的大小不受 Java
虚拟机控制，但既然是内存，当内存不足时就会抛出
<code>OutOfMemoryError</code> 异常。</p>
<h3 id="直接内存与堆内存比较">直接内存与堆内存比较</h3>
<ul>
<li>直接内存申请空间耗费更高的性能</li>
<li>直接内存读取 IO 的性能要优于普通的堆内存。</li>
<li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</li>
<li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存
-&gt; 本地 IO</li>
</ul>
<blockquote>
<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p>
</blockquote>
<h1 id="hotspot-虚拟机对象探秘">HotSpot 虚拟机对象探秘</h1>
<h2 id="对象的内存布局">对象的内存布局</h2>
<p>在 HotSpot 虚拟机中，<code>对象的内存布局</code>分为以下 3
块区域：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RUGHr4"><img
src="https://z3.ax1x.com/2021/06/28/RUGHr4.png"
alt="RUGHr4.png" /></a></p>
<h3 id="对象头">对象头</h3>
<p><strong>对象头</strong>记录了对象在运行过程中所需要使用的一些数据：</p>
<ul>
<li>哈希码</li>
<li>GC 分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程 ID</li>
<li>偏向时间戳</li>
</ul>
<p><strong>对象头</strong>可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。</p>
<h3 id="实例数据">实例数据</h3>
<p>实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。</p>
<h3 id="对齐填充">对齐填充</h3>
<p>用于确保对象的总长度为 8 字节的整数倍。</p>
<p>HotSpot VM 的自动内存管理系统要求对象的大小必须是 8
字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2
倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<blockquote>
<p>对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。</p>
</blockquote>
<h2 id="对象的创建过程">对象的创建过程</h2>
<h3 id="类加载检查">类加载检查</h3>
<p>虚拟机在解析<code>.class</code>文件时，若遇到一条 new
指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p>
<h3 id="为新生对象分配内存">为新生对象分配内存</h3>
<p>对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：</p>
<ul>
<li><p><strong>指针碰撞</strong><br> 如果 Java
<strong>堆中内存绝对规整</strong>（说明采用的是“<strong>复制算法</strong>”或“<strong>标记整理法</strong>”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</p></li>
<li><p><strong>空闲列表</strong><br> 如果 Java
<strong>堆中内存并不规整</strong>，已使用的内存和空闲内存交错（说明采用的是<strong>标记-清除法</strong>，有碎片），此时没法简单进行指针碰撞，
VM
必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“<strong>空闲列表</strong>”。</p></li>
</ul>
<h3 id="初始化">初始化</h3>
<p>分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。</p>
<p>至此，整个对象的创建过程就完成了。</p>
<h2 id="对象的访问方式">对象的访问方式</h2>
<p>所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。
那么根据引用存放的地址类型的不同，对象有不同的访问方式。</p>
<h3 id="句柄访问方式">句柄访问方式</h3>
<p>堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p>引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RUJKsg"><img
src="https://z3.ax1x.com/2021/06/28/RUJKsg.jpg"
alt="RUJKsg.jpg" /></a></p>
<h3 id="直接指针访问方式">直接指针访问方式</h3>
<p>引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RUJ1ds"><img
src="https://z3.ax1x.com/2021/06/28/RUJ1ds.jpg"
alt="RUJ1ds.jpg" /></a></p>
<p>需要说明的是，HotSpot
采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要<strong>额外的策略</strong>来存储对象在方法区中类信息的地址。</p>
<h1 id="垃圾收集策略与算法">垃圾收集策略与算法</h1>
<p>程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p>
<p>而对于 Java
堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。</p>
<h2 id="判定对象是否存活">判定对象是否存活</h2>
<p>若一个对象不被任何对象或变量引用，那么它就是无效对象，需要被回收。</p>
<h3 id="引用计数法">引用计数法</h3>
<p>在对象头维护着一个
<code>counter 计数器</code>，对象被引用一次则计数器
+1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。</p>
<p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的
Java
虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。</p>
<blockquote>
<p>举个栗子 👉 对象 objA 和 objB 都有字段 instance，令 objA.instance =
objB 并且 objB.instance =
objA，由于它们互相引用着对方，导致它们的引用计数都不为
0，于是引用计数算法无法通知 GC 收集器回收它们。</p>
</blockquote>
<h3 id="可达性分析法">可达性分析法</h3>
<p>所有和 <code>GC Roots</code> 直接或间接关联的对象都是有效对象，和 GC
Roots 没有关联的对象就是无效对象。</p>
<p><code>GC Roots</code> 是指：</p>
<ul>
<li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
</ul>
<p>GC Roots
<strong>并不包括堆中对象所引用的对象</strong>，这样就不会有循环引用的问题。</p>
<h2 id="引用的种类">引用的种类</h2>
<p>判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java
中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p>
<p>在 JDK 1.2 之后，Java
对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态<code>reachable</code>和垃圾收集的影响。</p>
<h3 id="强引用strong-reference">强引用（Strong Reference）</h3>
<p>类似 "Object obj = new Object()"
这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们<strong>错误地保持了强引用</strong>，比如：赋值给了
static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。</p>
<h3 id="软引用soft-reference">软引用（Soft Reference）</h3>
<p>软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当
JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出
OutOfMemoryError
之前，清理软引用指向的对象。软引用通常用来<strong>实现内存敏感的缓存</strong>，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<h3 id="弱引用weak-reference">弱引用（Weak Reference）</h3>
<p>弱引用的<strong>强度比软引用更弱</strong>一些。当 JVM
进行垃圾回收时，<strong>无论内存是否充足，都会回收</strong>只被弱引用关联的对象。</p>
<h3 id="虚引用phantom-reference">虚引用（Phantom Reference）</h3>
<p>虚引用也称幽灵引用或者幻影引用，它是<strong>最弱</strong>的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被
finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem
清理机制。</p>
<h2 id="回收堆中无效对象">回收堆中无效对象</h2>
<p>对于可达性分析中不可达的对象，也并不是没有存活的可能。</p>
<h3 id="判定-finalize-是否有必要执行">判定 finalize()
是否有必要执行</h3>
<p>JVM 会判断此对象是否有必要执行 finalize() 方法，如果对象没有覆盖
finalize() 方法，或者 finalize()
方法已经被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。</p>
<p>如果对象被判定为有必要执行 finalize() 方法，那么对象会被放入一个
F-Queue 队列中，虚拟机会以较低的优先级执行这些
finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果
finalize()
方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。</p>
<h3 id="对象重生或死亡">对象重生或死亡</h3>
<p>如果在执行 finalize() 方法时，将 this
赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。</p>
<blockquote>
<p>任何一个对象的 finalize()
方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize()
方法不会被再次执行，想继续在 finalize() 中自救就失效了。</p>
</blockquote>
<h2 id="回收方法区内存">回收方法区内存</h2>
<p>方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：</p>
<ul>
<li>废弃常量</li>
<li>无用的类</li>
</ul>
<h3 id="判定废弃常量">判定废弃常量</h3>
<p>只要<strong>常量池中的常量不被任何变量或对象引用</strong>，那么这些常量就会被清除掉。比如，一个字符串
"bingo" 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的
"bingo"
常量，也没有其它地方引用这个字面量，必要的话，"bingo"常量会被清理出常量池。</p>
<h3 id="判定无用的类">判定无用的类</h3>
<p>判定一个类是否是“无用的类”，条件较为苛刻。</p>
<ul>
<li>该类的所有对象都已经被清除</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收</li>
<li>该类的 <code>java.lang.Class</code>
对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<blockquote>
<p>一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：<code>java.lang.Class</code>。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。</p>
</blockquote>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<p>学会了如何判定无效对象、无用类、废弃常量之后，剩余工作就是回收这些垃圾。常见的垃圾收集算法有以下几个：</p>
<h3 id="标记-清除算法">标记-清除算法</h3>
<p><strong>标记</strong>的过程是：遍历所有的
<code>GC Roots</code>，然后将所有 <code>GC Roots</code>
可达的对象<strong>标记为存活的对象</strong>。</p>
<p><strong>清除</strong>的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。</p>
<p>这种方法有两个<strong>不足</strong>：</p>
<ul>
<li><code>效率问题</code>：标记和清除两个过程的效率都不高。</li>
<li><code>空间问题</code>：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<h3 id="复制算法新生代">复制算法（新生代）</h3>
<p>为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。这种算法有优有劣：</p>
<ul>
<li><code>优点</code>：不会有内存碎片的问题。</li>
<li><code>缺点</code>：内存缩小为原来的一半，浪费空间。</li>
</ul>
<p>为了解决空间利用率问题，可以将内存分为三块：
<code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code>，比例是
8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor
中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden
和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。</p>
<p>但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor
空间不够，需要依赖其他内存（指老年代）进行分配担保。</p>
<h4 id="分配担保">分配担保</h4>
<p>为对象分配内存空间时，如果 <code>Eden+Survivor</code>
中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC
过后依然有超过 10%
的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入
Eden 区。</p>
<h3 id="标记-整理算法老年代">标记-整理算法（老年代）</h3>
<p><strong>标记</strong>：它的第一个阶段与<strong>标记/清除算法</strong>是一模一样的，均是遍历
<code>GC Roots</code>，然后将存活的对象标记。</p>
<p><strong>整理</strong>：移动所有<strong>存活的对象</strong>，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</p>
<p>这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。</p>
<h3 id="分代收集算法">分代收集算法</h3>
<p>根据对象存活周期的不同，将内存划分为几块。一般是把 Java
堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。</p>
<ul>
<li><strong>新生代</strong>：复制算法</li>
<li><strong>老年代</strong>：标记-清除算法、标记-整理算法</li>
</ul>
<h1 id="hotspot-垃圾收集器">HotSpot 垃圾收集器</h1>
<p><strong>HotSpot
虚拟机</strong>提供了多种垃圾收集器，每种收集器都有各自的特点，虽然我们要对各个收集器进行比较，但并非为了挑选出一个最好的收集器。我们选择的只是对具体应用最合适的收集器。</p>
<h2 id="新生代垃圾收集器">新生代垃圾收集器</h2>
<h3 id="serial-垃圾收集器单线程">Serial 垃圾收集器（单线程）</h3>
<p>只开启<strong>一条</strong>
<code>GC 线程</code>进行垃圾回收，并且在垃圾收集过程中停止一切用户线程(Stop
The World)。</p>
<p>一般客户端应用所需内存较小，不会创建太多对象，而且堆内存不大，因此垃圾收集器回收时间短，即使在这段时间停止一切用户线程，也不会感觉明显卡顿。因此
Serial 垃圾收集器<strong>适合客户端</strong>使用。</p>
<p>由于 Serial 收集器只使用一条 GC
线程，<strong>避免了线程切换的开销</strong>，从而简单高效。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Rc3Pvd"><img
src="https://z3.ax1x.com/2021/07/02/Rc3Pvd.png"
alt="Rc3Pvd.png" /></a></p>
<h3 id="parnew-垃圾收集器多线程">ParNew 垃圾收集器（多线程）</h3>
<p><code>ParNew</code> 是 Serial
的多线程版本。由<strong>多条</strong><code>GC 线程</code>并行地进行垃圾清理。但清理过程依然需要
Stop The World。</p>
<p><code>ParNew</code> 追求“<strong>低停顿时间</strong>”,与 Serial
唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial
会有一定程度的提升；但<strong>线程切换需要额外的开销</strong>，因此在单
CPU 环境中表现不如 Serial。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Rc33bq"><img
src="https://z3.ax1x.com/2021/07/02/Rc33bq.png"
alt="Rc33bq.png" /></a></p>
<h3 id="parallel-scavenge-垃圾收集器多线程">Parallel Scavenge
垃圾收集器（多线程）</h3>
<p><code>Parallel Scavenge</code> 和 ParNew
一样，都是多线程、新生代垃圾收集器。但是两者有巨大的<strong>不同点</strong>：</p>
<ul>
<li><code>Parallel Scavenge</code>：追求 CPU
吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。</li>
<li><code>ParNew</code>：追求降低用户停顿时间，适合交互式应用。</li>
</ul>
<p><strong>吞吐量</strong> = 运行用户代码时间 / (运行用户代码时间 +
垃圾收集时间)</p>
<p>追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行
GC 意味着每当 GC
运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC
需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行
GC 以便更快速完成，反过来又导致吞吐量下降。</p>
<ul>
<li>通过参数 <code>-XX:GCTimeRadio</code> 设置垃圾回收时间占总 CPU
时间的百分比。</li>
<li>通过参数 <code>-XX:MaxGCPauseMillis</code>
设置垃圾处理过程最久停顿时间。</li>
<li>通过命令 <code>-XX:+UseAdaptiveSizePolicy</code>
开启自适应策略。我们只要设置好堆的大小和 MaxGCPauseMillis 或
GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor
的比例、对象进入老年代的年龄，以最大程度上接近我们设置的
MaxGCPauseMillis 或 GCTimeRadio。</li>
</ul>
<h2 id="老年代垃圾收集器">老年代垃圾收集器</h2>
<h3 id="serial-old-垃圾收集器单线程">Serial Old
垃圾收集器（单线程）</h3>
<p><strong>Serial Old 收集器</strong>是 Serial
的老年代版本，都是<code>单线程</code>收集器，只启用一条 GC
线程，都适合客户端应用。它们唯一的<strong>区别</strong>就是：Serial Old
工作在老年代，使用“标记-整理”算法；Serial
工作在新生代，使用“复制”算法。</p>
<h3 id="parallel-old-垃圾收集器多线程">Parallel Old
垃圾收集器（多线程）</h3>
<p><code>Parallel Old 收集器</code> 是 Parallel Scavenge
的老年代版本，追求 CPU 吞吐量。</p>
<h3 id="cms-垃圾收集器">CMS 垃圾收集器</h3>
<p><strong>CMS</strong>(Concurrent Mark
Sweep，并发标记清除)<strong>收集器</strong>是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和
GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。</p>
<ul>
<li><strong>初始标记</strong>：Stop The
World，仅使用一条初始标记线程对所有与 GC Roots
直接关联的对象进行标记。</li>
<li><strong>并发标记</strong>：使用<strong>多条</strong>标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。</li>
<li><strong>重新标记</strong>：Stop The
World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。</li>
<li><strong>并发清除</strong>：只使用一条 GC
线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。</li>
</ul>
<p>并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，<strong>总体上说</strong>，CMS
收集器的内存回收过程是与用户线程<strong>一起并发执行</strong>的。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RfJEhn"><img
src="https://z3.ax1x.com/2021/07/04/RfJEhn.png"
alt="RfJEhn.png" /></a></p>
<p><code>CMS</code> 的<strong>缺点</strong>：</p>
<ul>
<li>吞吐量低</li>
<li>无法处理浮动垃圾，导致频繁 Full GC</li>
<li>使用“标记-清除”算法产生碎片空间</li>
</ul>
<p>对于产生碎片空间的问题，可以通过开启
<code>-XX:+UseCMSCompactAtFullCollection</code>，在每次 Full GC
完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数
<code>-XX:CMSFullGCsBeforeCompaction</code> 告诉 CMS，经过了 N 次 Full
GC 之后再进行一次内存整理。</p>
<h2 id="g1-通用垃圾收集器">G1 通用垃圾收集器</h2>
<p><strong>G1</strong>
是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的
Region。当要进行垃圾收集时，首先估计每个 Region
中垃圾的数量，每次都从垃圾回收价值最大的 Region
开始回收，因此可以获得最大的回收效率。</p>
<p>从整体上看， <strong>G1</strong>
是基于“<code>标记-整理</code>”算法实现的收集器，从局部（两个 Region
之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</p>
<p>这里抛个问题 👇<br> &gt; 一个对象和它内部所引用的对象可能不在同一个
Region
中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次<strong>可达性分析</strong>？</p>
<ul>
<li>并不！每个 Region 都有一个 Remembered
Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在
GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历。</li>
</ul>
<p>如果不计算维护 Remembered Set 的操作，G1
收集器的工作过程分为以下几个<strong>步骤</strong>：</p>
<ul>
<li><strong>初始标记</strong>：Stop The
World，仅使用一条初始标记线程对所有与 GC Roots
直接关联的对象进行标记。</li>
<li><strong>并发标记</strong>：使用<strong>一条</strong>标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。</li>
<li><strong>最终标记</strong>：Stop The
World，使用多条标记线程并发执行。</li>
<li><strong>筛选回收</strong>：回收废弃对象，此时也要 Stop The
World，并使用多条筛选回收线程并发执行。</li>
</ul>
<h1 id="内存分配与回收策略">内存分配与回收策略</h1>
<p><code>对象的内存分配</code>，就是在堆上分配（也可能经过 JIT
编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的 Eden
区上，少数情况下可能直接分配在老年代，<strong>分配规则不固定</strong>，取决于当前使用的垃圾收集器组合以及相关的参数配置。</p>
<p>以下列举几条最普遍的内存分配规则，供大家学习。</p>
<h2 id="对象优先在-eden-分配">对象优先在 Eden 分配</h2>
<p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden
区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<p>👇<strong>Minor GC</strong> vs <strong>Major GC</strong>/<strong>Full
GC</strong>：</p>
<ul>
<li><code>Minor GC</code>：回收新生代（包括 Eden 和 Survivor
区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC
非常频繁，一般回收速度也比较快。</li>
<li><code>Major GC / Full GC</code>: 回收老年代，出现了 Major
GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比
Minor GC 慢 10 倍 以上。</li>
</ul>
<blockquote>
<p>在 JVM 规范中，<code>Major GC</code> 和 <code>Full GC</code>
都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full
GC 清理整个内存堆。</p>
</blockquote>
<h2 id="大对象直接进入老年代">大对象直接进入老年代</h2>
<p><code>大对象</code>是指<strong>需要大量连续内存空间的 Java
对象</strong>，如很长的字符串或数据。</p>
<p>一个大对象能够存入 Eden
区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。</p>
<p>虚拟机提供了一个 <code>-XX:PretenureSizeThreshold</code>
参数，令大于这个设置值的对象<strong>直接在老年代分配</strong>，这样做的目的是避免在
Eden 区及两个 Survivor
区之间发生大量的内存复制。（还记得吗，新生代采用复制算法回收垃圾）</p>
<h2 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h2>
<p>JVM 给每个对象定义了一个<code>对象年龄计数器</code>。当新生代发生一次
Minor GC 后，存活下来的对象年龄
+1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。</p>
<p>使用 <code>-XXMaxTenuringThreshold</code>
设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。</p>
<h2 id="动态对象年龄判定">动态对象年龄判定</h2>
<p>如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor
空间的一半，年龄 &gt;= 该年龄的对象就可以直接进入老年代，无须等到
<code>MaxTenuringThreshold</code> 中要求的年龄。</p>
<h2 id="空间分配担保">空间分配担保</h2>
<ul>
<li><p><code>JDK 6 Update 24</code> 之前的规则是这样的：<br />
在发生 Minor GC
之前，虚拟机会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，
如果这个条件成立，Minor GC 可以确保是安全的； 如果不成立，则虚拟机会查看
<code>HandlePromotionFailure</code> 值是否设置为允许担保失败，
如果是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的；
如果小于，或者 <code>HandlePromotionFailure</code>
设置不允许冒险，那此时也要改为进行一次 Full GC。</p></li>
<li><p><code>JDK 6 Update 24</code> 之后的规则变为：<br />
只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行
Minor GC，否则将进行 Full GC。</p></li>
</ul>
<p>通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。</p>
<p>这个过程就是<strong>分配担保</strong>。</p>
<hr />
<p>👇 总结一下有哪些情况可能会触发 JVM 进行 <strong>Full
GC</strong>。</p>
<ol type="1">
<li><p><strong>System.gc() 方法的调用</strong></p>
<p>此方法的调用是建议 JVM 进行 Full
GC，注意这<strong>只是建议而非一定</strong>，但在很多情况下它会触发 Full
GC，从而增加 Full GC
的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过
<code>-XX:+ DisableExplicitGC</code> 来禁止调用
<code>System.gc()</code>。</p></li>
<li><p><strong>老年代空间不足</strong></p>
<p>老年代空间不足会触发 <code>Full GC</code>
操作，若进行该操作后空间依然不足，则会抛出如下错误： <br>
<code>java.lang.OutOfMemoryError: Java heap space</code></p></li>
<li><p><strong>永久代空间不足</strong></p>
<p>JVM 规范中运行时数据区域中的方法区，在 HotSpot
虚拟机中也称为永久代（Permanet
Generation），存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发
Full GC。如果经过 Full GC 仍然回收不了，那么 JVM
会抛出如下错误信息：<br>
<code>java.lang.OutOfMemoryError: PermGen space</code></p></li>
<li><p><strong>CMS GC 时出现 promotion failed 和 concurrent mode
failure</strong></p>
<p>promotion failed，就是上文所说的担保失败，而 concurrent mode failure
是在执行 CMS GC
的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。</p></li>
<li><p><strong>统计得到的 Minor GC
晋升到旧生代的平均大小大于老年代的剩余空间</strong></p></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="prev" title="JVM学习笔记（二）">
      <i class="fa fa-chevron-left"></i> JVM学习笔记（二）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/LeetCode1/" rel="next" title="LeetCode1">
      LeetCode1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">JVM 内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8pc-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器（PC 寄存器）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">程序计数器的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">程序计数器的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.3.</span> <span class="nav-text">程序计数器的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88java-%E6%A0%88"><span class="nav-number">1.2.</span> <span class="nav-text">Java 虚拟机栈（Java 栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">Java 虚拟机栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E6%A0%88%E5%87%BA%E6%A0%88%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">压栈出栈过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.3.</span> <span class="nav-text">Java 虚拟机栈的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88c-%E6%A0%88"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈（C 栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">本地方法栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%E5%8F%98%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">栈帧变化过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.4.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.1.</span> <span class="nav-text">堆的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.4.2.</span> <span class="nav-text">堆的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.5.1.</span> <span class="nav-text">方法区的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.2.</span> <span class="nav-text">方法区的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.5.3.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="nav-number">1.6.</span> <span class="nav-text">直接内存（堆外内存）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">1.6.1.</span> <span class="nav-text">操作直接内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83"><span class="nav-number">1.6.2.</span> <span class="nav-text">直接内存与堆内存比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hotspot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98"><span class="nav-number">2.</span> <span class="nav-text">HotSpot 虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.1.</span> <span class="nav-text">对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">2.1.1.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.2.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85"><span class="nav-number">2.1.3.</span> <span class="nav-text">对齐填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">对象的创建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="nav-number">2.2.1.</span> <span class="nav-text">类加载检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E6%96%B0%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">2.2.2.</span> <span class="nav-text">为新生对象分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.3.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">对象的访问方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.1.</span> <span class="nav-text">句柄访问方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text">直接指针访问方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">垃圾收集策略与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB"><span class="nav-number">3.1.</span> <span class="nav-text">判定对象是否存活</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">可达性分析法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">引用的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8strong-reference"><span class="nav-number">3.2.1.</span> <span class="nav-text">强引用（Strong Reference）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8soft-reference"><span class="nav-number">3.2.2.</span> <span class="nav-text">软引用（Soft Reference）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8weak-reference"><span class="nav-number">3.2.3.</span> <span class="nav-text">弱引用（Weak Reference）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8phantom-reference"><span class="nav-number">3.2.4.</span> <span class="nav-text">虚引用（Phantom Reference）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%A0%86%E4%B8%AD%E6%97%A0%E6%95%88%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.3.</span> <span class="nav-text">回收堆中无效对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A-finalize-%E6%98%AF%E5%90%A6%E6%9C%89%E5%BF%85%E8%A6%81%E6%89%A7%E8%A1%8C"><span class="nav-number">3.3.1.</span> <span class="nav-text">判定 finalize()
是否有必要执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E9%87%8D%E7%94%9F%E6%88%96%E6%AD%BB%E4%BA%A1"><span class="nav-number">3.3.2.</span> <span class="nav-text">对象重生或死亡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98"><span class="nav-number">3.4.</span> <span class="nav-text">回收方法区内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F"><span class="nav-number">3.4.1.</span> <span class="nav-text">判定废弃常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="nav-number">3.4.2.</span> <span class="nav-text">判定无用的类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="nav-number">3.5.2.</span> <span class="nav-text">复制算法（新生代）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">分配担保</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.5.3.</span> <span class="nav-text">标记-整理算法（老年代）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hotspot-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">HotSpot 垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">新生代垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#serial-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">Serial 垃圾收集器（单线程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parnew-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">ParNew 垃圾收集器（多线程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallel-scavenge-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.1.3.</span> <span class="nav-text">Parallel Scavenge
垃圾收集器（多线程）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">老年代垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#serial-old-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.2.1.</span> <span class="nav-text">Serial Old
垃圾收集器（单线程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallel-old-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.2.2.</span> <span class="nav-text">Parallel Old
垃圾收集器（多线程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cms-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text">CMS 垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#g1-%E9%80%9A%E7%94%A8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">G1 通用垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">5.</span> <span class="nav-text">内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-eden-%E5%88%86%E9%85%8D"><span class="nav-number">5.1.</span> <span class="nav-text">对象优先在 Eden 分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">5.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">5.3.</span> <span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="nav-number">5.4.</span> <span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">5.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

