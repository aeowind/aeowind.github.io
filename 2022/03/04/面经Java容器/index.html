<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="就在一瞬间 握紧我矛盾密布的手">
<meta property="og:type" content="article">
<meta property="og:title" content="Java容器">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJava%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="就在一瞬间 握紧我矛盾密布的手">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.461Z">
<meta property="article:modified_time" content="2022-04-14T05:40:22.765Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJava%E5%AE%B9%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java容器 | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/%E9%9D%A2%E7%BB%8FJava%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java容器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 13:40:22" itemprop="dateModified" datetime="2022-04-14T13:40:22+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E7%BB%8F/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">就在一瞬间 握紧我矛盾密布的手</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="hashmap的底层原理">HashMap的底层原理</h1>
<p><strong>HashMap</strong>由<strong>数组和链表</strong>来实现对数据的存储。在<strong>Jdk1.8</strong>中HashMap的实现方式做了一些改变，但是基本思想还是没有变的，只是在一些地方做了优化，数据结构的存储由<strong>数组+链表</strong>的方式，变化为<strong>数组+链表+红黑树</strong>的存储方式，当<strong>链表长度超过阈值（8）时，将链表转换为红黑树</strong>。在性能上进一步得到提升。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7xO7I1"><img
src="https://s4.ax1x.com/2022/01/28/7xO7I1.md.png"
alt="7xO7I1.md.png" /></a></p>
<p>其中，桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询的效率。</p>
<h1 id="hashmap的扩容机制">HashMap的扩容机制</h1>
<ul>
<li>HashMap的默认容量是16;</li>
<li>第二，容量扩容与负载因子和存储元素个数有关;</li>
<li>第三，设置初始值是为了减少扩容导致重建hash的性能影响。</li>
</ul>
<p>首先要了解HashMap的<strong>扩容过程</strong>，我们就得了解一些<strong>HashMap</strong>中的变量：</p>
<ul>
<li><code>Node&lt;K,V&gt;</code>：链表节点，包含了key、value、hash、next指针四个元素</li>
<li><code>table</code>：Node&lt;K,V&gt;类型的数组，里面的元素是链表，用于存放HashMap元素的实体</li>
<li><code>size</code>：记录了放入HashMap的元素个数</li>
<li><code>loadFactor</code>：负载因子</li>
<li><code>threshold</code>：扩容的阈值，决定了HashMap何时扩容，以及扩容后的大小，一般等于，等于
table * loadFactor</li>
</ul>
<p><strong>何时进行扩容？</strong></p>
<ul>
<li><p>HashMap使用的是懒加载，构造完HashMap对象后，只要不进行put
方法插入元素之前，HashMap并不会去初始化或者扩容table。</p></li>
<li><p>当首次调用put方法时，HashMap会发现table为空然后调用resize方法进行初始化，当添加完元素后，如果HashMap发现size（元素总数）大于threshold（阈值），则会调用<strong>resize方法</strong>进行扩容。</p></li>
</ul>
<p><strong>扩容过程：</strong></p>
<ul>
<li><p>若threshold（阈值）不为空，table的首次初始化大小为阈值，否则初始化为缺省值大小16</p></li>
<li><p>默认的负载因子大小为0.75，当一个map填满了75%的bucket时，就会扩容，扩容后的table大小变为原来的两倍</p>
<ul>
<li>扩容因子=0.75。当使用量接近数组容量的75%的时候，数组中还有25%的剩余空间。碰撞的概率越大，put的元素就越多，平均到每个桶中的元素的数量也越多。一旦发生碰撞，需要付出更大的代价。所以，如果扩容因子越大，碰撞的概率也就越大，发生碰撞后的代价也更大，结果导致效率大打折扣。因此扩容因子=0.75也是一个空间换时间的考虑，0.75这个数值应该是经过充分的考虑决定的。</li>
</ul></li>
<li><p>假设扩容前的table大小为2的N次方，有上述put方法解析可知，元素的table索引为其hash值的后N位确定</p></li>
<li><p>扩容后的table大小即为2的N+1次方，则其中元素的table索引为其hash值的后N+1位确定，比原来多了一位</p></li>
<li><p>重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing</p></li>
</ul>
<p>因此，table中的元素只有两种情况：</p>
<ul>
<li>元素hash值第N+1位为0：不需要进行位置调整</li>
<li>元素hash值第N+1位为1：调整至原索引的两倍位置</li>
</ul>
<p>扩容或初始化完成后，resize方法返回新的table</p>
<p><strong>扩容必须满足两个条件：</strong></p>
<ol type="1">
<li><p>存放新值的时候当前已有元素的个数必须大于等于阈值</p></li>
<li><p>存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）</p></li>
</ol>
<p><strong>下面我们看源码，如下：</strong></p>
<p>首先是<code>put()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">　　　　<span class="comment">//判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）</span></span><br><span class="line">　　　　<span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">　　　　　　inflateTable(threshold);<span class="comment">//如果为空，则初始化</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　</span><br><span class="line">　　　　<span class="comment">//判断key是否为空</span></span><br><span class="line">　　　　<span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">　　　　　　<span class="keyword">return</span> putForNullKey(value);<span class="comment">//hashmap允许key为空</span></span><br><span class="line">　　　　</span><br><span class="line">　　　　<span class="comment">//计算当前key的哈希值　　　　</span></span><br><span class="line">　　　　<span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">　　　　<span class="comment">//通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置</span></span><br><span class="line">　　　　<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">　　　　<span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">　　　　　　Object k;</span><br><span class="line">　　　　　　<span class="comment">//如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value</span></span><br><span class="line">　　　　　　<span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">　　　　　　　　<span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">　　　　　　　　e.value = value;</span><br><span class="line">　　　　　　　　e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">　　　　　　　　<span class="keyword">return</span> oldValue;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　modCount++;</span><br><span class="line">　　　　<span class="comment">//存放值的具体方法</span></span><br><span class="line">　　　　addEntry(hash, key, value, i);</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>put()</code>方法中有调用<code>addEntry()</code>方法，这个方法里面是具体的存值，在存值之前还有判断是否需要扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">　　　　<span class="comment">//1、判断当前个数是否大于等于阈值</span></span><br><span class="line">　　　　<span class="comment">//2、当前存放是否发生哈希碰撞</span></span><br><span class="line">　　　　<span class="comment">//如果上面两个条件否发生，那么就扩容</span></span><br><span class="line">　　　　<span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">　　　　　　<span class="comment">//扩容，并且把原来数组中的元素重新放到新数组中</span></span><br><span class="line">　　　　　　resize(<span class="number">2</span> * table.length);</span><br><span class="line">　　　　　　hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">　　　　　　bucketIndex = indexFor(hash, table.length);</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　createEntry(hash, key, value, bucketIndex);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要扩容，调用扩容的方法<code>resize()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">　　　　Entry[] oldTable = table;</span><br><span class="line">　　　　<span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">　　　　<span class="comment">//判断是否有超出扩容的最大值，如果达到最大值则不进行扩容操作</span></span><br><span class="line">　　　　<span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">　　　　　　threshold = Integer.MAX_VALUE;</span><br><span class="line">　　　　　　<span class="keyword">return</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">　　　　<span class="comment">// transfer()方法把原数组中的值放到新数组中</span></span><br><span class="line">　　　　transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">　　　　<span class="comment">//设置hashmap扩容后为新的数组引用</span></span><br><span class="line">　　　　table = newTable;</span><br><span class="line">　　　　<span class="comment">//设置hashmap扩容新的阈值</span></span><br><span class="line">　　　　threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p><code>transfer()</code>在实际扩容时候把原来数组中的元素放入新的数组中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">　　　　<span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">　　　　<span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">　　　　　　<span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">　　　　　　　　Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">　　　　　　　　<span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">　　　　　　　　　　e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">　　　　　　　　&#125;</span><br><span class="line">　　　　　　　　<span class="comment">//通过key值的hash值和新数组的大小算出在当前数组中的存放位置</span></span><br><span class="line">　　　　　　　　<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">　　　　　　　　e.next = newTable[i];</span><br><span class="line">　　　　　　　　newTable[i] = e;</span><br><span class="line">　　　　　　　　e = next;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p><strong>Hashmap的扩容</strong>需要满足两个条件：<strong>当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。</strong></p>
<p>因为上面这两个条件，所以存在下面这些情况：</p>
<ol type="1">
<li><p>就是hashmap在存值的时候（默认大小为16，负载因子0.75，阈值12），可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。</p></li>
<li><p>当然也有可能存储更多值（超多16个值，最多可以存26个值）都还没有扩容。原理：前11个值全部hash碰撞，存到数组的同一个位置（这时元素个数小于阈值12，不会扩容），后面所有存入的15个值全部分散到数组剩下的15个位置（这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，所以不会扩容），前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。</p></li>
</ol>
<h1
id="hashmap为什么当链表长度为8时才自动转化成红黑树为什么红黑树大小为6时需要还原成链表">HashMap为什么当链表长度为8时，才自动转化成红黑树？为什么红黑树大小为6时需要还原成链表？</h1>
<p>首先，如HashMap源码所说，当加载因子为
0.75时，hash冲突元素个数达到8的概率为一亿分之6，概率是很小的，所以设置长度为8时才转化，基本上可以保证正常情况链表转化成红黑树的概率极低。</p>
<p>另外红黑树的平均查找复杂度为 o(lgn), 链表的平均查找复杂度
n/2，所以可以来比较下：</p>
<p>当n=4时，log2(4)=2, 4/2=2</p>
<p>当n=6时，log2(6)&lt;3, 6/2=3</p>
<p>当n=8时, log2(8)=3, 8/2=4</p>
<p>当n=10时, log2(10)&lt;4, 10/2=5</p>
<p>可以发现,当n=8时，采用红黑树查询数据的平均效率是高于链表的，而当n&lt;8时，红黑树和链表的查询效率差不多，但是转化红黑树会消耗一定时间，所以没有必要。</p>
<p><strong>所以当链表的长度达到8时会转化成红黑树，一个是超过8的概率很小，二是超过8之后红黑树的查询效率要高于链表。</strong></p>
<p>至于为什么当红黑树数据个数小于6时会还原成链表，首先如上所述，当个数小于等于6时，实际上红黑树和链表的查询复杂度基本上差不多，个数越少链表更有优势，因为红黑树还有转化的消耗。</p>
<p>在6和8之间还有一个中间值7是为了提供容错性，因为如果大于8就转成红黑树，小于8就还原成链表，如果不停的插入和删除元素，链表大小一直在8左右徘徊，就会频繁的进行链表和树的转化，会消耗一定的性能。</p>
<p>所以当红黑树大小小于等于6时还原成链表，一个是小于6时链表效率更高，二是避免链表和红黑树的频繁互相转换。</p>
<h1 id="简述什么是红黑树">简述什么是红黑树</h1>
<p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NIL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li>
</ul>
<h1 id="hashmap是线程安全的吗">HashMap是线程安全的吗</h1>
<p>一直以来都知道<code>HashMap</code>是<strong>线程不安全</strong>的，但是到底为什么线程不安全，在多线程操作情况下什么时候线程不安全？</p>
<p>让我们先来了解一下HashMap的底层存储结构，HashMap底层是一个Entry数组，一旦发生Hash冲突的的时候，HashMap采用拉链法解决碰撞冲突，Entry内部的变量：</p>
<ol type="1">
<li>final Object key;</li>
<li>Object value;</li>
<li>Entry next;</li>
<li>int hash;</li>
</ol>
<p>通过Entry内部的next变量可以知道使用的是链表，这时候我们可以知道，<strong>如果多个线程，在某一时刻同时操作HashMap并执行put操作，而有两个以上key的hash值相同，如图中a1、a2，这个时候需要解决碰撞冲突，这个时候两个线程如果恰好都取到了对应位置的头结点e1，而最终的结果可想而知，a1、a2两个数据中势必会有一个会丢失，</strong>如图所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7YVYfx"><img
src="https://s4.ax1x.com/2022/01/15/7YVYfx.md.png"
alt="7YVYfx.md.png" /></a></p>
<p><code>put</code>方法不是同步的，同时调用了<code>addEntry</code>方法。</p>
<p><code>addEntry</code>方法依然不是同步的，所以导致了线程不安全出现上述问题，其他类似操作不再说明，源码一看便知，下面主要说一下另一个非常重要的知识点，同样也是HashMap非线程安全的原因，我们知道在HashMap存在扩容的情况，对应的方法为HashMap中的<code>resize</code>方法。</p>
<p>可以看到扩容方法也不是同步的，通过代码我们知道在扩容过程中，会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。</p>
<p>当多个线程同时检测到总数量超过阈值的时候就会同时调用<strong>resize操作</strong>，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p>
<h1 id="数组与链表的区别">数组与链表的区别</h1>
<p><strong>数组</strong>：查询效率高，新增和修改需要移动元素效率低，内存分配是<strong>连续的内存</strong>，扩容需要重新分配内存。</p>
<p><strong>链表</strong>：新增和修改效率高，只需要修改指针指向就好。链表查询效率低，需要从链表头依次查找。内存分配<strong>不需要连续的内存</strong>，占用连续内存少。</p>
<h1 id="arraylist和linkedlist的区别">ArrayList和LinkedList的区别</h1>
<h2 id="list概括">List概括</h2>
<p>先来回顾一下<strong>List</strong>在<code>Collection</code>中的的框架图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TCPWef"><img
src="https://s4.ax1x.com/2021/12/16/TCPWef.md.png"
alt="TCPWef.md.png" /></a></p>
<p>从图中我们可以看出：</p>
<ol type="1">
<li><p><strong>List</strong>是一个接口，它继承于<code>Collection接口</code>，代表有序的队列。</p></li>
<li><p><strong>AbstractList</strong>是一个抽象类，它继承于AbstractCollection。AbstractList实现了List接口中除了size()、get(int
location)之外的方法。</p></li>
<li><p><strong>AbstractSequentialList</strong>是一个抽象类，它继承与AbstrctList。AbstractSequentialList实现了“链表中，根据index索引值操作链表的全部方法”。</p></li>
<li><p><strong>ArrayList、LinkedList、Vector和Stack</strong>是List的四个实现类，其中Vector是基于JDK1.0，虽然实现了同步，但是效率低，已经不用了，Stack继承与Vector，所以不再赘述。</p></li>
<li><p><strong>LinkedList</strong>是个双向链表，它同样可以被当作栈、队列或双端队列来使用。</p></li>
</ol>
<h2 id="arraylist和linkedlist区别">ArrayList和LinkedList区别</h2>
<ol type="1">
<li><p>LinkedList和ArrayList的差别主要来自于<strong>Array和LinkedList数据结构的不同</strong>
。<code>ArrayList</code>是基于<strong>数组</strong>实现的，<code>LinkedList</code>是基于<strong>双链表</strong>实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向队列
，栈（可以参见Deque提供的接口方法）和List集合使用，功能强大。</p></li>
<li><p>因为<strong>Array是基于索引(index)的数据结构</strong>，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。</p></li>
<li><p>相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。</p></li>
<li><p>LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</p></li>
</ol>
<blockquote>
<p>使用场景：</p>
</blockquote>
<ol type="1">
<li><p>如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；</p></li>
<li><p>如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList对象要优于ArrayList对象；</p></li>
<li><p>不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。</p></li>
</ol>
<p><strong>ArrayList中的随机访问、添加和删除部分源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取index位置的元素值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//首先判断index的范围是否合法</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将index位置的值设为element，并返回原来的值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"> </span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将element添加到ArrayList的指定位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"> </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//将index以及index之后的数据复制到index+1的位置往后，即从index开始向后挪了一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index); </span><br><span class="line">    elementData[index] = element; <span class="comment">//然后在index处插入element</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除ArrayList指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"> </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//向左挪一位，index位置原来的数据已经被覆盖了</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//多出来的最后一位删掉</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedList中的随机访问、添加和删除部分源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得第index个节点的值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	checkElementIndex(index);</span><br><span class="line">	<span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//设置第index元素的值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">	checkElementIndex(index);</span><br><span class="line">	Node&lt;E&gt; x = node(index);</span><br><span class="line">	<span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">	x.item = element;</span><br><span class="line">	<span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在index个节点之前添加新的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">	checkPositionIndex(index);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (index == size)</span><br><span class="line">		linkLast(element);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除第index个节点</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	checkElementIndex(index);</span><br><span class="line">	<span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定位index处的节点</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">	<span class="comment">//index&lt;size/2时，从头开始找</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">		Node&lt;E&gt; x = first;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">			x = x.next;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//index&gt;=size/2时，从尾开始找</span></span><br><span class="line">		Node&lt;E&gt; x = last;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">			x = x.prev;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1
id="hashmap与concurrenthashmap的区别">HashMap与ConcurrentHashMap的区别</h1>
<ul>
<li><p>HashMap是线程不安全的，当出现多线程操作时，会出现安全隐患；而ConcurrentHashMap是线程安全的。</p></li>
<li><p>HashMap不支持并发操作，没有同步方法，ConcurrentHashMap支持并发操作，通过继承
ReentrantLock（JDK1.7重入锁）/CAS和synchronized(JDK1.8内置锁)来进行加锁（分段锁），每次需要加锁的操作锁住的是一个
segment，这样只要保证每个 Segment
是线程安全的，也就实现了全局的线程安全。</p></li>
</ul>
<h1 id="hashmap和hashtable的区别">HashMap和Hashtable的区别</h1>
<ul>
<li><p><strong>HashMap</strong>不是线程安全的，<strong>HashTable</strong>是线程安全的。</p></li>
<li><p>HashMap是map接口的子类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。<strong>HashMap</strong>允许<code>null key</code>和<code>null value</code>，而<strong>Hashtable</strong>不允许。</p></li>
<li><p><strong>HashMap是Hashtable的轻量级实现（非线程安全的实现）</strong>，他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。</p></li>
<li><p><strong>HashMap</strong>把Hashtable的<code>contains方法</code>去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map
interface的一个实现。
最大的不同是，<strong>Hashtable的方法是Synchronize的，而HashMap不是</strong>，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap
就必须为之提供外同步。
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差别。</p></li>
</ul>
<h1 id="arraylist的扩容过程">Arraylist的扩容过程</h1>
<p>​
<strong>ArrayList扩容</strong>的核心从<code>ensureCapacityInternal</code>方法说起。可以看到前面介绍成员变量的提到的ArrayList有两个默认的空数组：</p>
<p><strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong>：是用来使用默认构造方法时候返回的空数组。如果第一次添加数据的话那么数组扩容长度为<code>DEFAULT_CAPACITY=10</code>。</p>
<p><strong>EMPTY_ELEMENTDATA</strong>：出现在需要用到空数组的地方，其中一处就是使用自定义初始容量构造方法时候如果你指定初始容量为0的时候就会返回。</p>
<p>从下面可以看到如果是使用了<code>空数组EMPTY_ELEMENTDATA</code>，那么不会返回默认的初始容量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前数组是否是默认构造方法生成的空数组，如果是的话minCapacity=10反之则根据原来的值传入下一个方法去完成下一步的扩容判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//minCapacitt表示修改后的数组容量，minCapacity = size + 1 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//判断看看是否需要扩容</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面谈谈<code>ensureExplicitCapacity</code>方法（modCount设计到Java的快速报错机制后面会谈到），可以看到如果修改后的数组容量大于当前的数组长度那么就需要调用grow进行扩容，反之则不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//判断当前ArrayList是否需要进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//快速报错机制</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后看下ArrayList扩容的核心方法<strong>grow()</strong>，下面将针对三种情况对该方法进行解析：</p>
<ol type="1">
<li>当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。而后的数组扩容才是按照当前容量的1.5倍进行扩容;</li>
<li>当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都
+1，在第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。</li>
<li>当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//ArrayList扩容的核心方法，此方法用来决定扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">     <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">     newCapacity = minCapacity;</span><br><span class="line">     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    	 newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">     <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<h1 id="hashmap1.8比1.7版本对比">HashMap1.8比1.7版本对比</h1>
<p>HashMap是我们开发中经常使用到的集合，jdk1.8相对于1.7底层实现发生了一些改变。<strong>1.8主要优化减少了Hash冲突
，提高哈希表的存、取效率。</strong></p>
<ol type="1">
<li>底层数据结构不一样，1.7是<strong>数组+链表</strong>，1.8则是<strong>数组+链表+红黑树结构</strong>（当链表长度大于8，转为红黑树）。</li>
<li>JDK1.8中<strong>resize()方法</strong>在表为空时，创建表；在表不为空时，扩容；而JDK1.7中resize()方法负责扩容，inflateTable()负责创建表。</li>
<li>1.8中没有区分键为null的情况，而1.7版本中对于键为null的情况调用putForNullKey()方法。但是两个版本中如果键为null，那么调用hash()方法得到的都将是0，所以键为null的元素都始终位于哈希表table【0】中。</li>
<li>当1.8中的桶中元素处于链表的情况，遍历的同时最后如果没有匹配的，直接将节点添加到链表尾部；而1.7在遍历的同时没有添加数据，而是另外调用了addEntry()方法，将节点添加到链表头部。</li>
<li>1.7中新增节点采用<strong>头插法</strong>，1.8中新增节点采用<strong>尾插法</strong>。这也是为什么1.8不容易出现环型链表的原因。</li>
<li>1.7中是通过更改hashSeed值修改节点的hash值从而达到rehash时的链表分散，而1.8中键的hash值不会改变，rehash时根据（hash&amp;oldCap）==0将链表分散。</li>
<li>1.8 <strong>rehash时保证原链表的顺序</strong>，而1.7
rehash时有可能改变链表的顺序（头插法导致）。</li>
<li>1.7在插入数据<strong>之前扩容</strong>，而1.8插入数据成功<strong>之后扩容</strong>。</li>
</ol>
<h1 id="hash冲突的解决办法">Hash冲突的解决办法</h1>
<h2 id="开放定址法">开放定址法</h2>
<p>这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi
，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p>
<p>Hi=（H（key）+di）% m i=1，2，…，n</p>
<p>其中H（key）为哈希函数，m
为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：</p>
<h3 id="线性探测再散列">线性探测再散列</h3>
<p>dii=1，2，3，…，m-1</p>
<p>这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
<h3 id="二次探测再散列">二次探测再散列</h3>
<p>di=12，-12，22，-22，…，k2，-k2 ( k&lt;=m/2 )</p>
<p>这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
<h3 id="伪随机探测再散列">伪随机探测再散列</h3>
<p>di=伪随机数序列。</p>
<p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p) %
m），并给定一个随机数做起点。</p>
<p>例如，已知哈希表长度m=11，哈希函数为：H（key）= key %
11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。</p>
<p>如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 =
4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 =
5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 =
6，此时不再冲突，将69填入5号单元。</p>
<p>如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 =
4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 =
2，此时不再冲突，将69填入2号单元。</p>
<p>如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3
+ 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 =
8，此时不再冲突，将69填入8号单元。</p>
<h2 id="再哈希法">再哈希法</h2>
<p>这种方法是同时构造多个不同的哈希函数：</p>
<p>Hi=RH1（key） i=1，2，…，k</p>
<p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
<h2 id="链地址法">链地址法</h2>
<p>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<h2 id="建立公共溢出区">建立公共溢出区</h2>
<p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<h2 id="链表法chaining">链表法（chaining）</h2>
<p>在哈希表中，每一个桶（bucket）或者槽（slot）都会对应一条链表，所有哈希值相同的元素放到相同槽位对应的链表中。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7XwNcR"><img
src="https://s4.ax1x.com/2022/01/27/7XwNcR.md.jpg"
alt="7XwNcR.md.jpg" /></a></p>
<p>在插入的时候，我们可以通过散列函数计算出对应的散列槽位，将元素插入到对应的链表即可，时间复杂度为O（1）；在查找或删除元素时，我们同样通过散列函数计算出对应的散列槽位，然后再通过遍历链表进行查找或删除，时间复杂度为O（k），k为链表长度。</p>
<h2 id="开放寻址法">开放寻址法</h2>
<p>核心思想：如果出现散列冲突，我们就重新探测一个空闲位置，再将元素插入。</p>
<p>一种比较简单的探测方法：<strong>线性探测法（Linear
Probing）</strong></p>
<p>但我们往散列表中插入元素时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，那么我们就从当前位置开始，依次往后遍历，直到找到空余的位置插入为止（插入第一个空余的位置，方便查找），举例如图：</p>
<p>黄色的色块表示空余色块，橙色的色块表示已经存储了数据</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7XwrND"><img
src="https://s4.ax1x.com/2022/01/27/7XwrND.md.jpg"
alt="7XwrND.md.jpg" /></a></p>
<p>在查找元素时，先将要查找元素键值通过散列函数变成散列值，然后与下标为散列值的元素比较，若相等，则说明这是我们要找的元素；若不相等，则顺序往后遍历查找，如果遍历到数组中的空余位置还是没有找到，说明要查找的元素不在散列表中。</p>
<p>删除元素时，删除操作不能简单地把元素设置为空，而是要特殊标记为deleted，因为如果简单设置为空，在查找元素的过程中遇到这个被删除元素的位置就会停下，而不是继续往后遍历，会使查找算法失效；但是如果特色标记为deleted，当线性探测查找时，遇到标记为deleted的位置就会往下探测。</p>
<p>线性探测法的缺点：当插入的数据越来越多时，散列冲突发生的可能性会越来越大，空余位置会越来越少，线性探测的时间会越来越长，最坏时间复杂度为O（n）。</p>
<p>另外的两种探测方法是<strong>二次探测法</strong>（Quadratic
probing）和<strong>双重散列法</strong>（Double hashing）。</p>
<h1
id="list和set底层继承或实现什么接口">List和Set底层继承或实现什么接口</h1>
<p><strong>List和Set接口</strong>自<strong>Collection</strong>接口，而Map不是继承的Collection接口。</p>
<p>Collection表示一组对象,这些对象也称为collection的元素;一些
collection允许有重复的元素,而另一些则不允许;一些collection是有序的,而另一些则是无序的;JDK中不提供此接口的任何直接实现,它提供更具体的子接口(如
Set 和
List)实现;Map没有继承Collection接口,Map提供key到value的映射;一个Map中不能包含相同key,每个key只能映射一个value;Map接口提供3种集合的视图,Map的内容可以被当做一组key集合,一组value集合,或者一组key-value映射;</p>
<h2 id="list接口">List接口</h2>
<p><strong>元素有放入顺序，元素可重复</strong></p>
<blockquote>
<p>List接口有三个实现类：<strong>LinkedList，ArrayList，Vector</strong></p>
</blockquote>
<ul>
<li><strong>LinkedList</strong>：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢</li>
</ul>
<p><strong>ArrayList和Vector的区别</strong>：ArrayList是非线程安全的，效率高；Vector是基于线程安全的，效率低。</p>
<h2 id="set接口">Set接口</h2>
<p><strong>元素无放入顺序，元素不可重复</strong>（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）</p>
<blockquote>
<p>Set接口有两个实现类：<strong>HashSet</strong>(底层由HashMap实现)，<strong>LinkedHashSet</strong></p>
</blockquote>
<p>Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。<strong>实际上Set就是Collection,只是行为不同。</strong>(这是继承与多态思想的典型应用：表现不同的行为。)</p>
<p>Set不保存重复的元素(至于如何判断元素相同则较为复杂)</p>
<p><strong>Set</strong> :
存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。</p>
<h2 id="map接口">Map接口</h2>
<p>以键值对的方式出现的</p>
<blockquote>
<p>Map接口有三个实现类：<strong>HashMap，HashTable，LinkeHashMap</strong></p>
</blockquote>
<h1 id="hashmap和treemap的比较">hashmap和treeMap的比较</h1>
<ol type="1">
<li><strong>HashMap</strong>通过hashcode对其内容进行快速查找，而
<strong>TreeMap</strong>中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</li>
<li>HashMap 非线程安全 TreeMap 非线程安全</li>
<li><strong>HashMap</strong>：基于<strong>哈希表</strong>实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。<strong>TreeMap</strong>：基于<strong>红黑树</strong>实现。TreeMap没有调优选项，因为该树总处于平衡状态。</li>
<li><strong>HashMap</strong>适用于在Map中插入、删除和定位元素。<strong>Treemap</strong>适用于按自然顺序或自定义顺序遍历键(key)。</li>
<li><strong>HashMap</strong>通常比<strong>TreeMap</strong>快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。</li>
</ol>
<h1 id="arraylist底层实现原理">ArrayList底层实现原理</h1>
<ul>
<li>ArrayList是基于<strong>数组</strong>实现的，是一个<strong>动态数组</strong>，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。</li>
<li><strong>ArrayList不是线程安全的</strong>，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List
l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</li>
<li>ArrayList实现了<strong>Serializable接口</strong>，因此它<strong>支持序列化</strong>，能够通过序列化传输，实现了<strong>RandomAccess接口</strong>，支持<strong>快速随机访问</strong>，实际上就是通过下标序号进行快速访问，实现了<strong>Cloneable接口</strong>，能被克隆。</li>
</ul>
<h1 id="arraylist如何线程安全">ArrayList如何线程安全</h1>
<h2 id="线程不安全的两种体现">线程不安全的两种体现</h2>
<ul>
<li><strong>数组越界异常
<code>ArrayIndexOutOfBoundsException</code></strong></li>
</ul>
<p>由于ArrayList添加元素是如上面分两步进行，可以看出第一个不安全的隐患，在多个线程进行add操作时可能会导致elementData数组越界。</p>
<p>具体逻辑如下：</p>
<ol type="1">
<li>列表大小为9，即size=9</li>
<li>线程A开始进入add方法，这时它获取到size的值为9，调用ensureCapacityInternal方法进行容量判断。</li>
<li>线程B此时也进入add方法，它获取到size的值也为9，也开始调用ensureCapacityInternal方法。</li>
<li>线程A发现需求大小为10，而elementData的大小就为10，可以容纳。于是它不再扩容，返回。</li>
<li>线程B也发现需求大小为10，也可以容纳，返回。</li>
<li>线程A开始进行设置值操作， elementData[size++] = e
操作。此时size变为10。</li>
<li>线程B也开始进行设置值操作，它尝试设置elementData[10] =
e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException.</li>
</ol>
<ul>
<li><strong>元素值覆盖和为空问题</strong></li>
</ul>
<p>elementData[size++] = e
设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elementData[size] = e;</span><br><span class="line">size = size + 1;</span><br></pre></td></tr></table></figure>
<p>在单线程执行这两条代码时没有任何问题，但是当多线程环境下执行时，可能就会发生一个线程的值覆盖另一个线程添加的值，具体逻辑如下：</p>
<ol type="1">
<li>列表大小为0，即size=0</li>
<li>线程A开始添加一个元素，值为A。此时它执行第一条操作，将A放在了elementData下标为0的位置上。</li>
<li>接着线程B刚好也要开始添加一个值为B的元素，且走到了第一步操作。此时线程B获取到size的值依然为0，于是它将B也放在了elementData下标为0的位置上。</li>
<li>线程A开始将size的值增加为1</li>
<li>线程B开始将size的值增加为2</li>
</ol>
<p>这样线程AB执行完毕后，理想中情况为size为2，elementData下标0的位置为A，下标1的位置为B。而实际情况变成了size为2，elementData下标为0的位置变成了B，下标1的位置上什么都没有。并且后续除非使用set方法修改此位置的值，否则将一直为null，因为size为2，添加元素时会从下标为2的位置上开始。</p>
<p><strong>代码示例</strong></p>
<p>如下，通过两个线程对ArrayList添加元素，复现上面的两种不安全情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ArrayListSafeTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        // 线程A将1-1000添加到列表</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 1; i &lt; 1000; i++) &#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        // 线程B将1001-2000添加到列表</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 1001; i &lt; 2000; i++) &#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1); </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        // 打印所有结果</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + (i + 1) + &quot;个元素为：&quot; + list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行过程中，两种情况出现如下：</p>
<figure>
<img
src="https://img2018.cnblogs.com/blog/1001990/201901/1001990-20190107005714604-10907725.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://img2018.cnblogs.com/blog/1001990/201901/1001990-20190107005501263-325741227.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="arraylist线程安全处理">ArrayList线程安全处理</h2>
<ul>
<li><strong>Collections.synchronizedList</strong></li>
</ul>
<p>最常用的方法是<strong>通过 Collections 的 synchronizedList
方法</strong>将 ArrayList 转换成线程安全的容器后再使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list =Collections.synchronizedList(new ArrayList&lt;Object&gt;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>为list.add()方法加锁</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(list.get()) &#123;</span><br><span class="line">list.get().add(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>CopyOnWriteArrayList</strong></li>
</ul>
<p>使用线程安全的 CopyOnWriteArrayList 代替线程不安全的 ArrayList。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = new CopyOnWriteArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用ThreadLocal</strong></li>
</ul>
<p>使用ThreadLocal变量确保线程封闭性(封闭线程往往是比较安全的，
但由于使用ThreadLocal封装变量，相当于把变量丢进执行线程中去，每new一个新的线程，变量也会new一次，一定程度上会造成性能[内存]损耗，但其执行完毕就销毁的机制使得ThreadLocal变成比较优化的并发解决方案)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;List&lt;Object&gt;&gt; threadList = new ThreadLocal&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">         protected List&lt;Object&gt; initialValue() &#123;</span><br><span class="line">              return new ArrayList&lt;Object&gt;();</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="arraylist的扩容机制">ArrayList的扩容机制</h1>
<h2 id="初始容量">初始容量</h2>
<p><strong>ArrayList</strong>有多个不同的构造函数，不同的构造函数的初始容量是不同的。快速看一下<code>ArrayList</code>源码里关于元素存放的几个私有属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认容量是10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 如果容量为0的时候，就返回这个数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 使用默认容量10时，返回这个数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 元素存放的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// 元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录被修改的次数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 数组的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><code>ArrayList</code>有三个构造方法，不同的构造方法的容量是不一样的，具体可以查看JDK
源码。</p>
<ul>
<li>如果不传入初始容量，就使用默认容量，并设置<code>elementData</code>为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code></li>
<li>如果传入初始容量，会判断这个传入的值，如果大于0，就new一个新的Object数组，如果等于0，就直接设置<code>elementData</code>为<code>EMPTY_ELEMENTDATA</code>。</li>
<li>如果传入一个Collection，则会调用<code>toArray()</code>方法把它变成一个数组并赋值给<code>elementData</code>。同样会判断它的长度是否为0，如果为0，设置<code>elementData</code>为<code>EMPTY_ELEMENTDATA</code>。</li>
</ul>
<h2 id="扩容具体指的是什么">扩容具体指的是什么？</h2>
<p>可以看到，<code>ArrayList</code>里面有两个概念，一个是<code>capacity</code>，它表示的就是“容量”，其实质是数组<code>elementData</code>的长度。而<code>size</code>则表示的“存放的元素的个数”。</p>
<p>因为Java中，数组操作不能越界，所以我们必须要保证在插入操作的时候，不会抛出数组越界异常。</p>
<h2 id="arraylist是如何实现扩容的">ArrayList是如何实现扩容的？</h2>
<p>底层主要是这三个私有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容一个</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">	<span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证扩容到期望容量minCapacity及以上</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据期望容量minCapacity计算实际需要扩容的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">// 得到旧容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 设置新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123; <span class="comment">// 如果新容量仍然小于期望容量</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) <span class="comment">// 如果是使用的默认容量</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity); <span class="comment">// 取默认容量和期望容量较大值返回</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow // 检查期望容量是否越界（int 的范围）</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> minCapacity; <span class="comment">// 返回期望容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新容量大于期望容量，判断一下新容量是否越界</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，底层其实是调用了<code>Arrays.copyOf</code>方法来进行扩充数组容量的。这里我们主要看一下最后一个方法<strong>newCapacity(int
minCapacity)</strong>的实现。</p>
<p><strong>默认情况下，新的容量会是原容量的1.5倍，这里用了位运算提高效率</strong>。一般情况下，如果扩容1.5倍后就大于期望容量，那就返回这个1.5倍旧容量的值。而如果小于期望容量，那就返回期望容量。这里对默认容量10做了特殊处理。</p>
<p><strong>使用1.5倍这个数值而不是直接使用期望容量，是为了防止频繁扩容影响性能</strong>。试想如果每次add操作都要扩容一次，那性能将会非常低下。</p>
<p>上述grow方法其实主要是用于实现自动扩容的。而用户也可以通过调用以下方法实现手动扩容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么需要手动扩容？试想一下，如果用户已经知道即将存入大量的元素，比如目前有20个元素，即将存入2000个。那这个时候使用自动扩容就会扩容多次。而手动扩容可以一次性扩容到2000，可以提高性能。</p>
<h1 id="hashmap的put方法">hashmap的put方法</h1>
<p>put函数大致的思路为：</p>
<ul>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>如果<strong>节点</strong>已经存在就替换old
value(保证key的唯一性)；</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ul>
<h1 id="linkedhashmap和hashmap比较">linkedHashmap和hashmap比较</h1>
<ul>
<li><p><strong>LinkedHashMap</strong>是继承于HashMap，是基于HashMap和<strong>双向链表</strong>来实现的。</p></li>
<li><p><strong>HashMap无序；LinkedHashMap有序</strong>，可分为插入顺序和访问顺序两种。如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。</p></li>
<li><p><strong>LinkedHashMap</strong>在<strong>遍历</strong>的时候会比HashMap慢，不过有种情况例外：当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢。因为LinkedHashMap的遍历速度只和<strong>实际数据</strong>有关，和容量无关，而HashMap的遍历速度和它的<strong>容量</strong>有关。</p></li>
</ul>
<h1 id="set的底层结构">Set的底层结构</h1>
<blockquote>
<p><strong>STL中set底层实现方式：</strong></p>
</blockquote>
<p>set底层实现方式为RB树（即红黑树）。</p>
<blockquote>
<p><strong>为什么不用hash？</strong></p>
</blockquote>
<p>首先set，不像map那样是key-value对，它的key与value是相同的。关于set有两种说法，第一个是STL中的set，用的是红黑树；第二个是hash_set，底层用得是hash
table。红黑树与hash table最大的不同是，红黑树是有序结构，而hash
table不是。但不是说set就不能用hash，如果只是判断set中的元素是否存在，那么hash显然更合适，因为set
的访问操作时间复杂度是log(N)的，而使用hash底层实现的hash_set是近似O(1)的。然而，set应该更加被强调理解为“集合”，而集合所涉及的操作并、交、差等，即STL提供的如交集set_intersection()、并集set_union()、差集set_difference()和对称差集set_symmetric_difference()，都需要进行大量的比较工作，那么使用底层是有序结构的红黑树就十分恰当了，这也是其相对hash结构的优势所在。</p>
<h1 id="java集合类线程安全不安全">Java集合类（线程安全/不安全）</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">线程安全</th>
<th style="text-align: center;">线程不安全</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Collection</td>
<td style="text-align: center;">Vector</td>
<td style="text-align: center;">ArrayList、LinkedList</td>
</tr>
<tr class="even">
<td style="text-align: center;">Collection</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">HashSet、TreeSet</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Map</td>
<td style="text-align: center;">HashTable</td>
<td style="text-align: center;">HashMap、TreeMap</td>
</tr>
<tr class="even">
<td style="text-align: center;">字符串</td>
<td style="text-align: center;">StringBuffer</td>
<td style="text-align: center;">StringBuilder</td>
</tr>
</tbody>
</table>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8Fjava%E5%9F%BA%E7%A1%80/" rel="prev" title="Java基础">
      <i class="fa fa-chevron-left"></i> Java基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E9%9D%A2%E7%BB%8FJVM/" rel="next" title="JVM">
      JVM <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">HashMap的底层原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">HashMap的扩容机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BD%93%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E4%B8%BA8%E6%97%B6%E6%89%8D%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8C%96%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%A2%E9%BB%91%E6%A0%91%E5%A4%A7%E5%B0%8F%E4%B8%BA6%E6%97%B6%E9%9C%80%E8%A6%81%E8%BF%98%E5%8E%9F%E6%88%90%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">HashMap为什么当链表长度为8时，才自动转化成红黑树？为什么红黑树大小为6时需要还原成链表？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">简述什么是红黑树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">5.</span> <span class="nav-text">HashMap是线程安全的吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">数组与链表的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#arraylist%E5%92%8Clinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">ArrayList和LinkedList的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#list%E6%A6%82%E6%8B%AC"><span class="nav-number">7.1.</span> <span class="nav-text">List概括</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arraylist%E5%92%8Clinkedlist%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.</span> <span class="nav-text">ArrayList和LinkedList区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap%E4%B8%8Econcurrenthashmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">HashMap与ConcurrentHashMap的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap%E5%92%8Chashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">HashMap和Hashtable的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#arraylist%E7%9A%84%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text">Arraylist的扩容过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap1.8%E6%AF%941.7%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94"><span class="nav-number">11.</span> <span class="nav-text">HashMap1.8比1.7版本对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hash%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">Hash冲突的解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="nav-number">12.1.</span> <span class="nav-text">开放定址法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E5%86%8D%E6%95%A3%E5%88%97"><span class="nav-number">12.1.1.</span> <span class="nav-text">线性探测再散列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%E5%86%8D%E6%95%A3%E5%88%97"><span class="nav-number">12.1.2.</span> <span class="nav-text">二次探测再散列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%8E%A2%E6%B5%8B%E5%86%8D%E6%95%A3%E5%88%97"><span class="nav-number">12.1.3.</span> <span class="nav-text">伪随机探测再散列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-number">12.2.</span> <span class="nav-text">再哈希法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-number">12.3.</span> <span class="nav-text">链地址法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA"><span class="nav-number">12.4.</span> <span class="nav-text">建立公共溢出区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E6%B3%95chaining"><span class="nav-number">12.5.</span> <span class="nav-text">链表法（chaining）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="nav-number">12.6.</span> <span class="nav-text">开放寻址法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list%E5%92%8Cset%E5%BA%95%E5%B1%82%E7%BB%A7%E6%89%BF%E6%88%96%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.</span> <span class="nav-text">List和Set底层继承或实现什么接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#list%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.1.</span> <span class="nav-text">List接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.2.</span> <span class="nav-text">Set接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.3.</span> <span class="nav-text">Map接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap%E5%92%8Ctreemap%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">14.</span> <span class="nav-text">hashmap和treeMap的比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#arraylist%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">15.</span> <span class="nav-text">ArrayList底层实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#arraylist%E5%A6%82%E4%BD%95%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">16.</span> <span class="nav-text">ArrayList如何线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%93%E7%8E%B0"><span class="nav-number">16.1.</span> <span class="nav-text">线程不安全的两种体现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arraylist%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86"><span class="nav-number">16.2.</span> <span class="nav-text">ArrayList线程安全处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#arraylist%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">17.</span> <span class="nav-text">ArrayList的扩容机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F"><span class="nav-number">17.1.</span> <span class="nav-text">初始容量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E5%85%B7%E4%BD%93%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">17.2.</span> <span class="nav-text">扩容具体指的是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arraylist%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="nav-number">17.3.</span> <span class="nav-text">ArrayList是如何实现扩容的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashmap%E7%9A%84put%E6%96%B9%E6%B3%95"><span class="nav-number">18.</span> <span class="nav-text">hashmap的put方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linkedhashmap%E5%92%8Chashmap%E6%AF%94%E8%BE%83"><span class="nav-number">19.</span> <span class="nav-text">linkedHashmap和hashmap比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">20.</span> <span class="nav-text">Set的底层结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">21.</span> <span class="nav-text">Java集合类（线程安全&#x2F;不安全）</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

