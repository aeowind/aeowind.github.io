<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Battles and wastelands, battles and wastelands in me">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础（一）">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="Battles and wastelands, battles and wastelands in me">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/23/gX81k6.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/23/gX81k6.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/24/gvP6Og.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/24/gvP4f0.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/24/gvkCod.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/24/gv1wr9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/25/gzHMa8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/26/2pgYb4.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/26/2C9O54.png">
<meta property="article:published_time" content="2022-03-04T12:46:25.409Z">
<meta property="article:modified_time" content="2021-11-12T08:28:01.740Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/05/23/gX81k6.png">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础（一） | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-12 16:28:01" itemprop="dateModified" datetime="2021-11-12T16:28:01+08:00">2021-11-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          
            <div class="post-description"><blockquote class="blockquote-center">Battles and wastelands, battles and wastelands in me</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h1><h2 id="语言概述"><a href="#语言概述" class="headerlink" title="语言概述"></a>语言概述</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/gX81k6"><img src="https://z3.ax1x.com/2021/05/23/gX81k6.png" alt="gX81k6.png"></a></p>
<h3 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h3><ul>
<li><strong>面向对象性：</strong></li>
</ul>
<ol>
<li><p><code>两个要素</code>：类、对象；</p>
</li>
<li><p><code>三个特征</code>：封装、继承、多态；</p>
</li>
</ol>
<ul>
<li><strong>健壮性：</strong></li>
</ul>
<ol>
<li><p>去除了C语言中的指针 </p>
</li>
<li><p>自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏</p>
</li>
</ol>
<ul>
<li><strong>跨平台型：</strong><br>write once,run anywhere（一次编译，到处运行），归功于JVM（Java编译器）</li>
</ul>
<h3 id="JDK、JRE、JVM的关系"><a href="#JDK、JRE、JVM的关系" class="headerlink" title="JDK、JRE、JVM的关系"></a>JDK、JRE、JVM的关系</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/gX81k6"><img src="https://z3.ax1x.com/2021/05/23/gX81k6.png" alt="gX81k6.png"></a></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="关键字与标识符"><a href="#关键字与标识符" class="headerlink" title="关键字与标识符"></a>关键字与标识符</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/gvP6Og"><img src="https://z3.ax1x.com/2021/05/24/gvP6Og.png" alt="gvP6Og.png"></a><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/gvP4f0"><img src="https://z3.ax1x.com/2021/05/24/gvP4f0.png" alt="gvP4f0.png"></a></p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>现Java版本尚未使用，但以后版本可能会作为关键字使用。  </p>
<p>具体哪些保留字：<code>goto</code> 、<code>const</code></p>
<p><strong>定义：</strong> 凡是自己可以起名字的地方都叫标识符。</p>
<p><strong>涉及到的结构：</strong> <code>包名</code>、<code>类名</code>、<code>接口名</code>、<code>变量名</code>、<code>方法名</code>、<code>常量名</code></p>
<h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/gvkCod"><img src="https://z3.ax1x.com/2021/05/24/gvkCod.png" alt="gvkCod.png"></a></p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="异常的体系结构"><a href="#异常的体系结构" class="headerlink" title="异常的体系结构"></a>异常的体系结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">异常的体系结构</span><br><span class="line"> * java.lang.Throwable</span><br><span class="line"> * 		|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line"> * 		|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line"> * 			|------编译时异常(checked)不会生成字节码文件</span><br><span class="line"> * 					|-----IOException</span><br><span class="line"> * 						|-----FileNotFoundException</span><br><span class="line"> * 					|-----ClassNotFoundException</span><br><span class="line"> * 			|------运行时异常(unchecked,RuntimeException)</span><br><span class="line"> * 					|-----NullPointerException//空指针异常</span><br><span class="line"> * 					|-----ArrayIndexOutOfBoundsException//数组角标越界</span><br><span class="line"> * 					|-----ClassCastException//类型转化异常</span><br><span class="line"> * 					|-----NumberFormatException//编码格式异常</span><br><span class="line"> * 					|-----InputMismatchException//输入不匹配</span><br><span class="line"> * 					|-----ArithmeticException//算术异常</span><br></pre></td></tr></table></figure>
<h3 id="java中异常类的继承关系"><a href="#java中异常类的继承关系" class="headerlink" title="java中异常类的继承关系"></a>java中异常类的继承关系</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/gv1wr9"><img src="https://z3.ax1x.com/2021/05/24/gv1wr9.png" alt="gv1wr9.png"></a></p>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><h3 id="异常的处理方式一：try-catch-finally"><a href="#异常的处理方式一：try-catch-finally" class="headerlink" title="异常的处理方式一：try-catch-finally"></a>异常的处理方式一：try-catch-finally</h3><ul>
<li><code>finally</code> 是可选的。</li>
<li>使用 <code>try</code> 将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去 <code>catch</code> 中进行匹配</li>
<li>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构（在没写 <code>finally</code> 的情况。继续执行其后的代码）</li>
<li><code>catch</code> 中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓；<code>catch</code> 中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则会报错</li>
<li>常用的异常对象处理的方式：</li>
</ul>
<ol>
<li>String getMessage() </li>
<li>printStackTrace()</li>
</ol>
<ul>
<li>在 <code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用</li>
<li><code>try-catch-finally</code> 结构可以嵌套</li>
</ul>
<blockquote>
<p><strong>如何看待代码中的编译时异常和运行时异常？</strong>  </p>
</blockquote>
<ul>
<li>使用 <code>try-catch-finally</code> 处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</li>
<li>开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。但是针对于编译时异常，一定要考虑异常的处理。</li>
</ul>
<h3 id="异常的处理方式二：throws"><a href="#异常的处理方式二：throws" class="headerlink" title="异常的处理方式二：throws"></a>异常的处理方式二：throws</h3><ul>
<li><code>throws + 异常类型</code> 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 <code>throws</code> 后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</li>
</ul>
<h3 id="对比两种处理方式"><a href="#对比两种处理方式" class="headerlink" title="对比两种处理方式"></a>对比两种处理方式</h3><p><strong>try-catch-finally</strong> 真正的将异常给处理掉了。<br><strong>throws</strong> 的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。</p>
<h3 id="开发中应该选择哪种处理方式？"><a href="#开发中应该选择哪种处理方式？" class="headerlink" title="开发中应该选择哪种处理方式？"></a>开发中应该选择哪种处理方式？</h3><ul>
<li>如果父类中被重写的方法没 <code>throws</code> 方式处理异常，则子类重写的方法也不能使用 <code>throws</code>，意味着如果子类重写的方法中异常，必须使用 <code>try-catch-finally</code> 方式处理。</li>
<li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 <code>throws</code> 的方式进行处理。而执行的方法a可以考虑使用 <code>try-catch-finally</code> 方式进行处理。</li>
</ul>
<blockquote>
<p><em><strong>补充：</strong></em> <strong>方法重写的规则之一：</strong><br>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
</blockquote>
<h2 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h2><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的 throw 一个异常类的对象。</p>
<p><strong><code>throw</code> 和 <code>throws</code> 区别：</strong>   </p>
<ul>
<li><strong>throw</strong> 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 </li>
<li><strong>throws</strong> 属于异常处理的一种方式，声明在方法的声明处。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//手动抛出异常对象</span></span><br><span class="line">            <span class="comment">//			throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="comment">//			throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line">        &#125;		</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><h3 id="为什么引入封装性"><a href="#为什么引入封装性" class="headerlink" title="为什么引入封装性"></a>为什么引入封装性</h3><p>我们程序设计追求“高内聚，低耦合”</p>
<ul>
<li><strong>高内聚</strong>：类的内部数据操作细节自己完成，不允许外部干涉</li>
<li><strong>低耦合</strong>：仅对外暴露少量的方法用于使用。</li>
</ul>
<p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露岀来。这就是封装性的设计思想。</p>
<h3 id="封装性代码的具体体现"><a href="#封装性代码的具体体现" class="headerlink" title="封装性代码的具体体现"></a>封装性代码的具体体现</h3><p><strong>体现一：</strong>  </p>
<ul>
<li><p>将类的属性xxx私化(<code>private</code>),同时，提供公共的(<code>public</code>)方法来获取(<code>getXxx</code>)和设置(<code>setXxx</code>)此属性的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>体现二：</strong> 不对外暴露的私有的方法</p>
</li>
<li><p><strong>体现三：</strong> 单例模式（将构造器私有化）</p>
</li>
<li><p><strong>体现四：</strong> 如果不希望类在包外被调用，可以将类设置为缺省的。</p>
</li>
</ul>
<h3 id="Java规定的四种权限修饰符"><a href="#Java规定的四种权限修饰符" class="headerlink" title="Java规定的四种权限修饰符"></a>Java规定的四种权限修饰符</h3><p>通过<strong>对不同的方法属性设置不同的权限修饰符</strong>来达到对类进行<code>封装</code>的目的。</p>
<p>权限从小到大顺序为：<code>private &lt; 缺省 &lt; protected &lt; public</code></p>
<p><strong>具体的修饰范围：</strong></p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">类内部</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">（缺省）</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
</tbody></table>
<p><strong>权限修饰符可用来修饰的结构说明:</strong></p>
<ul>
<li>4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</li>
<li>修饰类，只能使用：缺省、public</li>
</ul>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><h3 id="继承性的格式"><a href="#继承性的格式" class="headerlink" title="继承性的格式"></a>继承性的格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A extends B&#123;&#125;</span><br><span class="line"> *    A:子类、派生类、subclass</span><br><span class="line"> *    B:父类、超类、基类、superclass</span><br></pre></td></tr></table></figure>
<h3 id="子类继承父类后有哪些不同"><a href="#子类继承父类后有哪些不同" class="headerlink" title="子类继承父类后有哪些不同"></a>子类继承父类后有哪些不同</h3><ul>
<li><p>子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p>
</li>
<li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。</p>
</li>
</ul>
<h3 id="Java继承类的说明"><a href="#Java继承类的说明" class="headerlink" title="Java继承类的说明"></a>Java继承类的说明</h3><ol>
<li>一个类可以被多个子类继承。</li>
<li>Java中类的单继承性：一个类只能有一个父类</li>
<li>子父类是相对的概念。</li>
<li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li>
<li>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</li>
</ol>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h4 id="java-lang-Object类的理解"><a href="#java-lang-Object类的理解" class="headerlink" title="java.lang.Object类的理解"></a>java.lang.Object类的理解</h4><p>是Java中所有类的父类，类似于二叉树中的根节点，定义了一些通用的方法。</p>
<ol>
<li>如果我们没显式的声明一个类的父类的话，则此类继承于<code>java.lang.Object类</code></li>
<li>所的java类（除java.lang.Object类之外都<strong>直接或间接</strong>继承于<code>java.lang.Object类</code></li>
<li>意味着，所的java类具有<code>java.lang.Object类</code>声明的功能。</li>
<li><code>java.lang.Object类</code>中定义的一些方法</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Object()</td>
<td align="center">构造方法</td>
<td align="center">构造器</td>
</tr>
<tr>
<td align="center">public boolean equals(Object obj)</td>
<td align="center">普通方法</td>
<td align="center">对象比较</td>
</tr>
<tr>
<td align="center">public int hashCode()</td>
<td align="center">普通方法</td>
<td align="center">获取Hash码</td>
</tr>
<tr>
<td align="center">public String toString()</td>
<td align="center">普通方法</td>
<td align="center">对象打印时调用</td>
</tr>
</tbody></table>
<h4 id="java-lang-Object类的说明"><a href="#java-lang-Object类的说明" class="headerlink" title="java.lang.Object类的说明"></a>java.lang.Object类的说明</h4><ol>
<li><p>Object类是所Java类的根父类</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object 类</p>
</li>
<li><p>Object 类中的功能(属性、方法)就具通用性。</p>
</li>
</ol>
<ul>
<li><p><em><strong>属性：</strong></em> 无</p>
</li>
<li><p><em><strong>方法：</strong></em><br>equals() &#x2F; toString() &#x2F; getClass() &#x2F;hashCode() &#x2F; clone() &#x2F; finalize()<br>wait() 、 notify()、notifyAll()</p>
</li>
</ul>
<p>&amp;nbsp; &amp;nbsp; &amp;nbsp; Object类只声明了一个空参的构造器<br>&amp;nbsp; &amp;nbsp; &amp;nbsp;数组也作为 Object 类的子类出现，可以调用 Object 类中声明的方法</p>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h4><ul>
<li>是一个<strong>方法</strong>，而非运算符</li>
<li>只能适用于<strong>引用数据类型</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">	        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用说明：</strong></p>
</blockquote>
</li>
</ul>
<ol>
<li><p>Object类中定义的 <strong>equals()</strong> 和 <strong>&#x3D;&#x3D;</strong> 的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
</li>
<li><p>像String、Date、File、包装类等都重写了<code>Object类</code>中的<code>equals()方法</code>。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>通常情况下，我们自定义的类如果使用<code>equals()</code>的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对<code>Object类</code>中的<code>equals()</code>进行重写.</p>
</li>
<li><p><strong>重写的原则</strong>：比较两个对象的实体内容是否相同.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="comment">//重写其equals()方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="built_in">this</span>)&#123;<span class="comment">//判断形参和比较对象的引用地址是否相同，相同直接返回true</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">			<span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.age == u.age &amp;&amp; <span class="built_in">this</span>.name.equals(u.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4></li>
<li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的<code>toString()方法</code></p>
</li>
<li><p><strong>Object类</strong>中<code>toString()</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>像<strong>String、Date、File、包装类等</strong>都重写了<strong>Object类</strong>中的<code>toString()方法</code>。使得在调用对象的<code>toString()</code>时，返回”实体内容”信息。</p>
</li>
<li><p>自定义类也可以重写<code>toString()方法</code>，当调用此方法时，返回对象的”实体内容”</p>
</li>
</ol>
<blockquote>
<p>重写toString()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类对象实例化全过程"><a href="#子类对象实例化全过程" class="headerlink" title="子类对象实例化全过程"></a>子类对象实例化全过程</h3><p><strong>1. 从结果上看：继承性：</strong>  </p>
<ul>
<li>子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</li>
</ul>
<p><strong>2. 从过程上看：</strong></p>
<ul>
<li>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了<code>java.lang.Object类</code>中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</li>
</ul>
<p><strong>3. 强调说明：</strong></p>
<ul>
<li>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</li>
</ul>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><h3 id="多态性的理解"><a href="#多态性的理解" class="headerlink" title="多态性的理解"></a>多态性的理解</h3><p>可以理解为一个事物的多种形态。比如数据库的连接方式，我们定义好了数据库的连接，也规定了连接时的步骤，但是我们并不知道用户会采用什么数据库，在没有多态以前我们只能针对不同的数据库写不同的连接方法，而有了多态以后我们只需要定义好数据库的类并书写好连接方法，让所有的数据库继承数据库类并重写数据库连接方法。  </p>
<p>这样我们在调用的时候只需要通过声明数据库类并指向数据库的子类的方式，<strong>（即数据库类的引用指向继承了数据库类的具体实现类的对象）</strong> 就可以进行数据库连接。而不是需要针对不同的数据库书写不同的连接方式。</p>
<h3 id="何为多态性"><a href="#何为多态性" class="headerlink" title="何为多态性"></a>何为多态性</h3><p><strong>对象的多态性：</strong> 父类的引用指向子类的对象（或子类的对象赋给父类的引用）  </p>
<p>编译时和运行时类型不一致，产生了多态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>

<h3 id="多态性的使用：虚拟方法调用"><a href="#多态性的使用：虚拟方法调用" class="headerlink" title="多态性的使用：虚拟方法调用"></a>多态性的使用：虚拟方法调用</h3><ul>
<li>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</li>
<li><strong>总结：</strong> 编译，看左边；运行，看右边。</li>
<li><strong>对象的多态：</strong> 在Java中，子类的对象可以替代父类的对象使用<blockquote>
<ul>
<li>一个变量只能有一种确定的数据类型 </li>
<li>一个引用类型变量可能指向（引用）多种不同类型的对象</li>
</ul>
</blockquote>
<h4 id="多态性使用前提"><a href="#多态性使用前提" class="headerlink" title="多态性使用前提"></a>多态性使用前提</h4></li>
</ul>
<ol>
<li>类的继承方法</li>
<li>方法的重写</li>
</ol>
<h4 id="多态性使用的注意点"><a href="#多态性使用的注意点" class="headerlink" title="多态性使用的注意点"></a>多态性使用的注意点</h4><ul>
<li><p>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
</li>
<li><p>引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就<strong>不能</strong>再访问子类中添加的属性和方法</p>
</li>
</ul>
<h4 id="多态使用总结"><a href="#多态使用总结" class="headerlink" title="多态使用总结"></a>多态使用总结</h4><p><strong>多态的作用：</strong> 提高了代码的通用性，常称作接口重用</p>
<p><strong>使用前提：</strong> </p>
<ol>
<li>需要存在继承或者实现关系 </li>
<li>有方法的重写</li>
</ol>
<p><strong>成员方法：</strong><br><strong>编译时：</strong> 要查看引用变量所声明的类中是否有所调用的方法<br><strong>运行时：</strong> 调用实际new的对象所属的类中的重写方法</p>
<p><strong>成员变量：</strong> 不具备多态性，只看引用变量所声明的类</p>
<h3 id="向上转型与向下转型"><a href="#向上转型与向下转型" class="headerlink" title="向上转型与向下转型"></a>向上转型与向下转型</h3><p>向上转型：多态</p>
<h4 id="为什么使用向下转型"><a href="#为什么使用向下转型" class="headerlink" title="为什么使用向下转型"></a>为什么使用向下转型</h4><blockquote>
<p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</p>
</blockquote>
<h4 id="如何实现向下转型"><a href="#如何实现向下转型" class="headerlink" title="如何实现向下转型"></a>如何实现向下转型</h4><p>使用强制类型转换符：()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line">Man m1=（Man）p2；<span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure>
<h4 id="使用时的注意点"><a href="#使用时的注意点" class="headerlink" title="使用时的注意点"></a>使用时的注意点</h4><ol>
<li><p>使用强转时，可能出现<code>ClassCastException</code>的异常。</p>
</li>
<li><p>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行<code>instanceof</code>的判断，一旦返回<code>true</code>，就进行向下转型。如果返回false，不进行向下转型。</p>
</li>
<li><p>只有对象A是B的子类实例化对象或者在下层的子类，才能向下转型</p>
</li>
</ol>
<h4 id="instanceof的使用"><a href="#instanceof的使用" class="headerlink" title="instanceof的使用"></a>instanceof的使用</h4><ol>
<li><p>a instanceof A: 判断对象a是否是类A的实例。如果是，返回 true；如果不是，返回false。</p>
</li>
<li><p>如果 a instanceof A 返回 true,则 a instanceof B 也返回 true.其中，类B是类A的父类。</p>
</li>
<li><p>要求a所属的类与类A必须是子类和父类的关系，否则编译错误<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/gzHMa8"><img src="https://z3.ax1x.com/2021/05/25/gzHMa8.png" alt="gzHMa8.png"></a></p>
</li>
</ol>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><blockquote>
<p><strong>谈谈你对多态性的理解？</strong></p>
</blockquote>
<ul>
<li><p>实现代码的通用性。</p>
</li>
<li><p>举例：<br>Object类中定义的public boolean equals(Object obj){ }<br>JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server）<br>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</p>
</li>
</ul>
<blockquote>
<p><strong>多态是编译时行为还是运行时行为？</strong></p>
</blockquote>
<ul>
<li>运行时行为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldMethodTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">		System.out.println(s.count);<span class="comment">//20</span></span><br><span class="line">		s.display();<span class="comment">//20</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> s;<span class="comment">//多态性</span></span><br><span class="line">		<span class="comment">//==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同</span></span><br><span class="line">		System.out.println(b == s);<span class="comment">//true</span></span><br><span class="line">		System.out.println(b.count);<span class="comment">//10</span></span><br><span class="line">		b.display();<span class="comment">//20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>若子类重写了父类方法，就意味着子类里面定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中：编译看左边，运行看右边</p>
</li>
<li><p>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量：编译运行都看左边</p>
</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><ul>
<li><strong>面向过程：</strong> 强调的是功能行为，以函数为最小单位，考虑怎么做。</li>
<li><strong>面向对象：</strong> 强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</li>
</ul>
<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><p><strong>类：</strong> 对一类事物的描述，是抽象的、概念上的定义</p>
<p><strong>对象：</strong> 是实际存在的该类事物的每个个体，因而也称为实例(instance)</p>
<h3 id="面向对象思想实现的规则"><a href="#面向对象思想实现的规则" class="headerlink" title="面向对象思想实现的规则"></a>面向对象思想实现的规则</h3><ol>
<li><p>创建类，设计类的成员</p>
</li>
<li><p>创建类的对象</p>
</li>
<li><p>通过对象.属性 或 对象.方法调用对象的结构</p>
</li>
</ol>
<p><strong>补充</strong>：几个概念的使用说明  </p>
<blockquote>
<p>属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段<br>方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method<br>创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类</p>
</blockquote>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>我们创建的对象，没显式的赋给一个变量名。即为匿名对象</p>
<p><strong>特点：</strong> 匿名对象只能调用一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().sendEmail();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().playGame();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().showPrice();<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PhoneMall</span> <span class="variable">mall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneMall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br><span class="line">其中，</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone phone)</span>&#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的结构之一：属性"><a href="#类的结构之一：属性" class="headerlink" title="类的结构之一：属性"></a>类的结构之一：属性</h2><h3 id="属性vs局部变量"><a href="#属性vs局部变量" class="headerlink" title="属性vs局部变量"></a>属性vs局部变量</h3><blockquote>
<p><strong>相同点：</strong></p>
</blockquote>
<ol>
<li><p>定义变量的格式：数据类型 变量名 &#x3D; 变量值</p>
</li>
<li><p>先声明，后使用</p>
</li>
<li><p>变量都其对应的作用域</p>
</li>
</ol>
<blockquote>
<p><strong>不同点：</strong></p>
</blockquote>
<ol>
<li>在类中声明的位置的不同</li>
</ol>
<ul>
<li><strong>属性</strong>：直接定义在类的一对{}内  </li>
<li><strong>局部变量</strong>：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量。</li>
</ul>
<ol start="2">
<li>关于权限修饰符的不同</li>
</ol>
<ul>
<li><strong>属性：</strong> 可以在声明属性时，指明其权限，使用权限修饰符。  </li>
<li><strong>常用的权限修饰符：</strong> private、public、缺省、protected —&gt;封装性  </li>
<li>目前，声明属性时，使用缺省就可以。  </li>
<li><strong>局部变量：</strong> 不可以使用权限修饰符。</li>
</ul>
<ol start="3">
<li>默认初始化值的情况：</li>
</ol>
<ul>
<li><p><strong>属性：</strong> 类的属性，根据其类型，都默认初始化值。</p>
</li>
<li><p><code>整型</code>（byte、short、int、long：0）</p>
</li>
<li><p><code>浮点型</code>（float、double：0.0）</p>
</li>
<li><p><code>字符型</code>（char：0 （或’\u0000’））</p>
</li>
<li><p><code>布尔型</code>（boolean：false）</p>
</li>
<li><p><code>引用数据类型</code>（类、数组、接口：null）</p>
</li>
<li><p><strong>局部变量：</strong> 没默认初始化值。</p>
</li>
</ul>
<blockquote>
<ul>
<li>意味着，我们在调用局部变量之前，一定要显式赋值。</li>
<li>特别地：形参在调用时，我们赋值即可。</li>
</ul>
</blockquote>
<ol start="4">
<li>在内存中加载的位置：</li>
</ol>
<ul>
<li><strong>属性：</strong> 加载到<code>堆空间</code>中 （非static）  </li>
<li><strong>局部变量：</strong> 加载到<code>栈空间</code></li>
</ul>
<h2 id="类的结构之二：方法"><a href="#类的结构之二：方法" class="headerlink" title="类的结构之二：方法"></a>类的结构之二：方法</h2><h3 id="方法的说明"><a href="#方法的说明" class="headerlink" title="方法的说明"></a>方法的说明</h3><p><strong>关于权限修饰符：</strong><br>Java规定的四种权限修饰符：private、public、缺省、protected</p>
<h3 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h3><ul>
<li><p>同类中的方法可以直接调用当前类的属性或方法，<br>不同类中通过类的实例化对象调用。</p>
</li>
<li><p>特殊的：方法A中又调用了自身—递归方法。（自身调用）</p>
</li>
</ul>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul>
<li>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li>
</ul>
<h3 id="可变个数形参方法"><a href="#可变个数形参方法" class="headerlink" title="可变个数形参方法"></a>可变个数形参方法</h3><ul>
<li><p>可变个数形参的格式：<code>数据类型 ... 变量名</code></p>
</li>
<li><p>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，…..</p>
</li>
<li><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p>
</li>
<li><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</p>
</li>
<li><p>可变个数形参在方法的形参中，必须声明在末尾。</p>
</li>
<li><p>可变个数形参在方法的形参中， <em><strong>最多只能声明一个可变形参</strong></em>。</p>
</li>
</ul>
<h3 id="Java的值传递机制"><a href="#Java的值传递机制" class="headerlink" title="Java的值传递机制"></a>Java的值传递机制</h3><ul>
<li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
</ul>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p>
<h4 id="重写的应用"><a href="#重写的应用" class="headerlink" title="重写的应用"></a>重写的应用</h4><p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p>
<h4 id="重写举例"><a href="#重写举例" class="headerlink" title="重写举例"></a>重写举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cylinder</span> <span class="keyword">extends</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">**********************************************</span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amt)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckAccount</span> <span class="keyword">extends</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amt)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写的规则"><a href="#重写的规则" class="headerlink" title="重写的规则"></a>重写的规则</h4><blockquote>
<p><strong>方法的声明</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型&#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p>
</li>
<li><p>子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</p>
</li>
<li><p>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</p>
</li>
</ul>
<p><em><strong><code>特殊情况：</code>子类不能重写父类中声明为private权限的方法</strong></em></p>
<blockquote>
<p><strong>返回值类型：</strong></p>
</blockquote>
<ol>
<li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li>
<li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li>
</ol>
<blockquote>
<p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
</blockquote>
<ul>
<li>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。</li>
<li>开发中一般保持子父类一致</li>
</ul>
<blockquote>
<p><em><strong>区分方法的重写和重载？</strong></em></p>
</blockquote>
<ol>
<li><strong>二者的概念：</strong></li>
</ol>
<p><code>方法的重写</code>：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.<br><code>方法的重载</code>： 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
<ol>
<li>重载和重写的具体规则：重载：两同一不同，重写</li>
<li>重载：不表现为多态性。 重写：表现为多态性。</li>
<li>从编译和运行的角度看：</li>
</ol>
<ul>
<li><p>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p>
</li>
<li><p>所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</p>
</li>
<li><p>而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</p>
</li>
</ul>
<h2 id="类的结构之三：构造器"><a href="#类的结构之三：构造器" class="headerlink" title="类的结构之三：构造器"></a>类的结构之三：构造器</h2><p><strong>构造器的作用：</strong>（只要造对象就得用构造器）</p>
<ol>
<li><p>创建对象</p>
</li>
<li><p>初始化对象的信息</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3></li>
<li><p>如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</p>
</li>
<li><p>定义构造器的格式：<code>权限修饰符 类名(形参列表)&#123; &#125;</code></p>
</li>
<li><p>一个类中定义的多个构造器，彼此构成重载</p>
</li>
<li><p>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</p>
</li>
<li><p>一个类中，至少会有一个构造器。</p>
</li>
</ol>
<h3 id="构造器举例"><a href="#构造器举例" class="headerlink" title="构造器举例"></a>构造器举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器不等于方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person().....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n)</span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器默认权限和类的权限一致</p>
<h3 id="属性赋值顺序"><a href="#属性赋值顺序" class="headerlink" title="属性赋值顺序"></a>属性赋值顺序</h3><p><strong>总结：</strong> 属性赋值的先后顺序</p>
<ol>
<li><p>默认初始化</p>
</li>
<li><p>显式初始化</p>
</li>
<li><p>构造器中初始化</p>
</li>
<li><p>通过”对象.方法” 或 “对象.属性”的方式，赋值</p>
</li>
</ol>
<h3 id="JavaBean的概念"><a href="#JavaBean的概念" class="headerlink" title="JavaBean的概念"></a>JavaBean的概念</h3><p>所谓JavaBean，是指符合如下标准的Java类：</p>
<ul>
<li><p>类是公共的</p>
</li>
<li><p>一个<strong>无参</strong>的公共的构造器</p>
</li>
<li><p>属性，且对应的get、set方法</p>
</li>
</ul>
<h2 id="类的结构之四：代码块"><a href="#类的结构之四：代码块" class="headerlink" title="类的结构之四：代码块"></a>类的结构之四：代码块</h2><p>代码块(初始化块)（重要性较属性、方法、构造器差一些）</p>
<h3 id="代码块的作用"><a href="#代码块的作用" class="headerlink" title="代码块的作用"></a>代码块的作用</h3><p>用来初始化类、对象的信息</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>代码块要是使用修饰符，只能使用static<br><strong>分类：</strong> 静态代码块 vs 非静态代码块</p>
<blockquote>
<p><strong>静态代码块：</strong></p>
</blockquote>
<ul>
<li>内部可以输出语句</li>
<li>随着类的加载而执行,而且只执行一次</li>
<li>作用：初始化类的信息</li>
<li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li>
<li>静态代码块的执行要优先于非静态代码块的执行</li>
<li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li>
</ul>
<blockquote>
<p><strong>非静态代码块：</strong></p>
</blockquote>
<ul>
<li>内部可以输出语句</li>
<li>随着对象的创建而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以在创建对象时，对对象的属性等进行初始化</li>
<li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
<p><em><strong>注意：</strong></em><br>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：由父及子，静态先行。</p>
<p>举例一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">                           + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;调用父类构造器&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Leaf</span>(); </span><br><span class="line">        <span class="comment">//new Leaf();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;33333333333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;44444444444&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;55555555555&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;66666666666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;77777777777&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性的赋值顺序"><a href="#属性的赋值顺序" class="headerlink" title="属性的赋值顺序"></a>属性的赋值顺序</h3><ol>
<li><p>默认初始化</p>
</li>
<li><p>显式初始化&#x2F;⑤在代码块中赋值</p>
</li>
<li><p>构造器中初始化</p>
</li>
<li><p>有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p>
</li>
</ol>
<h2 id="类的结构之五：内部类"><a href="#类的结构之五：内部类" class="headerlink" title="类的结构之五：内部类"></a>类的结构之五：内部类</h2><h3 id="内部类的定义"><a href="#内部类的定义" class="headerlink" title="内部类的定义"></a>内部类的定义</h3><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。</p>
<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><ul>
<li><p>成员内部类（静态、非静态 ）   </p>
</li>
<li><p>局部内部类(方法内、代码块内、构造器内)</p>
<h3 id="成员内部类的理解"><a href="#成员内部类的理解" class="headerlink" title="成员内部类的理解"></a>成员内部类的理解</h3></li>
</ul>
<p>一方面，作为外部类的成员：</p>
<ul>
<li>调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以被4种不同的权限修饰</li>
</ul>
<p>另一方面，作为一个类：</p>
<ul>
<li><p>类内可以定义属性、方法、构造器等</p>
</li>
<li><p>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</p>
</li>
<li><p>可以被abstract修饰</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h4 id="如何创建成员内部类的对象？-静态的，非静态的"><a href="#如何创建成员内部类的对象？-静态的，非静态的" class="headerlink" title="如何创建成员内部类的对象？(静态的，非静态的)"></a>如何创建成员内部类的对象？(静态的，非静态的)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">// Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br></pre></td></tr></table></figure>
<h4 id="如何在成员内部类中调用外部类的结构？"><a href="#如何在成员内部类中调用外部类的结构？" class="headerlink" title="如何在成员内部类中调用外部类的结构？"></a>如何在成员内部类中调用外部类的结构？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">            System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">            <span class="comment">//Person.this.eat();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="局部内部类的使用"><a href="#局部内部类的使用" class="headerlink" title="局部内部类的使用"></a>局部内部类的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="comment">//      class MyComparable implements Comparable&#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//          @Override</span></span><br><span class="line">    <span class="comment">//          public int compareTo(Object o) &#123;</span></span><br><span class="line">    <span class="comment">//              return 0;</span></span><br><span class="line">    <span class="comment">//          &#125;</span></span><br><span class="line">    <span class="comment">//          </span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//      </span></span><br><span class="line">    <span class="comment">//      return new MyComparable();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。</p>
</li>
<li><p><strong>原因：</strong> 局部内部类也会生成字节码文件，在调用所属类的局部变量时，因为是两个类，所以不能修改所属类的属性，因此所属类将属性设置为final的为内部类调用提供一个副本，而内部类不能进行修改。</p>
</li>
<li><p>jdk 7及之前版本：要求此局部变量显式的声明为final的</p>
</li>
<li><p>jdk 8及之后的版本：可以省略final的声明</p>
</li>
</ul>
<blockquote>
<p><strong>总结：</strong><br>成员内部类和局部内部类，在编译以后，都会生成字节码文件。<br>格式：成员内部类：外部类$内部类名.class 局部内部类：外部类$数字 内部类名.class</p>
</blockquote>
<h1 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h1><h2 id="return–跳出"><a href="#return–跳出" class="headerlink" title="return–跳出"></a>return–跳出</h2><ul>
<li><p>使用在方法体中，用于：① 结束方法 ② 针对于返回值类型的方法，使用”<code>return 数据</code>“方法返回所要的数据。</p>
</li>
<li><p><code>return</code>关键字后面不可以声明执行语句。</p>
</li>
<li><p>在异常处理中<code>try-catch-finally</code>的结构中，如果try或catch中的结构中写了<code>return</code>，但是<code>finally</code>中的结构仍会执行。</p>
</li>
</ul>
<h2 id="this–本类的"><a href="#this–本类的" class="headerlink" title="this–本类的"></a>this–本类的</h2><p><strong>this理解为</strong>：当前对象 或 当前正在创建的对象，可以调用的结构：<code>属性、方法；构造器</code></p>
<h3 id="this调用属性、方法"><a href="#this调用属性、方法" class="headerlink" title="this调用属性、方法"></a>this调用属性、方法</h3><ul>
<li><p>在类的方法中，我们可以使用”<code>this.属性</code>“或”<code>this.方法</code>“的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”<code>this.</code>“。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”<code>this.变量</code>“的方式，表明此变量是属性，而非形参。</p>
</li>
<li><p>在类的构造器中，我们可以使用”<code>this.属性</code>“或”<code>this.方法</code>“的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”<code>this.</code>“。特殊情况下，如果<strong>构造器的形参和类的属性同名</strong>时，我们必须显式的使用”<code>this.变量</code>“的方式，表明此变量是属性，而非形参。</p>
</li>
</ul>
<h3 id="this调用构造器"><a href="#this调用构造器" class="headerlink" title="this调用构造器"></a>this调用构造器</h3><ol>
<li>我们在类的构造器中，可以显式的使用 <strong>“this(形参列表)”</strong> 方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过”this(形参列表)”方式调用自己</li>
<li>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</li>
<li>规定：”this(形参列表)”必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器</li>
</ol>
<h2 id="super–父类的"><a href="#super–父类的" class="headerlink" title="super–父类的"></a>super–父类的</h2><p><code>super关键字</code>可以理解为：父类的，可以用来调用的结构：<strong>属性、方法、构造器</strong></p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li>
<li>super的追溯不仅限于直接父类</li>
<li>super和this的用法相像，this代表本类对象的引用， super代表父类的内存空间的标识<h3 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h3><h4 id="super调用属性、方法"><a href="#super调用属性、方法" class="headerlink" title="super调用属性、方法"></a>super调用属性、方法</h4>与this关键字使用方式相同，只不过调用的是父类的属性<h4 id="在子类的方法或构造器中使用"><a href="#在子类的方法或构造器中使用" class="headerlink" title="在子类的方法或构造器中使用"></a>在子类的方法或构造器中使用</h4>通过使用”<code>super.属性</code>“或”<code>super.方法</code>“的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯<strong>省略</strong>“<code>super.</code>“</li>
</ul>
<p><em><strong>特殊情况</strong></em></p>
<ul>
<li><p>当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”<code>super.属性</code>“的方式，表明调用的是父类中声明的属性。</p>
</li>
<li><p>当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”<code>super.方法</code>“的方式，表明调用的是父类中被重写的方法。</p>
<h4 id="super调用构造器"><a href="#super调用构造器" class="headerlink" title="super调用构造器"></a>super调用构造器</h4></li>
<li><p>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</p>
</li>
<li><p>“super(形参列表)”的使用，必须声明在子类构造器的首行！</p>
</li>
<li><p>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</p>
</li>
<li><p>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</p>
</li>
<li><p>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p>
</li>
</ul>
<h3 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h3><table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问属性</td>
<td align="center">访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td align="center">直接访问父类中的属性</td>
</tr>
<tr>
<td align="center">调用方法</td>
<td align="center">访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td align="center">直接访问父类中的方法</td>
</tr>
<tr>
<td align="center">调用构造器</td>
<td align="center">调用本类构造器，必须放在构造器的首行</td>
<td align="center">调用父类构造器，必须放在子类构造器的首行</td>
</tr>
</tbody></table>
<h2 id="package-x2F-import"><a href="#package-x2F-import" class="headerlink" title="package&#x2F;import"></a>package&#x2F;import</h2><ol>
<li><p>为了更好的实现项目中类的管理，提供包的概念</p>
</li>
<li><p>使用package声明类或接口所属的包，声明在源文件的首行</p>
</li>
<li><p>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</p>
</li>
<li><p>每”.”一次，就代表一层文件目录。</p>
</li>
</ol>
<h3 id="包结构应用举例"><a href="#包结构应用举例" class="headerlink" title="包结构应用举例"></a>包结构应用举例</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2pgYb4"><img src="https://z3.ax1x.com/2021/05/26/2pgYb4.png" alt="2pgYb4.png"></a></p>
<h3 id="JDK中的主要包介绍"><a href="#JDK中的主要包介绍" class="headerlink" title="JDK中的主要包介绍"></a>JDK中的主要包介绍</h3><ul>
<li><p><code>java. lang</code>–包含一些Java语言的核心类，如 String、Math、 integer、 System和Thread，提供常用功能</p>
</li>
<li><p><code>java. net</code>–包含执行与网络相关的操作的类和接口</p>
</li>
<li><p><code>java.io</code>–包含能提供多种输入&#x2F;输出功能的类</p>
</li>
<li><p><code>java util</code>–包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</p>
</li>
<li><p><code>java. text</code>–包含了一些java格式化相关的类</p>
</li>
<li><p><code>java.sql</code>–包含了java进行JDBC数据库编程的相关类&#x2F;接口</p>
</li>
<li><p><code>java. awt</code>–包含了构成抽象窗口工具集 (abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面GU）。 B&#x2F;S C&#x2F;S</p>
</li>
</ul>
<h3 id="import的使用"><a href="#import的使用" class="headerlink" title="import的使用"></a>import的使用</h3><ol>
<li><p>在源文件中显式的使用import结构导入指定包下的类、接口</p>
</li>
<li><p>声明在包的声明和类的声明之间</p>
</li>
<li><p>如果需要导入多个结构，则并列写出即可</p>
</li>
<li><p>可以使用”xxx.*”的方式，表示可以导入xxx包下的所结构</p>
</li>
<li><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p>
</li>
<li><p>如果使用的类或接口是本包下定义的，则可以省略import结构</p>
</li>
<li><p>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</p>
</li>
<li><p>使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p>
</li>
<li><p>import static:导入指定类或接口中的静态结构:属性或方法。</p>
</li>
</ol>
<h2 id="static–静态的"><a href="#static–静态的" class="headerlink" title="static–静态的"></a>static–静态的</h2><p>主要用来修饰类的内部结构，如：<code>属性、方法、代码块、内部类</code></p>
<h3 id="static关键字使用"><a href="#static关键字使用" class="headerlink" title="static关键字使用"></a>static关键字使用</h3><h4 id="static修饰属性：静态变量（或类变量）"><a href="#static修饰属性：静态变量（或类变量）" class="headerlink" title="static修饰属性：静态变量（或类变量）"></a>static修饰属性：静态变量（或类变量）</h4><p>属性是否使用static修饰，可分为：静态属性 vs 非静态属性(实例变量)</p>
<p><strong>实例变量：</strong> 我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。<br><strong>静态变量：</strong> 我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p>
<blockquote>
<p><strong>static修饰属性的其他说明：</strong></p>
</blockquote>
<ul>
<li><p>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p>
</li>
<li><p>静态变量的加载要早于对象的创建。</p>
</li>
<li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p>
</li>
</ul>
<h4 id="static修饰方法：静态方法、类方法"><a href="#static修饰方法：静态方法、类方法" class="headerlink" title="static修饰方法：静态方法、类方法"></a>static修饰方法：静态方法、类方法</h4><ul>
<li><p>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p>
</li>
<li><p>静态方法中，只能调用静态的方法或属性</p>
</li>
<li><p>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
</li>
</ul>
<blockquote>
<p><em><strong>使用的注意点:</strong></em></p>
</blockquote>
<ul>
<li><p>在静态的方法内，不能使用this关键字、super关键字</p>
</li>
<li><p>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</p>
</li>
</ul>
<h4 id="如何判定属性和方法应该使用static关键字"><a href="#如何判定属性和方法应该使用static关键字" class="headerlink" title="如何判定属性和方法应该使用static关键字"></a>如何判定属性和方法应该使用static关键字</h4><blockquote>
<p><em><strong>关于属性：</strong></em></p>
</blockquote>
<ul>
<li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li>
<li>类中的常量也常常声明为<code>static</code></li>
</ul>
<blockquote>
<p><em><strong>关于方法：</strong></em></p>
</blockquote>
<ul>
<li>操作静态属性的方法，通常设置为<code>static</code>的</li>
<li>工具类中的方法，习惯上声明为<code>static</code>的。 比如：<strong>Math、Arrays、Collections</strong></li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="设计模式的说明"><a href="#设计模式的说明" class="headerlink" title="设计模式的说明"></a>设计模式的说明</h4><p>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。</p>
<blockquote>
<p><em><strong>常用设计模式 — 23种经典的设计模式 GOF</strong></em></p>
</blockquote>
<ul>
<li><strong>创建型模式</strong>，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li><strong>结构型模式</strong>，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li><strong>行为型模式</strong>，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<h4 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h4><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">饿汉式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.内部创建类的对象</span></span><br><span class="line">	<span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">饿汉式<span class="number">2</span>：使用了静态代码块</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">	<span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">	<span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两种方式对比</p>
</blockquote>
<ol>
<li><code>饿汉式</code>：上来就创建对象</li>
</ol>
<ul>
<li>坏处：对象加载时间过长。</li>
<li>好处：饿汉式是线程安全的</li>
</ul>
<ol start="2">
<li><code>懒汉式</code>：什么时候用什么时候造对象</li>
</ol>
<ul>
<li>好处：延迟对象的创建。</li>
<li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li>
</ul>
<h2 id="final–最终的"><a href="#final–最终的" class="headerlink" title="final–最终的"></a>final–最终的</h2><blockquote>
<p><strong>可以用来修饰：类、方法、变量</strong></p>
</blockquote>
<ol>
<li><p><code>final</code> 用来修饰一个<strong>类</strong>: 此类不能被其他类所继承。<br>比如：String类、System类、StringBuffer类</p>
</li>
<li><p><code>final</code> 用来修饰<strong>方法</strong>：表明此方法不可以被重写<br>比如：Object类中getClass();</p>
</li>
<li><p><code>final</code> 用来修饰<strong>变量</strong>：此时的”变量”就称为是一个常量</p>
</li>
</ol>
<ul>
<li>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li>
<li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li>
</ul>
<ol start="4">
<li><code>static final</code> 用来修饰<strong>属性</strong>：全局常量</li>
</ol>
<h2 id="abstract–抽象的"><a href="#abstract–抽象的" class="headerlink" title="abstract–抽象的"></a>abstract–抽象的</h2><p><code>abstract</code>: 抽象的，可以用来修饰：类、方法</p>
<h3 id="abstract关键字的使用"><a href="#abstract关键字的使用" class="headerlink" title="abstract关键字的使用"></a>abstract关键字的使用</h3><ol>
<li>abstract修饰类：<strong>抽象类</strong></li>
</ol>
<ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;<strong>抽象的使用前提</strong>：继承性</li>
</ul>
<ol start="2">
<li>abstract修饰方法：<strong>抽象方法</strong></li>
</ol>
<ul>
<li>抽象方法只方法的声明，没方法体</li>
<li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li>
<li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li>
<li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li>
</ul>
<blockquote>
<p><strong>注意点：</strong></p>
</blockquote>
<ul>
<li><p>abstract不能用来修饰：属性、构造器等结构</p>
</li>
<li><p>abstract不能用来修饰私有方法、静态方法（静态方法不能被重写，抽象方法不能调用）、final的方法、final的类</p>
</li>
</ul>
<blockquote>
<p><strong>举例1：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Vehicle&#123;//抽象类</span><br><span class="line">public abstract double calcFuelEfficiency();//计算燃料效率的抽象方法</span><br><span class="line">public abstract double calcTripDistance();//计算行驶距离的抽象方法</span><br><span class="line">&#125;</span><br><span class="line">public class Truck extends Vehiclel&#123;</span><br><span class="line">public double calcFuelEfficiency( )&#123;//写出计算卡车的燃料效率的具体方法&#125;</span><br><span class="line">public double calcTripDistance( )&#123;//写出计算卡车行驶距离的具体方法&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class River Barge extends Vehicle&#123;</span><br><span class="line">public double calcFuelEfficiency( )&#123;//写出计算驳船的燃料效率的具体方法&#125;</span><br><span class="line">public double calcTripDistance( )&#123;//写出计算驳船行驶距离的具体方法&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>举例2：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class GeometricObject&#123;//抽象类</span><br><span class="line">public abstract double findArea();</span><br><span class="line">&#125;</span><br><span class="line">class Circle extends GeometricObject&#123;</span><br><span class="line">private double radius;</span><br><span class="line">public double findArea()&#123;</span><br><span class="line">		return 3.14 * radius * radius;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>举例3：</strong></p>
</blockquote>
<ul>
<li>IO流中设计到的抽象类：InputStream&#x2F;OutputStream &#x2F; Reader &#x2F;Writer。在其内部定义了抽象的read()、write()方法。</li>
</ul>
<h3 id="模板方法的设计模式"><a href="#模板方法的设计模式" class="headerlink" title="模板方法的设计模式"></a>模板方法的设计模式</h3><p>在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，<code>易变部分</code>可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
<h4 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">abstract class Template&#123;</span><br><span class="line">	</span><br><span class="line">	//计算某段代码执行所需要花费的时间</span><br><span class="line">	public void spendTime()&#123;</span><br><span class="line">		</span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		this.code();//不确定的部分、易变的部分</span><br><span class="line">		</span><br><span class="line">		long end = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;花费的时间为：&quot; + (end - start));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public abstract void code();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubTemplate extends Template&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void code() &#123;</span><br><span class="line">		</span><br><span class="line">		for(int i = 2;i &lt;= 1000;i++)&#123;</span><br><span class="line">			boolean isFlag = true;</span><br><span class="line">			for(int j = 2;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line">				</span><br><span class="line">				if(i % j == 0)&#123;</span><br><span class="line">					isFlag = false;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(isFlag)&#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junt单元测试</li>
<li>JavaWeb 的 Servlet 中关于 doGet&#x2F;doPost 方法调用</li>
<li>Hibernate 中模板程序</li>
<li>Spring 中 JDBCTemlate、 Hibernate Template 等</li>
</ul>
<h2 id="interface–接口"><a href="#interface–接口" class="headerlink" title="interface–接口"></a>interface–接口</h2><ol>
<li><p>接口使用interface来定义</p>
</li>
<li><p>Java中，接口和类是并列的两个结构</p>
</li>
</ol>
<h3 id="interface关键字使用说明"><a href="#interface关键字使用说明" class="headerlink" title="interface关键字使用说明"></a>interface关键字使用说明</h3><ol>
<li><p><strong>如何定义接口</strong>：定义接口中的成员</p>
</li>
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p>
</li>
</ol>
<ul>
<li>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</li>
</ul>
<ol start="4">
<li>Java类可以实现多个接口 —&gt;弥补了Java单继承性的局限性</li>
</ol>
<ul>
<li><strong>格式：</strong> class AA extends BB implements CC,DD,EE</li>
</ul>
<ol start="5">
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
</li>
<li><p>接口，实际上可以看做是一种规范</p>
</li>
</ol>
<p><code>使用举例：</code> 不同的设备通过USB口接入电脑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Computer&#123;</span><br><span class="line">	</span><br><span class="line">	public void transferData(USB usb)&#123;//USB usb = new Flash();</span><br><span class="line">		usb.start();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;具体传输数据的细节&quot;);</span><br><span class="line">		</span><br><span class="line">		usb.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface USB&#123;</span><br><span class="line">	//常量：定义了长、宽、最大最小的传输速度等</span><br><span class="line">	</span><br><span class="line">	void start();</span><br><span class="line">	</span><br><span class="line">	void stop();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Flash implements USB&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		System.out.println(&quot;U盘开启工作&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		System.out.println(&quot;U盘结束工作&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Printer implements USB&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		System.out.println(&quot;打印机开启工作&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		System.out.println(&quot;打印机结束工作&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java8中关于接口新规范"><a href="#Java8中关于接口新规范" class="headerlink" title="Java8中关于接口新规范"></a>Java8中关于接口新规范</h3><ol>
<li>JDK7及以前：只能定义全局常量和抽象方法</li>
</ol>
<p>全局常量：public static final的，书写时可以省略不写<br>抽象方法：public abstract的</p>
<ol start="2">
<li><code>JDK8</code>：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li>
</ol>
<ul>
<li><p>Java8中，可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p>
</li>
<li><p>静态方法：使用 static关键字修饰。<br>可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像 Collection&#x2F;co| ections或者Path&#x2F; Paths这样成对的接口和类。</p>
</li>
<li><p>默认方法：默认方法使用 default关键字修饰。  </p>
</li>
<li><p>可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性比如：java8API中对 Collection、List、 Comparator等接口提供了丰富的默认方法。</p>
</li>
</ul>
<blockquote>
<p><em><strong>JDK 8后接口使用总结</strong></em></p>
</blockquote>
<ul>
<li><p><code>知识点1</code>：接口中定义的静态方法，只能通过接口来调用。</p>
</li>
<li><p><code>知识点2</code>：通过实现类的对象，可以调用接口中的默认方法。<br>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p>
</li>
<li><p><code>知识点3</code>：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</p>
</li>
<li><p><code>知识点4</code>：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，<br>那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。<br>这就需要我们必须在实现类中重写此方法</p>
</li>
<li><p><code>知识点5</code>：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void myMethod()&#123;</span><br><span class="line">		method3();//调用自己定义的重写的方法</span><br><span class="line">		super.method3();//调用的是父类中声明的</span><br><span class="line">		//调用接口中的默认方法</span><br><span class="line">		CompareA.super.method3();</span><br><span class="line">		CompareB.super.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><blockquote>
<p><strong>抽象类和接口的异同？</strong></p>
</blockquote>
</li>
</ul>
<p><strong>相同点：</strong> </p>
<ul>
<li>都不能实例化；</li>
<li>都可以被继承；</li>
<li>都可以包含抽象方法的。</li>
</ul>
<p><strong>不同点：</strong><br><strong>抽象类</strong>：有构造器。<br><strong>接口</strong>：没有构造器<br>1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明<br>2）类：单继承性 接口：多继承<br>​<strong>类与接口</strong>：多实现</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">interface NetWork&#123;</span><br><span class="line">	public void browse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//被代理类</span><br><span class="line">class Server implements NetWork&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void browse() &#123;</span><br><span class="line">		System.out.println(&quot;真实的服务器访问网络&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//代理类</span><br><span class="line">class ProxyServer implements NetWork&#123;</span><br><span class="line">	</span><br><span class="line">	private NetWork work;</span><br><span class="line">	</span><br><span class="line">	public ProxyServer(NetWork work)&#123;</span><br><span class="line">		this.work = work;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void check()&#123;</span><br><span class="line">		System.out.println(&quot;联网之前的检查工作&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void browse() &#123;</span><br><span class="line">		check();</span><br><span class="line">		</span><br><span class="line">		work.browse();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p><code>安全代理</code>：屏蔽对真实角色的直接访问</p>
</li>
<li><p><code>远程代理</code>：通过代理类处理远程方法调用（RM）</p>
</li>
<li><p><code>延迟加载</code>：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用 proxy来进行大图片的打开。</p>
</li>
</ul>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>静态代理（静态定义代理类）</p>
</li>
<li><p>动态代理（动态生成代理类）JDK自带的动态代理，需要反射等知识</p>
</li>
</ul>
<h3 id="工厂的设计模式"><a href="#工厂的设计模式" class="headerlink" title="工厂的设计模式"></a>工厂的设计模式</h3><blockquote>
<p><strong>解决的问题</strong>  </p>
</blockquote>
<p>实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p>
<blockquote>
<p><strong>具体模式</strong><br><strong>简单工厂模式</strong>：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）<br><strong>工厂方法模式</strong>：用来生产同一等级结构中的固定产品。（支持增加任意产品)<br><strong>抽象工厂模式</strong>：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</p>
</blockquote>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="程序、进程、线程"><a href="#程序、进程、线程" class="headerlink" title="程序、进程、线程"></a>程序、进程、线程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序的一次执行过程，或是正在运行的一个程序。 说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程可进一步细化为线程，是一个程序内部的一条执行路径。 说明：线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。</p>
<blockquote>
<p>进程可以细化为多个线程。 每个线程，拥有自己独立的：栈、程序计数器 多个线程，共享同一个进程中的结构：方法区、堆。</p>
</blockquote>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><h3 id="单核CPU和多核CPU"><a href="#单核CPU和多核CPU" class="headerlink" title="单核CPU和多核CPU"></a>单核CPU和多核CPU</h3><ul>
<li><p><code>单核CPU</code>，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。涉及到CPU处理线程的方式，CPU在单位时间（也就是说一个时间片内）内只能处理一个线程，于是就将其他的线程设置为阻塞状态，加入到阻塞队列中，等到处理完成当前线程后从就绪队列中取出新的线程进行处理，由于切换和处理时间很快用户感知不到于是用户便认为CPU在同一时间内处理多个线程。</p>
</li>
<li><p><code>多核CPU</code>，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</p>
</li>
<li><p>一个Java应用程序java.exe，其实至少三个线程：<code>main()主线程</code>，<code>gc()垃圾回收线程</code>，<code>异常处理线程</code>。当然如果发生异常，会影响主线程。</p>
</li>
</ul>
<h3 id="并行与并发的理解"><a href="#并行与并发的理解" class="headerlink" title="并行与并发的理解"></a>并行与并发的理解</h3><p><code>并行</code>：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</p>
<p><code>并发</code>：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事</p>
<h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h2><p>当我们在进行商品抢购的时候，在支付按钮上总是有个计时器在进行倒计时，但是我们此时仍然可以进行商品信息的查看，这个计时器和我们浏览商品信息的线程是同时进行的，这样也就实现了抢购场景，增加了用户的体验。</p>
<h3 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h3><ul>
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>
<li>提高计算机系统CPU的利用率。</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3></li>
<li>程序需要同时执行两个或多个任务。</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</li>
<li>需要一些后台运行的程序时</li>
</ul>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>Java语言的JVM允许程序运行多个线程，它通过 <code>java. lang.Thread类来体现</code></p>
<h3 id="Thread类的特性"><a href="#Thread类的特性" class="headerlink" title="Thread类的特性"></a>Thread类的特性</h3><p>每个线程都是通过某个特定 Thread对象的run（方法来完成操作的，经常把run()方法的主体称为线程体 通过该 Thread对象的 start（方法来启动这个线程，而非直接调用run</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li><code>Thread()</code>：创建新的Thread对象</li>
<li><code>Thread（String threadName）</code>：创建线程并指定线程实例名</li>
<li><code>Thread（Runnable target）</code>：指定创建线程的目标对象，它实现了 Runnable接口中的run方法</li>
<li><code>Thread（Runnable target， String name）</code>：创建新的 Thread对象</li>
</ul>
<h3 id="创建多线程的两种方式"><a href="#创建多线程的两种方式" class="headerlink" title="创建多线程的两种方式"></a>创建多线程的两种方式</h3><h4 id="方式一继承Thread类的方式："><a href="#方式一继承Thread类的方式：" class="headerlink" title="方式一继承Thread类的方式："></a>方式一继承Thread类的方式：</h4><ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()</li>
</ol>
<blockquote>
<p><em><strong>注意点：</strong></em></p>
</blockquote>
<ol>
<li>我们启动一个线程，必须调用<code>start()</code>，不能调用<code>run()</code>的方式启动线程。 如果再启动一个线程，必须<strong>重新创建</strong>一个<code>Thread子类的对象</code>，调用此对象的<code>start()</code>.（注意后面的点）</li>
<li>如果自己手动调用<code>run()</code>方法，那么就只是普通方法，没有启动多线程模式</li>
<li><code>run()</code>方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li>
<li>想要启动多线程，必须调用<code>start方法</code>。</li>
<li>一个线程对象只能调用一次<code>start()</code>方法启动，如果重复调用了，则将抛出异常<code>“lllegalThreadStateException”</code>.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//1.继承Thread类</span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    public MyThread() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.重run方法</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            if (i % 2 == 0) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//3.新建Thread对象</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        //4.调用start方法</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式二实现Runnable接口的方式："><a href="#方式二实现Runnable接口的方式：" class="headerlink" title="方式二实现Runnable接口的方式："></a>方式二实现Runnable接口的方式：</h4><ol>
<li>创建一个实现了<code>Runnable</code>接口的类</li>
<li>实现类去实现Runnable中的抽象方法：<code>run()</code></li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到<code>Thread类</code>的构造器中，创建<code>Thread类</code>的对象</li>
<li>通过<code>Thread类</code>的对象调用<code>start()</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//1. 创建一个实现了Runnable接口的类</span><br><span class="line">public class RunnableTest implements Runnable &#123;</span><br><span class="line">    // 2. 实现类去实现Runnable中的抽象方法：run()</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //3. 创建实现类的对象</span><br><span class="line">        RunnableTest runnableTest = new RunnableTest();</span><br><span class="line">        //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span><br><span class="line">        Thread thread = new Thread(runnableTest);</span><br><span class="line">        //5. 通过Thread类的对象调用start()</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>两种方式的对比：</strong></p>
</blockquote>
<p>开发中优先选择：实现<strong>Runnable接口</strong>的方式</p>
<blockquote>
<p><strong>原因：</strong></p>
</blockquote>
<ol>
<li><p>实现的方式没有类的单继承性的局限性  </p>
</li>
<li><p>实现的方式更适合来处理多个线程共享数据的情况。</p>
</li>
</ol>
<p><strong>联系：</strong>  public class Thread implements Runnable<br><strong>相同点：</strong>  两种方式都需要重写<code>run()</code>,将线程要执行的逻辑声明在<code>run()</code>中。 目前两种方式，要想启动线程，都是调用的<code>Thread类</code>中的<code>start()</code>。</p>
<blockquote>
<p><strong>也可以采用创建匿名类的方式:</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //创建Thread类的匿名子类的方式</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                    if (i % 2 == 0) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                    if (i % 2 != 0) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h3><h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><p><strong>start()</strong>:启动当前线程；调用当前线程的run()，只有Thread类和他的子类才能调用start()方法</p>
<p><strong>run()</strong>: 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p>
<p><strong>currentThread()</strong>:静态方法，返回执行当前代码的线程</p>
<p><strong>getName()</strong>:获取当前线程的名字</p>
<p><strong>setName()</strong>:设置当前线程的名字</p>
<p><strong>yield()</strong>:释放当前cpu的执行权</p>
<p><strong>join()</strong>:在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</p>
<p><strong>stop()</strong>:已过时。当执行此方法时，强制结束当前线程。</p>
<p><strong>sleep(long millitime)</strong>:让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</p>
<p><strong>isAlive()</strong>:判断当前线程是否存活</p>
<h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><ul>
<li><strong>MAX_PRIORITY</strong>：10</li>
<li><strong>MIN _PRIORITY</strong>：1</li>
<li><strong>NORM_PRIORITY</strong>：5 –&gt;默认优先级</li>
</ul>
<blockquote>
<p>获取和设置当前线程的优先级:</p>
</blockquote>
<ul>
<li><p><strong>getPriority()</strong>:获取线程的优先级</p>
</li>
<li><p><strong>setPriority(int p)</strong>:设置线程的优先级</p>
</li>
</ul>
<p><em><strong>说明：</strong></em><br>高优先级的线程要抢占低优先级线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p>
<p><strong>线程通信：</strong> <code>wait()</code> &#x2F; <code>notify()</code> &#x2F; <code>notifyAll()</code> :此三个方法定义在Object类中的。</p>
<blockquote>
<p><strong>线程的分类</strong>  </p>
</blockquote>
<p><strong>守护线程</strong>，如：垃圾回收线程，依赖于主线程而存在<br><strong>用户线程</strong>，如：main方法的线程</p>
<h3 id="Thread生命周期"><a href="#Thread生命周期" class="headerlink" title="Thread生命周期"></a>Thread生命周期</h3><blockquote>
<p><strong>线程的五种状态：</strong></p>
</blockquote>
<ul>
<li><strong>新建</strong>：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li><strong>就绪</strong>：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li><strong>运行</strong>：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能</li>
<li><strong>阻塞</strong>：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态</li>
<li><strong>死亡</strong>：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2C9O54"><img src="https://z3.ax1x.com/2021/05/26/2C9O54.png" alt="2C9O54.png"></a></p>
<blockquote>
<p><strong>说明：</strong>  </p>
</blockquote>
<p><strong>生命周期关注两个概念</strong>：状态、相应的方法</p>
<p><strong>关注</strong>：状态a–&gt;状态b:哪些方法执行了（回调方法） 某个方法主动调用：状态a–&gt;状态b</p>
<p><strong>阻塞</strong>：临时状态，不可以作为最终状态</p>
<p><strong>死亡</strong>：最终状态。</p>
<h2 id="线程的同步机制"><a href="#线程的同步机制" class="headerlink" title="线程的同步机制"></a>线程的同步机制</h2><p><em><strong>例子</strong></em>：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式</p>
<p><strong>问题</strong>：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题<br><strong>问题出现的原因</strong>：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。<br><strong>如何解决</strong>：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</p>
<blockquote>
<p><strong>在Java中，我们通过同步机制，来解决线程的安全问题。</strong></p>
</blockquote>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><h4 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(同步监视器)&#123;//同步监视器就是需要同步线程的公共对象</span><br><span class="line">   //需要被同步的代码</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>  </p>
</blockquote>
<ol>
<li>操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。</li>
<li><strong>共享数据</strong>：多个线程共同操作的变量。比如：ticket就是共享数据。</li>
<li>同步监视器，俗称：<strong>锁</strong>。任何一个类的对象，都可以充当锁。</li>
<li>要求多个线程必须要<strong>共用</strong>同一把锁。</li>
</ol>
<ul>
<li><p>在实现<code>Runnable接口</code>创建多线程的方式中，我们可以考虑使用<code>this</code>充当同步监视器。</p>
</li>
<li><p>在继承<code>Thread类</code>创建多线程的方式中，慎用<code>this</code>充当同步监视器，考虑使用当前类充当同步监视器。</p>
</li>
</ul>
<blockquote>
<p><strong>代码示例：</strong></p>
</blockquote>
<ul>
<li><em><strong>继承Runnable接口形式同步代码块</strong></em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Ticket implements Runnable &#123;</span><br><span class="line">    private int tick = 100;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (tick &gt; 0) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;号窗口买票，票号为：&quot; + tick--);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TicketTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket ticket = new Ticket();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(ticket);</span><br><span class="line">        Thread thread2 = new Thread(ticket);</span><br><span class="line">        Thread thread3 = new Thread(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(&quot;窗口1&quot;);</span><br><span class="line">        thread2.setName(&quot;窗口2&quot;);</span><br><span class="line">        thread3.setName(&quot;窗口3&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><em><strong>继承Thread类形式同步代码块</strong></em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Ticket2 extends Thread &#123;</span><br><span class="line">    private static int tick = 100;</span><br><span class="line">    private static Object object = new Object();</span><br><span class="line"></span><br><span class="line">    public Ticket2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (object) &#123;</span><br><span class="line">            //synchronized (Ticket2.class) &#123;//通过反射调用当前类</span><br><span class="line">                if (tick &gt; 0) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;号窗口买票，票号为&quot; + tick--);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TicketTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket2 ticket1 = new Ticket2();</span><br><span class="line">        Ticket2 ticket2 = new Ticket2();</span><br><span class="line">        Ticket2 ticket3 = new Ticket2();</span><br><span class="line"></span><br><span class="line">        ticket1.setName(&quot;窗口1&quot;);</span><br><span class="line">        ticket2.setName(&quot;窗口2&quot;);</span><br><span class="line">        ticket3.setName(&quot;窗口3&quot;);</span><br><span class="line"></span><br><span class="line">        ticket1.start();</span><br><span class="line">        ticket2.start();</span><br><span class="line">        ticket3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h4>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void show(String namer)&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>代码示例：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Ticket3 implements Runnable &#123;</span><br><span class="line">    private int tick = 100;</span><br><span class="line">    private boolean isFlag = true;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (isFlag) &#123;</span><br><span class="line">            show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void show() &#123;//同步show方法，继承Thread类方法一样，只需同步方法即可，同时需要给方法加static关键字，确保不会创建多个对象</span><br><span class="line">        if (tick &gt; 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;号窗口买票，票号为：&quot; + tick--);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isFlag = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TicketTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket3 ticket = new Ticket3();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(ticket);</span><br><span class="line">        Thread thread2 = new Thread(ticket);</span><br><span class="line">        Thread thread3 = new Thread(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(&quot;窗口1&quot;);</span><br><span class="line">        thread2.setName(&quot;窗口2&quot;);</span><br><span class="line">        thread3.setName(&quot;窗口3&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式三：Lock锁-—-JDK-5-0新增"><a href="#方式三：Lock锁-—-JDK-5-0新增" class="headerlink" title="方式三：Lock锁 — JDK 5.0新增"></a>方式三：Lock锁 — JDK 5.0新增</h4></li>
<li>从JDK 5.0开始，Java提供了更强大的线程同步机制–<strong>通过显式定义同步锁对象来实现同步</strong>。同步锁使用<code>Lock对象</code>充当。</li>
<li><code>java.util.concurrent.locks.Lock接口</code>是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对<code>Lock对象</code>加锁，线程开始访问共享资源之前应先获得<code>Lock对象</code>。</li>
<li><code>ReentrantLock类</code>实现了<code>Lock</code>，它拥有与 <code>synchronized</code>相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 <code>Reentrantlock</code>，可以显式加锁、释放锁。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    //1.实例化ReentrantLock对象</span><br><span class="line">    private final ReenTrantLock lock = new ReenTrantLook();</span><br><span class="line">    public void m ()&#123;</span><br><span class="line">        lock.lock//2.先加锁</span><br><span class="line">        try&#123;</span><br><span class="line">            //保证线程同步的代码</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            lock.unlock();//3.后解锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注意：如果同步代码块有异常，要将unlock()写入finally语句块中</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>代码示例：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Window implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private int ticket = 100;</span><br><span class="line">    //1.实例化ReentrantLock</span><br><span class="line">    private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line"></span><br><span class="line">                //2.调用锁定方法lock()</span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                if(ticket &gt; 0)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                //3.调用解锁方法：unlock()</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LockTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Window w = new Window();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(w);</span><br><span class="line">        Thread t2 = new Thread(w);</span><br><span class="line">        Thread t3 = new Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(&quot;窗口1&quot;);</span><br><span class="line">        t2.setName(&quot;窗口2&quot;);</span><br><span class="line">        t3.setName(&quot;窗口3&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步方法的总结"><a href="#同步方法的总结" class="headerlink" title="同步方法的总结"></a>同步方法的总结</h3><p>对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他仼务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p>
<h4 id="synchronized的锁是什么"><a href="#synchronized的锁是什么" class="headerlink" title="synchronized的锁是什么"></a>synchronized的锁是什么</h4></li>
</ul>
<ol>
<li><strong>任意对象</strong>都可以作为<code>同步锁</code>。<strong>所有对象</strong>都自动含有单一的锁（<code>监视器</code>）</li>
<li><strong>同步方法的锁</strong>：静态方法（<code>类名.class</code>）、非静态方法（this）</li>
<li><strong>同步代码块</strong>：自己指定，很多时候也是指定为<code>this</code>或<code>类名.class</code></li>
</ol>
<blockquote>
<p><strong>注意点</strong></p>
</blockquote>
<ol>
<li><p>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全</p>
</li>
<li><p>一个线程类中的<strong>所有静态方法</strong>共用同一把锁（<code>类名.class</code>），<strong>所有非静态方法</strong>共用同一把锁（<code>this</code>），同步代码块（指定需谨慎）</p>
</li>
<li><p>同步方法仍然涉及到<strong>同步监视器</strong>，只是不需要我们显式的声明。</p>
</li>
<li><p><strong>非静态的同步方法</strong>，同步监视器是：<code>this</code></p>
</li>
<li><p><strong>静态的同步方法</strong>，同步监视器是：<code>当前类本身</code></p>
</li>
</ol>
<h3 id="同步的范围"><a href="#同步的范围" class="headerlink" title="同步的范围"></a>同步的范围</h3><blockquote>
<p><strong>如何找问题，即代码是否存在线程安全？<em>（非常重要)</em></strong></p>
</blockquote>
<ol>
<li><p>明确哪些代码是多线程运行的代码</p>
</li>
<li><p>明确多个线程是否有共享数据</p>
</li>
<li><p>明确多线程运行代码中是否有多条语句操作共享数据</p>
</li>
</ol>
<blockquote>
<p><strong>如何解决呢？（<em>非常重要</em>）</strong><br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 即所有操作共享数据的这些语句都要放在同步范围中</p>
</blockquote>
<blockquote>
<p><strong>注意点</strong></p>
</blockquote>
<p><strong>范围太小</strong>：没锁住所有有安全问题的代码   </p>
<p><strong>范围太大</strong>：没发挥多线程的功能。</p>
<h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><h4 id="synchronized-与-Lock的异同？"><a href="#synchronized-与-Lock的异同？" class="headerlink" title="synchronized 与 Lock的异同？"></a>synchronized 与 Lock的异同？</h4><ol>
<li><p><strong>相同</strong>：二者都可以解决线程安全问题</p>
</li>
<li><p><strong>不同</strong>：<code>synchronized机制</code>在执行完相应的同步代码以后，自动的释放同步监视器</p>
</li>
<li><p><code>Lock</code>需要手动的启动同步（<code>lock()</code>，同时结束同步也需要手动的实现（<code>unlock()</code>）</p>
</li>
<li><p><strong>使用的优先顺序</strong>：<br><code>Lock</code>—&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) —&gt;同步方法（在方法体之外)</p>
</li>
<li><p><strong>利弊</strong>： 同步的方式，解决了线程的安全问题。—好处 操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</p>
</li>
</ol>
<h4 id="Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同"><a href="#Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同" class="headerlink" title="Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同"></a>Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</h4><p>利用同步锁的方式，有三种方式:<code>同步代码块</code>、<code>同步方法</code>和用<code>lock方法</code></p>
<h4 id="synchronized和Lock方式解决线程安全问题的对比"><a href="#synchronized和Lock方式解决线程安全问题的对比" class="headerlink" title="synchronized和Lock方式解决线程安全问题的对比"></a>synchronized和Lock方式解决线程安全问题的对比</h4><ul>
<li><strong>相同</strong>：二者都可以解决线程安全问题</li>
<li><strong>不同</strong>：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器</li>
<li>Lock需要手动的启动同步（<code>lock()</code>，同时结束同步也需要手动的实现（<code>unlock()</code>）</li>
</ul>
<h3 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">使用同步机制将单例模式中的懒汉式改写为线程安全的。</span><br><span class="line"></span><br><span class="line">class Bank&#123;</span><br><span class="line"></span><br><span class="line">    private Bank()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static Bank instance = null;</span><br><span class="line"></span><br><span class="line">    public static Bank getInstance()&#123;</span><br><span class="line">        //方式一：效率稍差</span><br><span class="line">//        synchronized (Bank.class) &#123;</span><br><span class="line">//            if(instance == null)&#123;</span><br><span class="line">//</span><br><span class="line">//                instance = new Bank();</span><br><span class="line">//            &#125;</span><br><span class="line">//            return instance;</span><br><span class="line">//        &#125;</span><br><span class="line">        //方式二：效率更高</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line"></span><br><span class="line">            synchronized (Bank.class) &#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line"></span><br><span class="line">                    instance = new Bank();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><ol>
<li><p><strong>死锁的理解</strong>：<br>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p>
</li>
<li><p><strong>说明</strong>：</p>
</li>
</ol>
<ul>
<li>出现死锁后，不会出现异常，不会出现提示，只是所的线程都处于<code>阻塞状态</code>，无法继续</li>
<li>我们使用同步时，要避免出现死锁。</li>
</ul>
<blockquote>
<p><strong>举例</strong>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuffer s1 = new StringBuffer();</span><br><span class="line">    StringBuffer s2 = new StringBuffer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    new Thread()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (s1)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(&quot;a&quot;);</span><br><span class="line">                s2.append(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                synchronized (s2)&#123;</span><br><span class="line">                    s1.append(&quot;b&quot;);</span><br><span class="line">                    s2.append(&quot;2&quot;);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (s2)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(&quot;c&quot;);</span><br><span class="line">                s2.append(&quot;3&quot;);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                synchronized (s1)&#123;</span><br><span class="line">                    s1.append(&quot;d&quot;);</span><br><span class="line">                    s2.append(&quot;4&quot;);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h2><p>为了解决线程的死锁问题，引入<code>线程通讯</code></p>
<h3 id="线程通信设计到的三个方法"><a href="#线程通信设计到的三个方法" class="headerlink" title="线程通信设计到的三个方法"></a>线程通信设计到的三个方法</h3><p>-<code> wait()</code>:一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</p>
<ul>
<li><code>notify()</code>:一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</li>
<li><code>notifyAll()</code>:一旦执行此方法，就会唤醒所有被wait的线程。</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>wait()，notify()，notifyAll()三个方法必须使用在<strong>同步代码块</strong>或<strong>同步方法</strong>中。</p>
</li>
<li><p>ait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。<br>否则，会出现<strong>IllegalMonitorStateException异常</strong></p>
</li>
<li><p>wait()，notify()，notifyAll()三个方法是定义在<strong>java.lang.Object类</strong>中。</p>
</li>
</ul>
<blockquote>
<p>代码示例：</p>
</blockquote>
<p>使用两个线程打印 1-100，线程1, 线程2 交替打印。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line">    private int number = 1;</span><br><span class="line">    private Object object = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (object) &#123;</span><br><span class="line">                object.notify();//调用notify()方法唤醒线程</span><br><span class="line">                if (number &lt;= 100) &#123;</span><br><span class="line">                    //线程休眠</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        object.wait();//打印输出一次后调用wait()方法将线程阻塞</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CommunicationTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(myThread);</span><br><span class="line">        Thread thread2 = new Thread(myThread);</span><br><span class="line"></span><br><span class="line">        thread1.setName(&quot;线程1:&quot;);</span><br><span class="line">        thread2.setName(&quot;线程2:&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><blockquote>
<p><strong>sleep() 和 wait()的异同？</strong>  </p>
</blockquote>
<ul>
<li><p><strong>相同点</strong>：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p>
</li>
<li><p><strong>不同点</strong>：<br>1）两个方法声明的位置不同：<code>Thread类</code>中声明<code>sleep()</code> , <code>Object类</code>中声明<code>wait()</code><br>2）调用的要求不同：<code>sleep()</code>可以在任何需要的场景下调用。 <code>wait()</code>必须使用在同步代码块或同步方法中<br>3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，<code>sleep()</code>不会释放锁，<code>wait()</code>会释放锁。</p>
</li>
</ul>
<h3 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h3><ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步代码块、同步方法中遇到 break、 return终止了该代码块该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或 Exception，导致异常结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的 wait()方法，当前线程暂停，并释放锁</li>
</ul>
<h3 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h3><ul>
<li>线程执行同步代码块或同步方法时，程序调用 Thread. sleep()、Thread yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的 suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）</li>
<li>应尽量避免使用 suspend()和 resume()来控制线程</li>
</ul>
<h2 id="JDK5-0新增线程创建方式"><a href="#JDK5-0新增线程创建方式" class="headerlink" title="JDK5.0新增线程创建方式"></a>JDK5.0新增线程创建方式</h2><h3 id="新增方式一：实现Callable接口"><a href="#新增方式一：实现Callable接口" class="headerlink" title="新增方式一：实现Callable接口"></a>新增方式一：实现Callable接口</h3><blockquote>
<p><strong>实现方式：</strong></p>
</blockquote>
<ol>
<li><p>创建一个实现<code>Callable的实现类</code></p>
</li>
<li><p>实现<code>call方法</code>，将此线程需要执行的操作声明在<code>call()</code>中</p>
</li>
<li><p>创建<code>Callable接口</code>实现类的对象</p>
</li>
<li><p>将此<code>Callable</code>接口实现类的对象作为传递到<code>FutureTask构造器</code>中，创建<code>FutureTask的对象</code></p>
</li>
<li><p>将<code>FutureTask的对象</code>作为参数传递到<code>Thread类</code>的构造器中，创建<code>Thread对象</code>，并调用s<code>tart()</code></p>
</li>
<li><p>获取<code>Callable</code>中<code>call方法</code>的返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个实现Callable的实现类</span><br><span class="line">class NumThread implements Callable&#123;</span><br><span class="line">    //2.实现call方法，将此线程需要执行的操作声明在call()中</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">            if(i % 2 == 0)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadNew &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //3.创建Callable接口实现类的对象</span><br><span class="line">        NumThread numThread = new NumThread();</span><br><span class="line">        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span><br><span class="line">        FutureTask futureTask = new FutureTask(numThread);</span><br><span class="line">        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //6.获取Callable中call方法的返回值</span><br><span class="line">            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(&quot;总和为：&quot; + sum);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何理解实现<strong>Callable接口</strong>的方式创建多线程比实现<strong>Runnable接口</strong>创建多线程方式强大？</p>
</blockquote>
</li>
<li><p><strong>call()</strong> 可以返回值的。</p>
</li>
<li><p><strong>call()</strong> 可以抛出异常，被外面的操作捕获，获取异常的信息</p>
</li>
<li><p><strong>Callable</strong>是支持泛型的</p>
</li>
</ol>
<h3 id="新增方式二：使用线程池"><a href="#新增方式二：使用线程池" class="headerlink" title="新增方式二：使用线程池"></a>新增方式二：使用线程池</h3><p>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程对性能影响很大。</p>
<blockquote>
<p><strong>解决方案：</strong></p>
</blockquote>
<p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<blockquote>
<p><strong>实现方法：</strong></p>
</blockquote>
<ol>
<li><p>提供指定线程数量的线程池</p>
</li>
<li><p>执行指定的线程的操作。需要提供实现<code>Runnable接口</code>或<code>Callable接口</code>实现类的对象</p>
</li>
<li><p>关闭连接池</p>
</li>
</ol>
<blockquote>
<p><strong>相关API：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JDK 5.0起提供了线程池相关AP|： Executor Service和 Executors</span><br><span class="line"></span><br><span class="line">Executor Service：真正的线程池接口。常见子类 Thread Poolexecutor</span><br><span class="line">void execute(Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit（Callable&lt;T&gt;task）：执行任务，有返回值，一般又来执行Callable</span><br><span class="line">void shutdown()：关闭连接池</span><br><span class="line"></span><br><span class="line">Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</span><br><span class="line">Executors. newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</span><br><span class="line">Executors.newFⅸedthreadPool(n)；创建一个可重用固定线程数的线程池</span><br><span class="line">EXecutors. newSingleThreadEXecutor()：创建一个只有一个线程的线程池</span><br><span class="line">Executors. new thread Poo(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>代码示例：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class NumberThread implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0;i &lt;= 100;i++)&#123;</span><br><span class="line">            if(i % 2 == 0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NumberThread1 implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0;i &lt;= 100;i++)&#123;</span><br><span class="line">            if(i % 2 != 0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadPool &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1. 提供指定线程数量的线程池</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        //设置线程池的属性</span><br><span class="line">//        System.out.println(service.getClass());</span><br><span class="line">//        service1.setCorePoolSize(15);</span><br><span class="line">//        service1.setKeepAliveTime();</span><br><span class="line"></span><br><span class="line">        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span><br><span class="line">        service.execute(new NumberThread());//适合适用于Runnable</span><br><span class="line">        service.execute(new NumberThread1());//适合适用于Runnable</span><br><span class="line"></span><br><span class="line">//        service.submit(Callable callable);//适合使用于Callable</span><br><span class="line">        //3.关闭连接池</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>应用线程池的好处：</strong></p>
</blockquote>
<ol>
<li><p>提高响应速度（减少了创建新线程的时间）</p>
</li>
<li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
</li>
<li><p>便于线程管理</p>
</li>
</ol>
<ul>
<li><code>corePoolSize</code>：核心池的大小  </li>
<li><code>maximumPoolSize</code>：最大线程数  </li>
<li><code>keepAliveTime</code>：线程没任务时最多保持多长时间后会终止</li>
</ul>
<blockquote>
<p><strong>面试题：Java中多线程的创建有几种方式？四种。</strong></p>
</blockquote>
<ul>
<li>JDK 5.0以前：</li>
</ul>
<ol>
<li>即继承Thread类重run方法</li>
<li>实现Runnable接口实现run方法</li>
</ol>
<ul>
<li>JDK 5.0以后：</li>
</ul>
<ol start="3">
<li>实现callable接口，实现call方法</li>
<li>利用线程池</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> Java基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/" rel="prev" title="Java基础（四）">
      <i class="fa fa-chevron-left"></i> Java基础（四）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="JDBC学习笔记">
      JDBC学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">Java基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">语言概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java语言特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E3%80%81JRE%E3%80%81JVM%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.2.</span> <span class="nav-text">JDK、JRE、JVM的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">1.2.1.</span> <span class="nav-text">关键字与标识符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">标识符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">变量的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">异常的体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">2.1.1.</span> <span class="nav-text">java中异常类的继承关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">异常的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Atry-catch-finally"><span class="nav-number">2.2.1.</span> <span class="nav-text">异常的处理方式一：try-catch-finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Athrows"><span class="nav-number">2.2.2.</span> <span class="nav-text">异常的处理方式二：throws</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.3.</span> <span class="nav-text">对比两种处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BA%94%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.2.4.</span> <span class="nav-text">开发中应该选择哪种处理方式？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">2.3.</span> <span class="nav-text">手动抛出异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">3.</span> <span class="nav-text">面向对象三大特征</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">封装性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E5%B0%81%E8%A3%85%E6%80%A7"><span class="nav-number">3.1.1.</span> <span class="nav-text">为什么引入封装性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">封装性代码的具体体现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%A7%84%E5%AE%9A%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">3.1.3.</span> <span class="nav-text">Java规定的四种权限修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">继承性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">继承性的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%90%8E%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C"><span class="nav-number">3.2.2.</span> <span class="nav-text">子类继承父类后有哪些不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">3.2.3.</span> <span class="nav-text">Java继承类的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">3.2.4.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-lang-Object%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">java.lang.Object类的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-lang-Object%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">java.lang.Object类的说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals-%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">equals()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toString%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">toString方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.5.</span> <span class="nav-text">子类对象实例化全过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-number">3.3.</span> <span class="nav-text">多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">3.3.1.</span> <span class="nav-text">多态性的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E4%B8%BA%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-number">3.3.2.</span> <span class="nav-text">何为多态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">3.3.3.</span> <span class="nav-text">多态性的使用：虚拟方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">多态性使用前提</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">多态性使用的注意点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">多态使用总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E4%B8%8E%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">3.3.4.</span> <span class="nav-text">向上转型与向下转型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">为什么使用向下转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">如何实现向下转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">3.3.4.3.</span> <span class="nav-text">使用时的注意点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.4.4.</span> <span class="nav-text">instanceof的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">3.3.4.5.</span> <span class="nav-text">面试题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.1.</span> <span class="nav-text">类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">面向对象与面向过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.2.</span> <span class="nav-text">类与对象的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">4.1.3.</span> <span class="nav-text">面向对象思想实现的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.1.4.</span> <span class="nav-text">匿名对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B1%9E%E6%80%A7"><span class="nav-number">4.2.</span> <span class="nav-text">类的结构之一：属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7vs%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text">属性vs局部变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">类的结构之二：方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">4.3.1.</span> <span class="nav-text">方法的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">方法的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">4.3.3.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.4.</span> <span class="nav-text">可变个数形参方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">4.3.5.</span> <span class="nav-text">Java的值传递机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">4.3.6.</span> <span class="nav-text">方法的重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.3.6.1.</span> <span class="nav-text">重写的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E4%B8%BE%E4%BE%8B"><span class="nav-number">4.3.6.2.</span> <span class="nav-text">重写举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">4.3.6.3.</span> <span class="nav-text">重写的规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">4.4.</span> <span class="nav-text">类的结构之三：构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">4.4.1.</span> <span class="nav-text">使用说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">4.4.2.</span> <span class="nav-text">构造器举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.4.3.</span> <span class="nav-text">属性赋值顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaBean%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">4.4.4.</span> <span class="nav-text">JavaBean的概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">4.5.</span> <span class="nav-text">类的结构之四：代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.5.1.</span> <span class="nav-text">代码块的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">4.5.2.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.5.3.</span> <span class="nav-text">属性的赋值顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%94%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.6.</span> <span class="nav-text">类的结构之五：内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.6.1.</span> <span class="nav-text">内部类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">4.6.2.</span> <span class="nav-text">内部类的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">4.6.3.</span> <span class="nav-text">成员内部类的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.6.4.</span> <span class="nav-text">成员内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9F-%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%8C%E9%9D%9E%E9%9D%99%E6%80%81%E7%9A%84"><span class="nav-number">4.6.4.1.</span> <span class="nav-text">如何创建成员内部类的对象？(静态的，非静态的)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">4.6.4.2.</span> <span class="nav-text">如何在成员内部类中调用外部类的结构？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.6.5.</span> <span class="nav-text">局部内部类的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-1"><span class="nav-number">5.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#return%E2%80%93%E8%B7%B3%E5%87%BA"><span class="nav-number">5.1.</span> <span class="nav-text">return–跳出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E2%80%93%E6%9C%AC%E7%B1%BB%E7%9A%84"><span class="nav-number">5.2.</span> <span class="nav-text">this–本类的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.1.</span> <span class="nav-text">this调用属性、方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">this调用构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super%E2%80%93%E7%88%B6%E7%B1%BB%E7%9A%84"><span class="nav-number">5.3.</span> <span class="nav-text">super–父类的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.3.1.</span> <span class="nav-text">super关键字的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#super%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">super调用属性、方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%AD%90%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">在子类的方法或构造器中使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">super调用构造器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.2.</span> <span class="nav-text">this和super的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#package-x2F-import"><span class="nav-number">5.4.</span> <span class="nav-text">package&#x2F;import</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E7%BB%93%E6%9E%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">5.4.1.</span> <span class="nav-text">包结构应用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%85%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.4.2.</span> <span class="nav-text">JDK中的主要包介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.4.3.</span> <span class="nav-text">import的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E2%80%93%E9%9D%99%E6%80%81%E7%9A%84"><span class="nav-number">5.5.</span> <span class="nav-text">static–静态的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8"><span class="nav-number">5.5.1.</span> <span class="nav-text">static关键字使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7%EF%BC%9A%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E6%88%96%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">static修饰属性：静态变量（或类变量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">5.5.1.2.</span> <span class="nav-text">static修饰方法：静态方法、类方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">5.5.1.3.</span> <span class="nav-text">如何判定属性和方法应该使用static关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.5.2.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">5.5.2.1.</span> <span class="nav-text">设计模式的说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">5.5.2.2.</span> <span class="nav-text">单例模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final%E2%80%93%E6%9C%80%E7%BB%88%E7%9A%84"><span class="nav-number">5.6.</span> <span class="nav-text">final–最终的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abstract%E2%80%93%E6%8A%BD%E8%B1%A1%E7%9A%84"><span class="nav-number">5.7.</span> <span class="nav-text">abstract–抽象的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#abstract%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.7.1.</span> <span class="nav-text">abstract关键字的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.7.2.</span> <span class="nav-text">模板方法的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">5.7.2.1.</span> <span class="nav-text">应用举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.7.2.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interface%E2%80%93%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.8.</span> <span class="nav-text">interface–接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interface%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">5.8.1.</span> <span class="nav-text">interface关键字使用说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java8%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3%E6%96%B0%E8%A7%84%E8%8C%83"><span class="nav-number">5.8.2.</span> <span class="nav-text">Java8中关于接口新规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="nav-number">5.8.3.</span> <span class="nav-text">面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.8.4.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">5.8.4.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%B1%BB-1"><span class="nav-number">5.8.4.2.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.8.5.</span> <span class="nav-text">工厂的设计模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.1.</span> <span class="nav-text">程序、进程、线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.1.1.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.2.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.1.3.</span> <span class="nav-text">线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">6.2.</span> <span class="nav-text">并行与并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%A0%B8CPU%E5%92%8C%E5%A4%9A%E6%A0%B8CPU"><span class="nav-number">6.2.1.</span> <span class="nav-text">单核CPU和多核CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">6.2.2.</span> <span class="nav-text">并行与并发的理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.3.</span> <span class="nav-text">为什么要使用多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E7%82%B9"><span class="nav-number">6.3.1.</span> <span class="nav-text">多线程优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">6.3.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E7%B1%BB"><span class="nav-number">6.4.</span> <span class="nav-text">Thread类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">6.4.1.</span> <span class="nav-text">Thread类的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">6.4.2.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">6.4.3.</span> <span class="nav-text">创建多线程的两种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">6.4.3.1.</span> <span class="nav-text">方式一继承Thread类的方式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">6.4.3.2.</span> <span class="nav-text">方式二实现Runnable接口的方式：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.4.4.</span> <span class="nav-text">Thread类的常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">6.4.4.1.</span> <span class="nav-text">常用方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">6.4.4.2.</span> <span class="nav-text">线程的优先级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.4.5.</span> <span class="nav-text">Thread生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">6.5.</span> <span class="nav-text">线程的同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">6.5.1.</span> <span class="nav-text">同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">方式一：同步代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">6.5.1.2.</span> <span class="nav-text">方式二：同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9ALock%E9%94%81-%E2%80%94-JDK-5-0%E6%96%B0%E5%A2%9E"><span class="nav-number">6.5.1.3.</span> <span class="nav-text">方式三：Lock锁 — JDK 5.0新增</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">6.5.2.</span> <span class="nav-text">同步方法的总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E7%9A%84%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.5.2.1.</span> <span class="nav-text">synchronized的锁是什么</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">6.5.3.</span> <span class="nav-text">同步的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-2"><span class="nav-number">6.5.4.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E4%B8%8E-Lock%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="nav-number">6.5.4.1.</span> <span class="nav-text">synchronized 与 Lock的异同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%8C%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%B9%B6%E5%AF%B9%E6%AF%94%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">6.5.4.2.</span> <span class="nav-text">Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%92%8CLock%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">6.5.4.3.</span> <span class="nav-text">synchronized和Lock方式解决线程安全问题的对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.5.5.</span> <span class="nav-text">线程安全的单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.6.</span> <span class="nav-text">死锁问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="nav-number">6.6.</span> <span class="nav-text">线程通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1%E5%88%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">6.6.1.</span> <span class="nav-text">线程通信设计到的三个方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">6.6.2.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-3"><span class="nav-number">6.6.3.</span> <span class="nav-text">面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">6.6.4.</span> <span class="nav-text">释放锁的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">6.6.5.</span> <span class="nav-text">不会释放锁的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">6.7.</span> <span class="nav-text">JDK5.0新增线程创建方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.7.1.</span> <span class="nav-text">新增方式一：实现Callable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.7.2.</span> <span class="nav-text">新增方式二：使用线程池</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

