<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="凤凰于飞，翙翙其羽，远去无痕迹。听梧桐细雨，瑟瑟其叶，随风摇记忆">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记（二）">
<meta property="og:url" content="https://aeowind.github.io/2022/03/04/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="凤凰于飞，翙翙其羽，远去无痕迹。听梧桐细雨，瑟瑟其叶，随风摇记忆">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-04T12:46:25.412Z">
<meta property="article:modified_time" content="2021-07-05T06:16:27.057Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aeowind.github.io/2022/03/04/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM学习笔记（二） | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>movies</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>books</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/04/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM学习笔记（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 20:46:25" itemprop="dateCreated datePublished" datetime="2022-03-04T20:46:25+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-05 14:16:27" itemprop="dateModified" datetime="2021-07-05T14:16:27+08:00">2021-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">凤凰于飞，翙翙其羽，远去无痕迹。听梧桐细雨，瑟瑟其叶，随风摇记忆</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="jvm-性能调优">JVM 性能调优</h1>
<p>在高性能硬件上部署程序，目前主要有<code>两种方式</code>：</p>
<ul>
<li>通过 64 位 JDK 来使用大内存；</li>
<li>使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。</li>
</ul>
<h2 id="使用-64-位-jdk-管理大内存">使用 64 位 JDK 管理大内存</h2>
<p>堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。
如果堆内存为 14 G，那么每次 Full GC 将长达数十秒。如果 Full GC
频繁发生，那么对于一个网站来说是无法忍受的。</p>
<p>对于用户交互性强、对停顿时间敏感的系统，可以给 Java
虚拟机分配超大堆的前提是有把握把应用程序的 Full GC
频率控制得足够低，至少要低到不会影响用户使用。</p>
<p><code>可能面临的问题：</code></p>
<ul>
<li>内存回收导致的长时间停顿；</li>
<li>现阶段，64 位 JDK 的性能普遍比 32 位 JDK 低；</li>
<li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生超过
10GB 的 Dump 文件），哪怕产生了快照也几乎无法进行分析；</li>
<li>相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK
大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。</li>
</ul>
<h2 id="使用-32-位-jvm-建立逻辑集群">使用 32 位 JVM 建立逻辑集群</h2>
<p>在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口，
然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</p>
<p>考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性能需求，
也不需要保证每个虚拟机进程有绝对的均衡负载，因此使用无 Session
复制的亲合式集群是一个不错的选择。
我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据
SessionID 分配）
将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可。</p>
<p><code>可能遇到的问题</code>：</p>
<ul>
<li>尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致
IO 异常；</li>
<li>很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余；</li>
<li>各个节点受到 32 位的内存限制；</li>
<li>大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。</li>
</ul>
<h2 id="调优案例分析与实战">调优案例分析与实战</h2>
<h3 id="场景描述">场景描述</h3>
<p>一个小型系统，使用 32 位 JDK，4G
内存，测试期间发现服务端不定时抛出内存溢出异常。 加入
<code>-XX:+HeapDumpOnOutOfMemoryError</code>（添加这个参数后，堆内存溢出时就会输出异常日志），
但再次发生内存溢出时，没有生成相关异常日志。</p>
<h3 id="分析">分析</h3>
<p>在 32 位 JDK 上，1.6G 分配给堆，还有一部分分配给 JVM
的其他内存，直接内存最大也只能在剩余的 0.4G 空间中分出一部分，
如果使用了 NIO，JVM 会在 JVM
内存之外分配内存空间，那么就要小心“直接内存”不足时发生内存溢出异常了。</p>
<h3 id="直接内存的回收过程">直接内存的回收过程</h3>
<p>直接内存虽然不是 JVM 内存空间，但它的垃圾回收也由 JVM 负责。</p>
<p>垃圾收集进行时，虚拟机虽然会对直接内存进行回收，
但是直接内存却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，
它只能等老年代满了后 Full GC，然后“顺便”帮它清理掉内存的废弃对象。
否则只能一直等到抛出内存溢出异常时，先 catch 掉，再在 catch 块里大喊
“<code>System.gc()</code>”。
要是虚拟机还是不听，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。</p>
<h1 id="类文件结构">类文件结构</h1>
<h2 id="jvm-的无关性">JVM 的“无关性”</h2>
<p>谈论 <code>JVM 的无关性</code>，主要有以下两个：</p>
<ul>
<li><strong>平台无关性</strong>：任何操作系统都能运行 Java 代码</li>
<li><strong>语言无关性</strong>： JVM 能运行除 Java 以外的其他代码</li>
</ul>
<p><strong>Java 源代码</strong>首先需要使用 Javac
编译器<strong>编译</strong>成 .class 文件，然后由 JVM
<strong>执行</strong> .class 文件，从而程序开始运行。</p>
<p>JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要
.class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala
等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器
都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM
运行它们。</p>
<blockquote>
<p>Java
语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，
因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。
因此，有一些 Java
语言本身无法有效支持的语言特性，不代表字节码本身无法有效支持。</p>
</blockquote>
<h2 id="class-文件结构">Class 文件结构</h2>
<p><strong>Class
文件</strong>是<code>二进制文件</code>，它的内容具有严格的规范，文件中没有任何空格，全都是连续的
0/1。Class 文件 中的所有内容被分为两种类型：无符号数、表。</p>
<ul>
<li><code>无符号数</code> 无符号数表示 Class
文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8 分别代表
1/2/4/8 字节的无符号数。</li>
<li><code>表</code>
由多个无符号数或者其他表作为数据项构成的复合数据类型。</li>
</ul>
<p><code>Class 文件</code>具体由以下几个<strong>构成</strong>:</p>
<ul>
<li>魔数</li>
<li>版本信息</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引、父类索引、接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
<h3 id="魔数">魔数</h3>
<p>Class 文件的<strong>头 4
个字节</strong>称为<code>魔数</code>，用来表示这个 Class
文件的类型。</p>
<p>Class 文件的魔数是用 16 进制表示的“CAFE
BABE”，是不是很具有浪漫色彩？</p>
<blockquote>
<p>魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class
文件中标识文件类型比较合适。</p>
</blockquote>
<h3 id="版本信息">版本信息</h3>
<p>紧接着魔数的 4 个字节是版本信息，<strong>5-6 字节表示次版本号，7-8
字节表示主版本号</strong>，它们表示当前 Class 文件中使用的是哪个版本的
JDK。</p>
<p>高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的
Class
文件，即使文件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的
Class 文件。</p>
<h3 id="常量池">常量池</h3>
<p>版本信息之后就是常量池，常量池中存放两种类型的常量：</p>
<ul>
<li><p><strong>字面值常量</strong></p>
<p>字面值常量就是我们在程序中定义的字符串、被 final 修饰的值。</p></li>
<li><p><strong>符号引用</strong></p>
<p>符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。</p></li>
</ul>
<h4 id="常量池的特点">常量池的特点</h4>
<ul>
<li>常量池中常量数量不固定，因此常量池开头放置一个 u2
类型的无符号数，用来存储当前常量池的容量。</li>
<li>常量池的每一项常量都是一个表，表开始的第一位是一个 u1
类型的标志位（tag），代表当前这个常量属于哪种常量类型。</li>
</ul>
<h4 id="常量池中常量类型">常量池中常量类型</h4>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>tag</th>
<th>描述　</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8 编码的字符串</td>
</tr>
<tr class="even">
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr class="odd">
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr class="even">
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr class="odd">
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr class="even">
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr class="odd">
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr class="even">
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr class="odd">
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr class="even">
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr class="odd">
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr class="even">
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr class="odd">
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标识方法类型</td>
</tr>
<tr class="even">
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<p>对于
CONSTANT_Class_info（此类型的常量代表一个类或者接口的符号引用），它的二维表结构如下：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr class="even">
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>tag 是标志位，用于区分常量类型；name_index
是一个索引值，它指向常量池中一个 CONSTANT_Utf8_info
类型常量，此常量代表这个类（或接口）的全限定名，这里 name_index 值若为
0x0002，也即是指向了常量池中的第二项常量。</p>
<p>CONSTANT_Utf8_info 型常量的结构如下：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr class="even">
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr class="odd">
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody>
</table>
<p>tag 是当前常量的类型；length 表示这个字符串的长度；bytes
是这个字符串的内容（采用缩略的 UTF8 编码）</p>
<h3 id="访问标志">访问标志</h3>
<p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个
Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final
修饰。</p>
<h3 id="类索引父类索引接口索引集合">类索引、父类索引、接口索引集合</h3>
<p>类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2
类型的数据的集合，Class
文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>
<p>由于 Java 不允许多重继承，所以父类索引只有一个，除了 java.lang.Object
之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java
类的父类索引都不为
0。一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为
u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。</p>
<p>类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为
CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在
CONSTANT_Utf8_info 类型的常量中的全限定名字符串。</p>
<h3 id="字段表集合">字段表集合</h3>
<p>字段表集合存储本类涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量。</p>
<p>每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。字段表结构如下：</p>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u2</td>
<td>access_flags</td>
<td>1</td>
<td>字段的访问标志，与类稍有不同</td>
</tr>
<tr class="even">
<td>u2</td>
<td>name_index</td>
<td>1</td>
<td>字段名字的索引</td>
</tr>
<tr class="odd">
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
<td>描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示；
对象类型用“L 对象类型的全限定名”表示。</td>
</tr>
<tr class="even">
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td>属性表集合的长度</td>
</tr>
<tr class="odd">
<td>u2</td>
<td>attributes</td>
<td>attributes_count</td>
<td>属性表集合，用于存放属性的额外信息，如属性的值。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本
Java
代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p>
</blockquote>
<h3 id="方法表集合">方法表集合</h3>
<p>方法表结构与属性表类似。</p>
<p>volatile 关键字 和 transient
关键字不能修饰方法，所以方法表的访问标志中没有 ACC_VOLATILE 和
ACC_TRANSIENT 标志。</p>
<p>方法表的属性表集合中有一张 Code
属性表，用于存储当前方法经编译器编译后的字节码指令。</p>
<h3 id="属性表集合">属性表集合</h3>
<p>每个属性对应一张属性表，属性表的结构如下：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr class="even">
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr class="odd">
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
</tr>
</tbody>
</table>
<h1 id="类加载的时机">类加载的时机</h1>
<h2 id="类的生命周期">类的生命周期</h2>
<p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的<strong>整个生命周期</strong>包括以下
7 个阶段：</p>
<ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<p><code>验证、准备、解析</code> 3
个阶段统称为<strong>连接</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RhvaTA"><img
src="https://z3.ax1x.com/2021/07/05/RhvaTA.png"
alt="RhvaTA.png" /></a></p>
<p>加载、验证、准备、初始化和卸载这 5
个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持
Java 语言的运行时绑定。</p>
<h2
id="类加载过程中初始化开始的时机">类加载过程中“初始化”开始的时机</h2>
<p>Java
虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。<strong>有且仅有
5 种情况必须立即对类进行“初始化”</strong>：</p>
<ul>
<li>在遇到
n<code>ew、putstatic、getstatic、invokestatic 字节码指令</code>时，如果类尚未初始化，则需要先触发其初始化。</li>
<li>对类进行<code>反射调用</code>时，如果类还没有初始化，则需要先触发其初始化。</li>
<li>初始化一个类时，如果其<code>父类还没有初始化</code>，则需要先初始化父类。</li>
<li>虚拟机启动时，用于需要指定一个包含 <code>main()</code>
方法的主类，虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个
java.lang.invoke.MethodHandle 实例最后的解析结果为
<code>REF_getStatic、REF_putStatic、REF_invokeStatic</code>
的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。</li>
</ul>
<p>这 5
种场景中的行为称为对一个类进行<strong>主动引用</strong>，除此之外，其它所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。</p>
<h2 id="被动引用演示-demo">被动引用演示 Demo</h2>
<h3 id="demo1">Demo1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动引用 Demo1:</span></span><br><span class="line"><span class="comment"> * 通过子类引用父类的静态字段，不会导致子类初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ylb</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">        <span class="comment">// SuperClass init!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<h3 id="demo2">Demo2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动引用 Demo2:</span></span><br><span class="line"><span class="comment"> * 通过数组定义来引用类，不会触发此类的初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ylb</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SuperClass[] superClasses = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不会触发父类的初始化，但会触发“[L
全类名”这个类的初始化，它由虚拟机自动生成，直接继承自
java.lang.Object，创建动作由字节码指令 newarray 触发。</p>
<h3 id="demo3">Demo3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动引用 Demo3:</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ylb</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConstClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLO_BINGO</span> <span class="operator">=</span> <span class="string">&quot;Hello Bingo&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ConstClass.HELLO_BINGO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译通过之后，常量存储到 NotInitialization
类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass
类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。</p>
<h2 id="接口的加载过程">接口的加载过程</h2>
<p>接口加载过程与类加载过程稍有不同。</p>
<p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p>
<h1 id="类加载的过程">类加载的过程</h1>
<p>类加载过程包括 5 个阶段：加载、验证、准备、解析和初始化。</p>
<h2 id="加载">加载</h2>
<h3 id="加载的过程">加载的过程</h3>
<p>“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成
3 件事：</p>
<ul>
<li>通过类的全限定名获取该类的二进制字节流。</li>
<li>将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。</li>
<li>在内存中创建一个代表该类的 java.lang.Class
对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h3 id="获取二进制字节流">获取二进制字节流</h3>
<p>对于 Class
文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class
文件中读取，还有以下几种方式：</p>
<ul>
<li>从 zip 包中读取，如 jar、war 等</li>
<li>从网络中获取，如 Applet</li>
<li>通过动态代理技术生成代理类的二进制字节流</li>
<li>由 JSP 文件生成对应的 Class 类</li>
<li>从数据库中读取，如
有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ul>
<h3 id="非数组类与数组类加载比较">“非数组类”与“数组类”加载比较</h3>
<ul>
<li>非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的
<code>loadClass()</code> 方法）</li>
<li>数组类本身不通过类加载器创建，它是由 Java
虚拟机直接创建的，再由类加载器创建数组中的元素类。</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>虚拟机规范未规定 Class 对象的存储位置，对于 HotSpot
虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中。</li>
<li>加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始时间仍然保持着固定的先后顺序。</li>
</ul>
<h2 id="验证">验证</h2>
<h3 id="验证的重要性">验证的重要性</h3>
<p>验证阶段确保 Class
文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="验证的过程">验证的过程</h3>
<ul>
<li>文件格式验证 验证字节流是否符合 Class
文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：
<ul>
<li>是否以魔数 0XCAFEBABE 开头</li>
<li>主次版本号是否在当前虚拟机处理范围内</li>
<li>常量池是否有不被支持的常量类型</li>
<li>指向常量的索引值是否指向了不存在的常量</li>
<li>CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据</li>
<li>......</li>
</ul></li>
<li>元数据验证 对字节码描述信息进行语义分析，确保其符合 Java
语法规范。</li>
<li>字节码验证
本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</li>
<li>符号引用验证 本阶段发生在解析阶段，确保解析正常执行。</li>
</ul>
<h2 id="准备">准备</h2>
<p>准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。</p>
<p>初始值“通常情况下”是数据类型的零值（0,
null...），假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那么变量 value 在准备阶段过后的初始值为 0 而不是
123，因为这时候尚未开始执行任何 Java 方法。</p>
<p>存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue
属性，那么在准备阶段 value 就会被初始化为 ConstantValue
属性所指定的值，假设上面类变量 value 的定义变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为
123。</p>
<h2 id="解析">解析</h2>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h2 id="初始化">初始化</h2>
<p>类初始化阶段是类加载过程的最后一步，是执行类构造器
<code>&lt;clinit&gt;()</code> 方法的过程。</p>
<p><code>&lt;clinit&gt;()</code>
方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {}
块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。</p>
<p>静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;  <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.println(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;clinit&gt;()</code>
方法不需要显式调用父类构造器，虚拟机会保证在子类的
<code>&lt;clinit&gt;()</code> 方法执行之前，父类的
<code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p>
<p>由于父类的 <code>&lt;clinit&gt;()</code>
方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Sub.B); <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;clinit&gt;()</code>
方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成
<code>&lt;clinit&gt;()</code> 方法。</p>
<p>接口中不能使用静态代码块，但接口也需要通过
<code>&lt;clinit&gt;()</code>
方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的
<code>&lt;clinit&gt;()</code> 方法不需要先执行父类的
<code>&lt;clinit&gt;()</code>
方法，只有当父接口中定义的变量使用时，父接口才会初始化。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code>
方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的
<code>&lt;clinit&gt;()</code> 方法。</p>
<h1 id="类加载器">类加载器</h1>
<h2 id="类与类加载器">类与类加载器</h2>
<h3 id="判断类是否相等">判断类是否“相等”</h3>
<p>任意一个类，都由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>一同确立其在
Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。</p>
<p>因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个
Class
文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。</p>
<p>这里的“相等”，包括代表类的 Class 对象的 <code>equals()</code>
方法、<code>isInstance()</code> 方法的返回结果，也包括使用 instanceof
关键字做对象所属关系判定等情况。</p>
<h3 id="加载器种类">加载器种类</h3>
<p>系统提供了 3 种类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）： 负责将存放在
<code>&lt;JAVA_HOME&gt;\lib</code>
目录中的，并且能被虚拟机识别的（仅按照文件名识别，如
rt.jar，名字不符合的类库即使放在 lib
目录中也不会被加载）类库加载到虚拟机内存中。</li>
<li>扩展类加载器（Extension ClassLoader）： 负责加载
<code>&lt;JAVA_HOME&gt;\lib\ext</code>
目录中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）： 由于这个类加载器是
ClassLoader 中的 <code>getSystemClassLoader()</code>
方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/R4Swk9"><img
src="https://z3.ax1x.com/2021/07/05/R4Swk9.png"
alt="R4Swk9.png" /></a></p>
<p>当然，如果有必要，还可以加入自己定义的类加载器。</p>
<h2 id="双亲委派模型">双亲委派模型</h2>
<h3 id="什么是双亲委派模型">什么是双亲委派模型</h3>
<p>双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）</p>
<h3 id="工作过程">工作过程</h3>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>在 java.lang.ClassLoader 中的 <code>loadClass</code>
方法中实现该过程。</p>
<h3 id="为什么使用双亲委派模型">为什么使用双亲委派模型</h3>
<p>像 java.lang.Object 这些存放在 rt.jar
中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的
Object 类都是同一个。</p>
<p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为
java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的
Object 类，Java 类型体系中最基础的行为也就无法保证。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="JDBC学习笔记">
      <i class="fa fa-chevron-left"></i> JDBC学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" rel="next" title="JVM学习笔记（一）">
      JVM学习笔记（一） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-number">1.</span> <span class="nav-text">JVM 性能调优</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-64-%E4%BD%8D-jdk-%E7%AE%A1%E7%90%86%E5%A4%A7%E5%86%85%E5%AD%98"><span class="nav-number">1.1.</span> <span class="nav-text">使用 64 位 JDK 管理大内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-32-%E4%BD%8D-jvm-%E5%BB%BA%E7%AB%8B%E9%80%BB%E8%BE%91%E9%9B%86%E7%BE%A4"><span class="nav-number">1.2.</span> <span class="nav-text">使用 32 位 JVM 建立逻辑集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="nav-number">1.3.</span> <span class="nav-text">调优案例分析与实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">场景描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">1.3.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">直接内存的回收过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm-%E7%9A%84%E6%97%A0%E5%85%B3%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">JVM 的“无关性”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">Class 文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AD%94%E6%95%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">魔数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-number">2.2.2.</span> <span class="nav-text">版本信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.2.3.</span> <span class="nav-text">常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">常量池的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">常量池中常量类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="nav-number">2.2.4.</span> <span class="nav-text">访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%B4%A2%E5%BC%95%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88"><span class="nav-number">2.2.5.</span> <span class="nav-text">类索引、父类索引、接口索引集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88"><span class="nav-number">2.2.6.</span> <span class="nav-text">字段表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="nav-number">2.2.7.</span> <span class="nav-text">方法表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="nav-number">2.2.8.</span> <span class="nav-text">属性表集合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">3.</span> <span class="nav-text">类加载的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">3.2.</span> <span class="nav-text">类加载过程中“初始化”开始的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A2%AB%E5%8A%A8%E5%BC%95%E7%94%A8%E6%BC%94%E7%A4%BA-demo"><span class="nav-number">3.3.</span> <span class="nav-text">被动引用演示 Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#demo1"><span class="nav-number">3.3.1.</span> <span class="nav-text">Demo1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#demo2"><span class="nav-number">3.3.2.</span> <span class="nav-text">Demo2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#demo3"><span class="nav-number">3.3.3.</span> <span class="nav-text">Demo3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">接口的加载过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.1.</span> <span class="nav-text">加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">加载的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">获取二进制字节流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%95%B0%E7%BB%84%E7%B1%BB%E4%B8%8E%E6%95%B0%E7%BB%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%AF%94%E8%BE%83"><span class="nav-number">4.1.3.</span> <span class="nav-text">“非数组类”与“数组类”加载比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">4.1.4.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">4.2.</span> <span class="nav-text">验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">4.2.1.</span> <span class="nav-text">验证的重要性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.2.</span> <span class="nav-text">验证的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">4.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">4.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">类与类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%B1%BB%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="nav-number">5.1.1.</span> <span class="nav-text">判断类是否“相等”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="nav-number">5.1.2.</span> <span class="nav-text">加载器种类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">双亲委派模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">什么是双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">工作过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.3.</span> <span class="nav-text">为什么使用双亲委派模型</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

