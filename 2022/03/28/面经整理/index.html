<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aeowind.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="想当年我离家时她已十八，有一颗善良的心和一卷长发">
<meta property="og:type" content="article">
<meta property="og:title" content="整理">
<meta property="og:url" content="https://aeowind.github.io/2022/03/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Aeo&#39;s Blog">
<meta property="og:description" content="想当年我离家时她已十八，有一颗善良的心和一卷长发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/24/qGxict.md.png">
<meta property="article:published_time" content="2022-03-28T03:44:52.270Z">
<meta property="article:modified_time" content="2022-03-28T12:23:54.747Z">
<meta property="article:author" content="aeowind">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/03/24/qGxict.md.png">

<link rel="canonical" href="https://aeowind.github.io/2022/03/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>整理 | Aeo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aeo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你要静候 再静候</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aeowind.github.io/2022/03/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aeowind">
      <meta itemprop="description" content="爱上一场认真的消遣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aeo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-28 11:44:52 / 修改时间：20:23:54" itemprop="dateCreated datePublished" datetime="2022-03-28T11:44:52+08:00">2022-03-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/Java/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">想当年我离家时她已十八，有一颗善良的心和一卷长发</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1
id="mysql索引相关联合索引同时查询两个字段怎么建索引">MySQL索引相关，联合索引，同时查询两个字段怎么建索引</h1>
<p><strong>组合索引</strong>：由<strong>多个列值</strong>组成的索引。</p>
<p>考虑最左前缀匹配原则</p>
<h1
id="怎么查select走没走索引explain显示有索引就一定走了索引吗">怎么查select走没走索引，explain显示有索引就一定走了索引吗</h1>
<p>可以使用EXPLAIN语句查看索引是否正在使用</p>
<p>使用explain一定要结合多个字段分析。</p>
<p>key：表示使用的索引
rows:表示影响行数。使用索引不代表不会进行全表扫描</p>
<p>如果觉得explain不太准，怎么办？ 可以使用 show session status like
"Handler%"； show profile 这两个命令对SQL进行更准确的分析。</p>
<h1 id="jvm内存结构及作用">jvm内存结构及作用</h1>
<h1
id="在浏览器输入url显示过程http和https的区别https怎么加密对称加密的秘钥服务端和客户端怎么协商">在浏览器输入url，显示过程，http和https的区别，https怎么加密，对称加密的秘钥服务端和客户端怎么协商</h1>
<p><strong>超文本传输协议HTTP协议</strong>被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：<strong>安全套接字层超文本传输协议HTTPS</strong>，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>通讯双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥。</p>
<h1
id="mq怎么保证消费的幂等性用mysql怎么去重">mq怎么保证消费的幂等性，用Mysql怎么去重</h1>
<h2 id="为什么要保证幂等性">为什么要保证幂等性？</h2>
<p>​
幂等性要求任意多次执行对资源本身所产生的影响均与一次执行的影响相同，如果不保证幂等性，在发生如下情况时就会出现问题：</p>
<p><strong>前端重复提交表单</strong>：
在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。
<strong>用户恶意进行刷单</strong>：
例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。
<strong>接口超时重复提交</strong>： 很多时候 HTTP
客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次，如
feign、dubbo等</p>
<p><strong>消息进行重复消费</strong>： 当使用 MQ
消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。</p>
<p>传统的保证MQ消费幂等性的方案，原理都是通过<strong>一致性标识</strong>去防止重复发送-或者重复消费。</p>
<ul>
<li><strong>对于消息生产者：</strong></li>
</ul>
<p>并发情况下只要在上游保证第一条数据更新的过程其他线程不能查询并更新即可，因为后续进来的请求都会先查询数据库，如图所示。</p>
<figure>
<img
src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f62eb23fad449f59d669816e9a86c46~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><strong>对于消息消费者：</strong></li>
</ul>
<p><strong>1.业务操作之前进行状态查询：</strong></p>
<p>消费端开始执行业务操作时，通过幂等id首先进行业务状态的查询，如：修改订单状态环节，当订单状态为成功/失败则不需要再进行处理。那么我们只需要在消费逻辑执行之前通过订单号进行订单状态查询，一旦获取到确定的订单状态则对消息进行提交，通知broker消息状态为：ConsumeStatus.CONSUME_SUCCESS
。</p>
<p><strong>2.唯一性约束：</strong>
设定好数据库唯一约束，最坏的条件下保证数据的唯一性。</p>
<p>上述第一点操作并不能保证一定不出现重复的数据，如：并发插入的场景下，如果没有乐观锁、分布式锁作为保证的前提下，很有可能出现数据的重复插入操作，因此我们务必要对幂等id添加唯一性索引，这样就能够保证在并发场景下也能保证数据的唯一性。</p>
<p><strong>3.引入锁机制</strong></p>
<p>上述的第一点中，如果是并发更新的情况，没有使用悲观锁、乐观锁、分布式锁等机制的前提下，进行更新，很可能会出现多次更新导致状态的不准确。
如：对订单状态的更新，业务要求订单只能从初始化-&gt;处理中，处理中-&gt;成功，处理中-&gt;失败，不允许跨状态更新。如果没有锁机制，很可能会将初始化的订单更新为成功，成功订单更新为失败等异常的情况。
高并发下，建议通过状态机的方式定义好业务状态的变迁，通过乐观锁、分布式锁机制保证多次更新的结果是确定的，悲观锁在并发环境不利于业务吞吐量的提高因此不建议使用。</p>
<p><strong>4.消息记录表：</strong>
这种方案和业务层做的幂等操作类似，指定唯一约束，存储消息流水，间接实现消费的幂等。</p>
<p>首先准备一个消息记录表，在消费成功的同时插入一条已经处理成功的消息id记录到该表中，注意一定要
与业务操作处于同一个事物
中，当新的消息到达的时候，根据新消息的id在该表中查询是否已经存在该id，如果存在则表明消息已经被消费过，那么丢弃该消息不再进行业务操作即可。</p>
<h1
id="用redis保证mq消费幂等性怎么设置key值的过期时间">用Redis保证mq消费幂等性，怎么设置key值的过期时间</h1>
<blockquote>
<p>利用redis的原子性</p>
</blockquote>
<p>每次操作都直接set到redis里面，然后将redis数据定时同步到数据库中</p>
<h1
id="rabbitmq怎么存储数据会存在磁盘内存中吗">RabbitMQ怎么存储数据，会存在磁盘，内存中吗</h1>
<p>不管是持久化的消息还是非持久化的消息都可以被写入到磁盘。持久化的消息在到达队列时就被写入到磁盘，并且如果可以，持久化的消息也会在内存中保存一个备份，这样就可以提高一定的性能，当内存吃紧的时候会从内存中清除。非持久化的消息一般只保存在内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存空间。这两种类型的消息的落盘处理都在RabbitMQ的“持久层”中完成。</p>
<h1
id="使用spring有什么好处不用spring怎么开发">使用spring有什么好处，不用spring怎么开发</h1>
<p>1.方便解耦，简化开发</p>
<p>　　通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p>
<p>2.AOP编程的支持</p>
<p>　　通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</p>
<p>3.声明事务的支持</p>
<p>　　在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</p>
<p>4.方便程序的测试</p>
<p>　　可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
<p>5.方便集成各种优秀框架</p>
<p>　　Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。</p>
<p>6.降低Java EE API的使用难度</p>
<p>　　Spring对很多难用的Java EE
API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java
EE API的使用难度大为降低。</p>
<p>7.Java 源码是经典学习范例</p>
<p>spring主要解决的是ioc,mvc和dao三个问题。针对这3个问题目前有很多其他的替代方案，我们只要将它们组合起来使用即可。</p>
<p>比如解决ioc可以用google的guice等，其他的如vaadin，jsf都是可以进行web企业级开发的框架</p>
<h1 id="springmvc工作流程">SpringMVC工作流程</h1>
<p>[<img src="https://s1.ax1x.com/2022/03/24/qGxict.md.png"
alt="qGxict.md.png" />](</p>
<ol type="1">
<li><p>用户发送请求至前端控制器<strong>DispatcherServlet</strong>；</p></li>
<li><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器；</p></li>
<li><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</p></li>
<li><p><strong>DispatcherServlet</strong>通过HandlerAdapter处理器适配器调用处理器；</p></li>
<li><p>执行处理器(Controller，也叫后端控制器)；</p></li>
<li><p>Controller执行完成返回ModelAndView；</p></li>
<li><p>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet；</p></li>
<li><p><strong>DispatcherServlet</strong>将ModelAndView传给ViewReslover视图解析器；</p></li>
<li><p>ViewReslover解析后返回具体View；</p></li>
<li><p><strong>DispatcherServlet</strong>对View进行渲染视图（即将模型数据填充至视图中）；</p></li>
<li><p>DispatcherServlet响应用户。</p></li>
</ol>
<h1 id="mybatis和jdbc的区别">mybatis和jdbc的区别</h1>
<ul>
<li><strong>JDBC是java提供的操作数据库的api；</strong></li>
</ul>
<p>传统JDBC操作数据</p>
<blockquote>
<p>需要连接数据库，注册驱动和数据库信息 操作Connection，打开 Statement
对象 。 通过Statement执行SQL， 返回结果到ResultSet对象。
使用ResultSet读取数据，然后通过代码转化为具体的POJO对象。
关闭数据库的相关资源。</p>
</blockquote>
<p>jdbc存在弊端：</p>
<blockquote>
<p>工作量相对较大，每次都要去创建，关闭，获取
JDBC编程可能产生的异常进行捕捉处理并正确关闭资源</p>
</blockquote>
<ul>
<li><strong>MyBatis是一个支持普通SQL查询，存储过程和高级映射的持久层的框架。</strong></li>
</ul>
<p>MyBatis是对JDBC的封装，它可以基于xml或者注解的方式进行配置和原始映射，消除了几乎所有的jdbc代码和参数的手动设置和对结果集的封装。
MyBatis可以使用简单的XML配置，将接口和Java的POJO（普通的Java对象）映射成数据库中的记录。</p>
<p>相对于JDBC,MyBatis具有以下优点：</p>
<blockquote>
<p>1.MyBatis通过dataSource实现数据库连接池的配置，实现了隔离解耦，统一从dataSource中获取数据库连接，具体实现通过让用户配置应对变化。
2.MyBatis将所有的SQL统一放在配置文件（XXXMapper.xml）中统一管理，不需要再次编译，而传统的jdbc的SQL语句分布在代码中，修改之后需要再次编译。可读性差，不便于维护。
3.MyBatis还可以通过标签动态的生成SQL语句。
4.MyBatis可以直接将结果映射为自己需要的类型，如：Javabean，map，list等。而在使用jdbc时，我们要从返回的结果集ResultSet中获取结果封装为我们需要的类型中。</p>
</blockquote>
<h1
id="怎么合并另一个分支的其中某一个commit">怎么合并另一个分支的其中某一个commit</h1>
<p>例如要将A分支的一个commit合并到B分支：</p>
<p>首先切换到A分支</p>
<p>git checkout A</p>
<p>git log</p>
<p>找出要合并的commit ID :</p>
<p>例如</p>
<p>0128660c08e325d410cb845616af355c0c19c6fe</p>
<p>然后切换到B分支上</p>
<p>git checkout B</p>
<p>git cherry-pick 0128660c08e325d410cb845616af355c0c19c6fe</p>
<p>然后就将A分支的某个commit合并到了B分支了</p>
<h1 id="类加载过程">类加载过程</h1>
<p>Java虚拟机把描述类的数据从<code>class文件</code>加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的<code>Java类型</code>，这个过程被称作<strong>虚拟机的类加载机制</strong>。</p>
<h2 id="类加载的时机">类加载的时机</h2>
<ul>
<li>隐式加载 new 创建类的实例</li>
<li>显式加载：loaderClass,forName等</li>
<li>访问类的静态变量，或者为静态变量赋值</li>
<li>调用类的静态方法</li>
<li>使用反射方式创建某个类或者接口对象的Class对象</li>
<li>初始化某个类的子类</li>
<li>直接使用java.exe命令来运行某个主类</li>
</ul>
<h2 id="类加载过程-1">类加载过程</h2>
<p>我们编写的java文件都是保存着业务逻辑代码。java编译器将 .java
文件编译成扩展名为 <code>.class</code> 的文件。<code>.class</code>
文件中保存着java转换后，虚拟机将要执行的指令。当需要某个类的时候，java虚拟机会加载
<code>.class</code>
文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为<strong>类的加载</strong>。</p>
<ol type="1">
<li><p><strong>加载</strong></p>
<p>类加载过程的一个阶段，ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象。</p></li>
<li><p><strong>验证</strong></p>
<p>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。</p></li>
<li><p><strong>准备</strong>
为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static
int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i
赋值为5)，这里不包含final修饰的static
，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。</p></li>
<li><p><strong>解析</strong>
这里主要的任务是把常量池中的符号引用替换成直接引用</p></li>
<li><p><strong>初始化</strong>
这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static
初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）</p></li>
</ol>
<blockquote>
<p>类记载器的任务是根据类的全限定名来读取此类的二进制字节流到 JVM
中，然后转换成一个与目标类对象的java.lang.Class 对象的实例，在java
虚拟机提供三种类加载器，引导类加载器，扩展类加载器，系统类加载器。</p>
</blockquote>
<h1 id="redis数据结构">redis数据结构</h1>
<h1 id="过期删除内存淘汰">过期删除&amp;内存淘汰</h1>
<h1 id="lru">LRU</h1>
<p>一个用hash表作为底层结构的数据库，当然少不了缓存淘汰算法。</p>
<p>LRU（Least recently
used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<figure>
<img
src="https://pic4.zhimg.com/80/v2-71b21233c615b1ce899cd4bd3122cbab_1440w.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<p>过程如下：</p>
<figure>
<img
src="https://pic3.zhimg.com/80/v2-998b52e7534278b364e439bbeaf61d5e_1440w.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li>最开始时，内存空间是空的，因此依次进入A、B、C是没有问题的</li>
<li>当加入D时，就出现了问题，内存空间不够了，因此根据LRU算法，内存空间中A待的时间最为久远，选择A,将其淘汰</li>
<li>当再次引用B时，内存空间中的B又处于活跃状态，而C则变成了内存空间中，近段时间最久未使用的</li>
<li>当再次向内存空间加入E时，这时内存空间又不足了，选择在内存空间中待的最久的C将其淘汰出内存，这时的内存空间存放的对象就是E-&gt;B-&gt;D</li>
</ol>
<h1
id="多线程如何实现线程安全的i操作">多线程如何实现线程安全的i++操作</h1>
<p>1、 使用循环CAS，实现i++原子操作
Java从JDK1.5开始提供了java.util.concurrent.atomic包来提供线程安全的原子操作类。这些原子操作类都是是用CAS来实现，i++的原子性操作。以AtomicInteger为例子，讲一下
public final int getAndIncrement(){} 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2、使用锁机制，实现i++原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lock实现，多线程的数据同步</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
<p>3、使用synchronized，实现i++原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="comment">// 进行自加的操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="tcp报文">TCP报文</h1>
<p>TCP与UDP最大却别就在那个<strong>C</strong>上面，它充分实现了数据传输时各种控制功能。可以进行丢包<strong>重发控制</strong>，还可以对次序乱掉的数据包进行<strong>顺序控制</strong>，还能<strong>控制传输流量</strong>，这些是UDP中没有的。即T
C P 提供一种面向连接的、可靠的字节流服务。</p>
<p>TCP是一中面向有链接的协议，只有在确认对端存在的时候，才会发送分数据，从而也可以控制通信流量的浪费。</p>
<p><strong>什么是可靠的传输：</strong>不丢包、不损坏、不乱序、不重复。</p>
<p>TCP通过<strong>校验和</strong>、<strong>序列号</strong>、<strong>确认应答</strong>、<strong>重发控制</strong>、<strong>连接管理</strong>以及<strong>窗口控制</strong>等机制来实现可靠传输。</p>
<p>接收端查询就收数据TCP首部中的序号和数据长度。将自己下一步应该接受的序列号作为确认应答返送回去。就这样，通过序列号和确认应答，TCP实现可靠传输。</p>
<p>一般使用TCP首部用于控制的字段来管理连接。一个连接的建立和断开，正常过程中，至少需要来回共7个包才能完成。</p>
<h1
id="linux查找文中某个字符串的位置命令">Linux查找文中某个字符串的位置命令</h1>
<p>如果你想在当前目录下 查找"hello,world!"<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=字符串&amp;spm=1001.2101.3001.7020">字符串</a>,可以这样:</p>
<p><a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=grep&amp;spm=1001.2101.3001.7020">grep</a>
-rn "hello,world!" *</p>
<p>* : 表示当前目录所有文件，也可以是某个文件名</p>
<p>-r 是递归查找</p>
<p>-n 是显示行号</p>
<p>-R 查找所有文件包含子目录</p>
<p>-i 忽略大小写</p>
<h1
id="设计一个消减流量的算法大致就是服务器只能承受每秒20次的请求现在有每秒100次请求设计一个算法解决这样问题">设计一个消减流量的<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=算法">算法</a>（大致就是服务器只能承受每秒20次的请求，现在有每秒100次请求。设计一个<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=算法">算法</a>解决这样问题）</h1>
<p><strong>1、排队</strong></p>
<p>要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。在这里，消息队列就像“水库”一样，拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的<img
src="https://zhouj000.github.io/img/in-post/2018/10/highPerformance-05.jpg"
alt="highPerformance-05" /></p>
<p>但是，如果流量峰值持续一段时间达到了消息队列的处理上限，例如本机的消息积压达到了存储空间的上限，消息队列同样也会被压垮，这样虽然保护了下游的系统，但是和直接把请求丢弃也没多大的区别。就像遇到洪水爆发时，即使是有水库恐怕也无济于事</p>
<p>除了消息队列，类似的排队方式还有很多，例如：
1、利用线程池加锁等待也是一种常用的排队方式
2、先进先出、先进后出等常用的内存排队算法的实现方式
3、把请求序列化到文件中，然后再顺序地读文件（例如基于MySQL
binlog的同步机制）来恢复请求等方式</p>
<p>可以看到，这些方式都有一个共同特征，就是把“一步的操作”变成“两步的操作”，其中增加的一步操作用来起到缓冲的作用。那么这样一来增加了访问请求的路径啊，并不符合之前介绍的“4要1不要”原则。没错，的确看起来不太合理，但是如果不增加一个缓冲步骤，那么在一些场景下系统很可能会直接崩溃，所以最终还是需要做出妥协和平衡</p>
<p><strong>2、答题</strong></p>
<p>答题主要是为了增加购买的复杂度，从而达到两个目的：
1、防止部分买家使用秒杀器在参加秒杀时作弊
2、延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰。这个重要的功能就是把峰值的下单请求拉长，从以前的1s之内延长到2s~10s。这样一来，请求峰值基于时间分片了。这个时间的分片对服务端处理并发非常重要，会大大减轻压力。而且，由于请求具有先后顺序，靠后的请求到来时自然也就没有库存了，因此根本到不了最后的下单步骤，所以真正的并发写就非常有限了<img
src="https://zhouj000.github.io/img/in-post/2018/10/highPerformance-06.jpg"
alt="highPerformance-06" /></p>
<p>整个秒杀答题的逻辑主要分为3部分：
1、题库生成模块，这个部分主要就是生成一个个问题和答案，其实题目和答案本身并不需要很复杂，重要的是能够防止由机器来算出结果，即防止秒杀器来答题
2、题库的推送模块，用于在秒杀答题前，把题目提前推送给详情系统和交易系统。题库的推送主要是为了保证每次用户请求的题目是唯一的，目的也是防止答题作弊
3、题目的图片生成模块，用于把题目生成为图片格式，并且在图片里增加一些干扰因素。这也同样是为防止机器直接来答题，它要求只有人才能理解题目本身的含义。这里还要注意一点，由于答题时网络比较拥挤，我们应该把题目的图片提前推送到CDN上并且要进行预热，不然的话当用户真正请求题目时，图片可能加载比较慢，从而影响答题的体验</p>
<p>当用户提交的答案和题目对应的答案做比较，如果通过了就继续进行下一步的下单逻辑，否则就失败。我们可以把问题和答案用下面这样的key来进行MD5加密：</p>
<ul>
<li>问题key：userId+itemId+question_Id+time+PK</li>
<li>答案key：userId+itemId+answer+PK<img
src="https://zhouj000.github.io/img/in-post/2018/10/highPerformance-07.jpg"
alt="highPerformance-07" />这里面的验证逻辑，除了验证问题的答案以外，还包括用户本身身份的验证，例如是否已经登录、用户的Cookie是否完整、用户是否重复频繁提交等。除了做正确性验证，我们还可以对提交答案的时间做些限制，例如从开始答题到接受答案要超过1s，因为小于1s是人为操作的可能性很小，这样也能防止机器答题的情况</li>
</ul>
<p><strong>3、分层过滤</strong></p>
<p>前面介绍的排队和答题要么是少发请求，要么对发出来的请求进行缓冲，而针对秒杀场景还有一种方法，就是对请求进行分层过滤，从而过滤掉一些无效的请求。分层过滤其实就是采用“漏斗”式设计来处理请求的，如下图所示:<img
src="https://zhouj000.github.io/img/in-post/2018/10/highPerformance-08.jpg"
alt="highPerformance-08" /></p>
<p>假如请求分别经过CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：
1、大部分数据和流量在用户浏览器或者CDN上获取，这一层可以拦截大部分数据的读取
2、经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走Cache，过滤一些无效的请求
3、再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少
4、最后在数据层完成数据的强一致性校验</p>
<p>分层过滤的核心思想是：在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请求。而要达到这种效果，我们就必须对数据做分层的校验
分层校验的基本原则是：
1、将动态请求的读数据缓存（Cache）在Web端，过滤掉无效的数据读
2、对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题
3、对写数据进行基于时间的合理分片，过滤掉过期的失效请求
4、对写请求做限流保护，将超出系统承载能力的请求过滤掉
5、对写数据进行强一致性校验，只保留最后有效的数据</p>
<p>分层校验的目的是，在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等</p>
<h1 id="spring的bean生命周期">Spring的Bean生命周期</h1>
<p>对于普通的 Java 对象，当 new
的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java
自动进行垃圾回收。</p>
<p>而 Spring 中的对象是 bean，bean 和普通的 Java
对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC
容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC
容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean
的生命周期完全由容器控制。</p>
<ul>
<li><p>Bean 的生命周期概括起来就是 <strong>4 个阶段</strong>：</p>
<ol type="1">
<li>实例化（Instantiation）</li>
<li>属性赋值（Populate）</li>
<li>初始化（Initialization）</li>
<li>销毁（Destruction）</li>
</ol>
<figure>
<img
src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/1704860a4de235aa~tplv-t2oaga2asx-watermark.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li><strong>实例化</strong>：第 1 步，实例化一个 bean 对象；</li>
<li><strong>属性赋值</strong>：第 2 步，为 bean
设置相关属性和依赖；</li>
<li><strong>初始化</strong>：第 3~7 步，步骤较多，其中第 5、6
步为初始化操作，第 3、4 步为在初始化前执行，第 7
步在初始化后执行，该阶段结束，才能被用户使用；</li>
<li><strong>销毁</strong>：第
8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁
bean 时再执行相应的方法。</li>
</ol></li>
</ul>
<p><strong>最后总结下如何记忆 Spring Bean 的生命周期：</strong></p>
<ul>
<li>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</li>
<li>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor
在初始化前后的处理以及 InitializingBean 和 init-method
的初始化操作；</li>
<li>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和
destory-method 进行销毁。</li>
</ul>
<h1 id="spring的动态代理">Spring的动态代理</h1>
<p><strong>AOP是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring
AOP会使用<strong>JDK
Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK
Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong>
，这时候Spring AOP会使用 <strong>Cglib</strong>
生成一个被代理对象的子类来作为代理</p>
<h1 id="list和set的区别">List和Set的区别</h1>
<p>List：</p>
<blockquote>
<ol type="1">
<li>可以允许重复的对象。</li>
<li>可以插入多个null元素。</li>
<li>是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。</li>
<li>常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList
最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从
List 中添加或删除元素的场合更为合适。</li>
</ol>
</blockquote>
<p>Set：</p>
<blockquote>
<ol type="1">
<li>不允许重复对象</li>
<li>无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者
Comparable 维护了一个排序顺序。</li>
<li>只允许一个 null 元素</li>
<li>Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及
TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了
SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo()
的定义进行排序的有序容器。</li>
</ol>
</blockquote>
<h1 id="hashset为什么能去重">hashset为什么能去重</h1>
<p>继续溯源.可以看出依据<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&amp;spm=1001.2101.3001.7020">hash</a>以及equals判断的.</p>
<h1
id="多线程执行一个任务的流程run和call的区别">多线程执行一个任务的流程，run和call的区别</h1>
<p>一: 相同点</p>
<p>1、两者都是接口 2、通过Thread.start()开启线程后执行 3、两者可以通过<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=线程池&amp;spm=1001.2101.3001.7020">线程池</a>进行执行</p>
<p>二: 不同点</p>
<p>1、call方法可以抛出异常(<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=throws&amp;spm=1001.2101.3001.7020">throws</a>),有返回值,run不能够抛出异常,并且没有返回值</p>
<h1 id="java的并行流">Java的并行流</h1>
<p><strong>什么是并行流：</strong>
并行流就是将一个流的内容分成多个数据块，并用不同的线程分别处理每个不同数据块的流。例如有这么一个需求：</p>
<p>有一个 List 集合，而 list 中每个 apple 对象只有重量，我们也知道 apple
的单价是 5元/kg，现在需要计算出每个 apple 的单价，传统的方式是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>&lt;<span class="type">Apple</span>&gt; appleList <span class="operator">=</span> new <span class="type">ArrayList</span>&lt;&gt;(); <span class="comment">// 假装数据是从库里查出来的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">Apple</span> apple : appleList) &#123;</span><br><span class="line">    apple.setPrice(<span class="number">5.0</span> <span class="operator">*</span> apple.getWeight() <span class="operator">/</span> <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过迭代器遍历 list 中的 apple 对象，完成了每个 apple
价格的计算。而这个算法的时间复杂度是 O(list.size()) 随着 list
大小的增加，耗时也会跟着线性增加。并行流可以大大缩短这个时间。</p>
<p>并行流处理该集合的方法如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appleList.<span class="title function_ invoke__">parallelStream</span>().<span class="title function_ invoke__">forEach</span>(apple <span class="punctuation">-&gt;</span> apple.<span class="title function_ invoke__">setPrice</span>(<span class="number">5.0</span> * apple.<span class="title function_ invoke__">getWeight</span>() / <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<h1
id="海量数据中找出前k大数topk问题">海量数据中找出前k大数（topk问题）</h1>
<p>在海量数据中找出出现频率最好的前k个数，或者从海量数据中找出最大的前k个数，这类问题通常被称为top
K问题。</p>
<p>针对top
K类问题，通常比较好的方案是分治+Trie树/hash+小顶堆（就是上面提到的最小堆），即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树或者Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top
K中求出最终的top K。</p>
<p>方法进阶：</p>
<p>1、最简单的方法就是快排，取topk</p>
<p>2、局部淘汰法。用一个容器保存前k个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的k个数还小，那么容器内这k个数就是最大k个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完所有的数，得到的结果容器中保存的数即为最终结果了</p>
<p>3、分治法。将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100<em>10000个数据里面找出最大的10000个。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6</em>4=4MB，一共需要101次这样的比较。</p>
<p>4、采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。</p>
<h1 id="cms的过程那些是并发的">CMS的过程，那些是并发的</h1>
<p>一般<strong>老年代我们选择的垃圾回收器就是CMS（Concurrent Mark
Sweep） 收集器</strong>
，这是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。
我们大部分互联网网站或者基于浏览器的B/S系统的服务端
，这类应用通常都会较为关注服务的响应速度， 希望系统停顿时间尽可能短，
以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p>
<p>从名字（包含“Mark Sweep”）
上就可以看出CMS收集器是基于<strong>标记-清除算法</strong>实现的，
它的运作 过程相对于前面几种收集器来说要更复杂一些，
整个过程分为四个步骤， 包括：</p>
<p>1） 初始标记（CMS initial mark） 2） 并发标记（CMS concurrent mark）
3） 重新标记（CMS remark） 4） 并发清除（CMS concurrent sweep）</p>
<p>接下来我们来一步一步分析整个CMS的运行逻辑和流程，尽量把它的核心思路掌握。</p>
<h3 id="初始标记cms-initial-mark">1） 初始标记（CMS initial mark）</h3>
<p>首先根据之前讲过的“可达性分析算法“来判断有哪些对象是被GC
Roots给引用的，如果是的话就是存活对象，否则就是垃圾对象。然后将垃圾对象都标记出来，如下图：</p>
<p><img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a89d99cc100c46c19be366cbe0429877~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />注意：初始标记的过程会让系统停止工作，进入“Stop The
World”状态，不过这个过程很快，仅仅标记GCRoots直接引用的那些对象。(回顾下GC
Roots对象有：类的静态变量，方法的局部变量，但是类的实例变量不是GCRoots)</p>
<p>假设我现在系统中有这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    private static Company company = new Company();</span><br><span class="line">&#125;</span><br><span class="line">public class Company&#123;</span><br><span class="line">    private Employee employee = new Employee();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>那么在内存中对应的初始标记阶段只会标记出来GC
Roots直接引用的对象，也就是Company()对象，而employee对象仅仅是类的实例变量，不会被进行标记。内存图如下：</p>
<p><img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b80d9e4a94040d3abad56776fa918c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />注意：Employee对象仅仅是类的实例变量引用的对象，不是GCRoot直接引用的对象，因此初始标记并不会进行标记。</p>
<h3 id="并发标记cms-concurrent-mark">2）并发标记（CMS concurrent
mark）</h3>
<p>并发标记阶段恢复系统正常运行，可以随意创建对象，同时并发标记线程也开始工作，这里由于一边进行并发标记，一边进行对象的创建，必然会持续增加新的对象产生，同时也有可能一些对象失去引用变成垃圾对象。</p>
<p>那么并发标记主要是标记哪些对象呢？比如上图中的Employee对象，垃圾回收线程会判断该对象被谁引用，这里是被company对象引用，再次判断company对象被谁引用，由于初始标记的时候已经知道是被GCRoots直接引用，从而判断到Employee对象是间接被GCRoots对象引用，从而标记为存活对象。</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6663a53e3091470e949073ca1ec6295c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>总之，针对所有老年代中存在的对象以及不断新增的对象都会进行标记，而我们的系统线程也在一直工作不断产生对象，所以该阶段也是最耗时的。虽然是耗时的，但是垃圾回收与系统是并行进行的，所以并不会对系统的运行造成影响。</p>
<h3 id="重新标记cms-remark">3）重新标记（CMS remark）</h3>
<p>由于我们的第二个阶段是并发标记，那么肯定会造成有部分对象已经失去引用变成垃圾对象没有来得及更正，以及新创建的对象还未来得及标记，如下图：</p>
<p><img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96b002684e394668a30d25d357f7faad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />因此第三阶段：重新标记
会暂停我们的系统线程，开始重新整理，如下图：</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8052e9b221ad407e939dd5618f2c23b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>不过该阶段会很快，主要是针对第二阶段中被系统程序运行变动过的少数对象进行标记，所以速度很快。</p>
<p>接着重新恢复系统线程工作，开始进入第四阶段：并发清理。</p>
<h3 id="并发清除cms-concurrent-sweep">4）并发清除（CMS concurrent
sweep）</h3>
<p>最后是并发清除阶段， 清理删除掉标记阶段判断的已经死亡的对象，
由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的。</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7eb26b5e6ae422e94ee32a065af26cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="小结">5）小结</h3>
<p>通过以上CMS工作的整个过程，我们总结下：</p>
<ul>
<li>最耗时的阶段是：并发标记与并发清除---&gt;不过该阶段是与用户线程并发执行并不影响系统</li>
<li>初始标记和重新标记阶段：需要Stop the
World,暂停系统工作----&gt;但是该两个阶段速度很快几乎影响不大</li>
</ul>
<h1 id="线程池堵塞队列">线程池堵塞队列</h1>
<p>在重复一下新任务进入时线程池的执行策略：
如果运行的线程少于corePoolSize，则
Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存入queue中，而是直接运行）
如果运行的线程大于等于 corePoolSize，则
Executor始终首选将请求加入队列，而不添加新的线程。
如果无法将请求加入队列，则创建新的线程，除非创建此线程超出
maximumPoolSize，在这种情况下，任务将被拒绝。
主要有3种类型的BlockingQueue：</p>
<p><strong>无界队列</strong></p>
<p>队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool
采用就是
LinkedBlockingQueue，而楼主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue
中，导致cpu和内存飙升服务器挂掉。</p>
<p><strong>有界队列</strong></p>
<p>常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。
使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p>
<p>在我们的修复方案中，选择的就是这个类型的队列，虽然会有部分任务被丢失，但是我们线上是排序日志搜集任务，所以对部分对丢失是可以容忍的。</p>
<p><strong>同步移交队列</strong></p>
<p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>
<h1 id="spring事务传播机制">spring事务传播机制</h1>
<p>简单的理解就是多个事务方法相互调用时,事务如何在这些方法间传播。</p>
<p>因为 spring 是使用 aop 来代理事务控制
，是针对于接口或类的，所以在同一个 service
类中两个方法的调用，传播机制是不生效的</p>
<h2 id="传播机制类型">传播机制类型</h2>
<p>下面的类型都是针对于被调用方法来说的，理解起来要想象成两个 service
方法的调用才可以。</p>
<h3 id="propagation_required-默认">PROPAGATION_REQUIRED (默认)</h3>
<ul>
<li>支持当前事务，如果当前没有事务，则新建事务</li>
<li>如果当前存在事务，则加入当前事务，合并成一个事务</li>
</ul>
<h3 id="requires_new">REQUIRES_NEW</h3>
<ul>
<li>新建事务，如果当前存在事务，则把当前事务挂起</li>
<li>这个方法会独立提交事务，不受调用者的事务影响，父级异常，它也是正常提交</li>
</ul>
<h3 id="nested">NESTED</h3>
<ul>
<li>如果当前存在事务，它将会成为父级事务的一个子事务，方法结束后并没有提交，只有等父事务结束才提交</li>
<li>如果当前没有事务，则新建事务</li>
<li>如果它异常，父级可以捕获它的异常而不进行回滚，正常提交</li>
<li>但如果父级异常，它必然回滚，这就是和 <code>REQUIRES_NEW</code>
的区别</li>
</ul>
<h3 id="supports">SUPPORTS</h3>
<ul>
<li>如果当前存在事务，则加入事务</li>
<li>如果当前不存在事务，则以非事务方式运行，这个和不写没区别</li>
</ul>
<h3 id="not_supported">NOT_SUPPORTED</h3>
<ul>
<li>以非事务方式运行</li>
<li>如果当前存在事务，则把当前事务挂起</li>
</ul>
<h3 id="mandatory">MANDATORY</h3>
<ul>
<li>如果当前存在事务，则运行在当前事务中</li>
<li>如果当前无事务，则抛出异常，也即父级方法必须有事务</li>
</ul>
<h3 id="never">NEVER</h3>
<ul>
<li>以非事务方式运行，如果当前存在事务，则抛出异常，即父级方法必须无事务</li>
</ul>
<h3 id="一点小说明">一点小说明</h3>
<p>一般用得比较多的是 <code>PROPAGATION_REQUIRED</code>，
<code>REQUIRES_NEW</code>；</p>
<p><code>REQUIRES_NEW</code>
一般用在子方法需要单独事务，暂时找不到例子，以后补充 。</p>
<h1
id="操作系统线程和java线程的区别是什么">操作系统线程和Java线程的区别是什么</h1>
<p><strong>现今 Java
中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，比如在
Windows 中 Java 就是基于 Wind32 线程库来管理线程，且 Windows
采用的是一对一的线程模型</strong>。</p>
<p>在<strong>早期</strong>的操作系统中，所有的线程都是在用户空间下实现的，操作系统只能看到线程所属的进程，而不能看到线程。</p>
<p>从我们开发者的角度来理解用户级线程就是说：在这种模型下，我们需要自己定义线程的数据结构、创建、销毁、调度和维护等，这些线程运行在操作系统的某个进程内，然后操作系统直接对进程进行调度。</p>
<p>这种方式的好处一目了然，首先第一点，就是即使操作系统原生不支持线程，我们也可以通过库函数来支持线程；第二点，线程的调度只发生在用户态，避免了操作系统从内核态到用户态的转换开销。</p>
<p>当然缺点也很明显：由于操作系统看不见线程，不知道线程的存在，而 CPU
的时间片切换是以进程为维度的，所以如果进程中某个线程进行了耗时比较长的操作，那么由于用户空间中没有时钟中断机制，就会导致此进程中的其它线程因为得不到
CPU
资源而长时间的持续等待；另外，如果某个线程进行系统调用时比如缺页中断而导致了线程阻塞，此时操作系统也会阻塞住整个进程，即使这个进程中其它线程还在工作。</p>
<p>所谓内核级线程就是运行在内核空间的线程，
直接由内核负责，只能由内核来完成线程的调度。</p>
<p>几乎所有的<strong>现代</strong>操作系统，包括 Windows、Linux、Mac OS
X 和 Solaris 等，都支持内核线程。</p>
<p>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，<strong>支持多线程的内核就叫做多线程内核</strong>（Multi-Threads
Kernel）。</p>
<p>从我们开发者的角度来理解内核级线程就是说：我们可以直接使用操作系统中已经内置好的线程，线程的创建、销毁、调度和维护等，都是直接由操作系统的内核来实现，我们只需要使用系统调用就好了，不需要像用户级线程那样自己设计线程调度等。</p>
<h1
id="如何设计一个线程池设计线程池要关注哪些点">如何设计一个线程池，设计线程池要关注哪些点</h1>
<p>这种设计类问题还是一样，先说下理解，表明你是知道这个东西的用处和原理的，然后开始
BB。基本上就是按照现有的设计来说，再添加一些个人见解。</p>
<p>线程池讲白了就是存储线程的一个容器，池内保存之前建立过的线程来重复执行任务，减少创建和销毁线程的开销，提高任务的响应速度，并便于线程的管理。</p>
<p>我个人觉得如果要设计一个线程池的话得考虑池内工作线程的管理、任务编排执行、线程池超负荷处理方案、监控。</p>
<p>初始化线程数、核心线程数、最大线程池都暴露出来可配置，包括超过核心线程数的线程空闲消亡配置。</p>
<p>任务的存储结构可配置，可以是无界队列也可以是有界队列，也可以根据配置分多个队列来分配不同优先级的任务，也可以采用
stealing 的机制来提高线程的利用率。</p>
<p>再提供配置来表明此线程池是 IO 密集还是 CPU
密集型来改变任务的执行策略。</p>
<p>超负荷的方案可以有多种，包括丢弃任务、拒绝任务并抛出异常、丢弃最旧的任务或自定义等等。</p>
<p>线程池埋好点暴露出用于监控的接口，如已处理任务数、待处理任务数、正在运行的线程数、拒绝的任务数等等信息。</p>
<h1 id="docker镜像的作用">Docker镜像的作用</h1>
<p>镜像到底是什么？镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p>docker镜像的用处：1、镜像是Docker运行容器的前提，仓库是存放镜像的场所，更是Docker的核心；2、镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数。</p>
<h1 id="jvm中jit-compiler的作用">JVM中JIT Compiler的作用</h1>
<p>为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In
Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p>
<h1 id="java类中的初始化顺序">java类中的初始化顺序</h1>
<h2 id="初始化顺序">初始化顺序</h2>
<p>对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器。</p>
<h3 id="实例代码">实例代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialOrderTest</span> &#123;</span><br><span class="line">        <span class="comment">/* 静态变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line">        <span class="comment">/* 变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;变量&quot;</span>;</span><br><span class="line">        <span class="comment">/* 静态初始化块 */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println( staticField );</span><br><span class="line">        System.out.println( <span class="string">&quot;静态初始化块&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* 初始化块 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println( field );</span><br><span class="line">        System.out.println( <span class="string">&quot;初始化块&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* 构造器 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;构造器&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InitialOrderTest</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<p>运行以上代码，我们会得到如下的输出结果：</p>
<ol type="1">
<li>静态变量</li>
<li>静态初始化块</li>
<li>变量</li>
<li>初始化块</li>
<li>构造器</li>
</ol>
<h1 id="dns协议的作用">DNS协议的作用</h1>
<p>DNS协议说简单一点就是域名解析，将域名解析为IP地址。可以把它当作是一个电话本，用来记录某个人所对应的电话号码。我们熟悉的TCP/IP协议都是根据IP地址来访问远程主机。但是我们访问网址时，通常用的都是域名。比如访问百度这个网站，我们通常使用www.baidu.com这个域名来进行访问，而不是使用百度网站所对应的某个IP地址，比如220.181.38.150。因为域名比起IP地址而言，要好记很多。那如何将域名转化为其对应的某个或者是多个IP地址，就是由DNS协议所完成的工作。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/16/Convolutional%20Neural%20Network/" rel="prev" title="Convolutional Neural Network">
      <i class="fa fa-chevron-left"></i> Convolutional Neural Network
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%90%8C%E6%97%B6%E6%9F%A5%E8%AF%A2%E4%B8%A4%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.</span> <span class="nav-text">MySQL索引相关，联合索引，同时查询两个字段怎么建索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5select%E8%B5%B0%E6%B2%A1%E8%B5%B0%E7%B4%A2%E5%BC%95explain%E6%98%BE%E7%A4%BA%E6%9C%89%E7%B4%A2%E5%BC%95%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%B5%B0%E4%BA%86%E7%B4%A2%E5%BC%95%E5%90%97"><span class="nav-number">2.</span> <span class="nav-text">怎么查select走没走索引，explain显示有索引就一定走了索引吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">jvm内存结构及作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E6%98%BE%E7%A4%BA%E8%BF%87%E7%A8%8Bhttp%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%ABhttps%E6%80%8E%E4%B9%88%E5%8A%A0%E5%AF%86%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E7%A7%98%E9%92%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%8E%E4%B9%88%E5%8D%8F%E5%95%86"><span class="nav-number">4.</span> <span class="nav-text">在浏览器输入url，显示过程，http和https的区别，https怎么加密，对称加密的秘钥服务端和客户端怎么协商</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mq%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E7%94%A8mysql%E6%80%8E%E4%B9%88%E5%8E%BB%E9%87%8D"><span class="nav-number">5.</span> <span class="nav-text">mq怎么保证消费的幂等性，用Mysql怎么去重</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">为什么要保证幂等性？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8redis%E4%BF%9D%E8%AF%81mq%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89%E6%80%A7%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AEkey%E5%80%BC%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">6.</span> <span class="nav-text">用Redis保证mq消费幂等性，怎么设置key值的过期时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rabbitmq%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%A3%81%E7%9B%98%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97"><span class="nav-number">7.</span> <span class="nav-text">RabbitMQ怎么存储数据，会存在磁盘，内存中吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8spring%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E4%B8%8D%E7%94%A8spring%E6%80%8E%E4%B9%88%E5%BC%80%E5%8F%91"><span class="nav-number">8.</span> <span class="nav-text">使用spring有什么好处，不用spring怎么开发</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springmvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">SpringMVC工作流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mybatis%E5%92%8Cjdbc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">mybatis和jdbc的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%90%88%E5%B9%B6%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B6%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AAcommit"><span class="nav-number">11.</span> <span class="nav-text">怎么合并另一个分支的其中某一个commit</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">12.1.</span> <span class="nav-text">类加载的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-1"><span class="nav-number">12.2.</span> <span class="nav-text">类加载过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">13.</span> <span class="nav-text">redis数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="nav-number">14.</span> <span class="nav-text">过期删除&amp;内存淘汰</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lru"><span class="nav-number">15.</span> <span class="nav-text">LRU</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84i%E6%93%8D%E4%BD%9C"><span class="nav-number">16.</span> <span class="nav-text">多线程如何实现线程安全的i++操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E6%8A%A5%E6%96%87"><span class="nav-number">17.</span> <span class="nav-text">TCP报文</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux%E6%9F%A5%E6%89%BE%E6%96%87%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%91%BD%E4%BB%A4"><span class="nav-number">18.</span> <span class="nav-text">Linux查找文中某个字符串的位置命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E5%87%8F%E6%B5%81%E9%87%8F%E7%9A%84%E7%AE%97%E6%B3%95%E5%A4%A7%E8%87%B4%E5%B0%B1%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AA%E8%83%BD%E6%89%BF%E5%8F%97%E6%AF%8F%E7%A7%9220%E6%AC%A1%E7%9A%84%E8%AF%B7%E6%B1%82%E7%8E%B0%E5%9C%A8%E6%9C%89%E6%AF%8F%E7%A7%92100%E6%AC%A1%E8%AF%B7%E6%B1%82%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E8%BF%99%E6%A0%B7%E9%97%AE%E9%A2%98"><span class="nav-number">19.</span> <span class="nav-text">设计一个消减流量的算法（大致就是服务器只能承受每秒20次的请求，现在有每秒100次请求。设计一个算法解决这样问题）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E7%9A%84bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">20.</span> <span class="nav-text">Spring的Bean生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">21.</span> <span class="nav-text">Spring的动态代理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list%E5%92%8Cset%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">22.</span> <span class="nav-text">List和Set的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashset%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%8E%BB%E9%87%8D"><span class="nav-number">23.</span> <span class="nav-text">hashset为什么能去重</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8Brun%E5%92%8Ccall%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">24.</span> <span class="nav-text">多线程执行一个任务的流程，run和call的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="nav-number">25.</span> <span class="nav-text">Java的并行流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%87%BA%E5%89%8Dk%E5%A4%A7%E6%95%B0topk%E9%97%AE%E9%A2%98"><span class="nav-number">26.</span> <span class="nav-text">海量数据中找出前k大数（topk问题）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cms%E7%9A%84%E8%BF%87%E7%A8%8B%E9%82%A3%E4%BA%9B%E6%98%AF%E5%B9%B6%E5%8F%91%E7%9A%84"><span class="nav-number">27.</span> <span class="nav-text">CMS的过程，那些是并发的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0cms-initial-mark"><span class="nav-number">27.0.1.</span> <span class="nav-text">1） 初始标记（CMS initial mark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0cms-concurrent-mark"><span class="nav-number">27.0.2.</span> <span class="nav-text">2）并发标记（CMS concurrent
mark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0cms-remark"><span class="nav-number">27.0.3.</span> <span class="nav-text">3）重新标记（CMS remark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4cms-concurrent-sweep"><span class="nav-number">27.0.4.</span> <span class="nav-text">4）并发清除（CMS concurrent
sweep）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">27.0.5.</span> <span class="nav-text">5）小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A0%B5%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">28.</span> <span class="nav-text">线程池堵塞队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">29.</span> <span class="nav-text">spring事务传播机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">29.1.</span> <span class="nav-text">传播机制类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#propagation_required-%E9%BB%98%E8%AE%A4"><span class="nav-number">29.1.1.</span> <span class="nav-text">PROPAGATION_REQUIRED (默认)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#requires_new"><span class="nav-number">29.1.2.</span> <span class="nav-text">REQUIRES_NEW</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nested"><span class="nav-number">29.1.3.</span> <span class="nav-text">NESTED</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#supports"><span class="nav-number">29.1.4.</span> <span class="nav-text">SUPPORTS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#not_supported"><span class="nav-number">29.1.5.</span> <span class="nav-text">NOT_SUPPORTED</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mandatory"><span class="nav-number">29.1.6.</span> <span class="nav-text">MANDATORY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#never"><span class="nav-number">29.1.7.</span> <span class="nav-text">NEVER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%82%B9%E5%B0%8F%E8%AF%B4%E6%98%8E"><span class="nav-number">29.1.8.</span> <span class="nav-text">一点小说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E5%92%8Cjava%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">30.</span> <span class="nav-text">操作系统线程和Java线程的区别是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A6%81%E5%85%B3%E6%B3%A8%E5%93%AA%E4%BA%9B%E7%82%B9"><span class="nav-number">31.</span> <span class="nav-text">如何设计一个线程池，设计线程池要关注哪些点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E9%95%9C%E5%83%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">32.</span> <span class="nav-text">Docker镜像的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E4%B8%ADjit-compiler%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">33.</span> <span class="nav-text">JVM中JIT Compiler的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">34.</span> <span class="nav-text">java类中的初始化顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">34.1.</span> <span class="nav-text">初始化顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">34.1.1.</span> <span class="nav-text">实例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">34.1.2.</span> <span class="nav-text">输出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dns%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">35.</span> <span class="nav-text">DNS协议的作用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aeowind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aeowind</p>
  <div class="site-description" itemprop="description">爱上一场认真的消遣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aeowind" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aeowind" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/129971630/" title="douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;129971630&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>douban</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aeowind</span>
</div>



  <script>
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        document.title = '(*^▽^*)我藏好了哦~' + OriginTitle;
        clearTimeout(titleTime);
      } else {
        document.title = 'q(≧▽≦q)被你发现啦~' + OriginTitle;
        titleTime = setTimeout(function() {
          document.title = OriginTitle;
        }, 2000);
      }
    });
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->

      <script type="text/javascript" src="/js/clicklove.js"></script>

